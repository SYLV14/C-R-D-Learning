# 基础知识

## 计算机单位

- bit和Byte
  
    bit --- 比特 --- 1个比特位可存1个二进制（0，1） --- 计算机中最小的存储单位
    
    byte --- 字节 --- 8个比特位等于1个字节（如：10110011） --- 计算计中最基本的存储单元
    
    💡 1个字节总共有2^8^种二进制序列，最小可表示十进制0，最大可表示2^8^-1即255
    
- 计算机单位间的互相转换
  
    1 Byte = 8 bit
    
    1 KB = 1024 Byte
    
    1 MB = 1024 KB
    
    1 GB = 1024 MB
    
    1 TB = 1024 GB
    

## 认识进制

- 四种进制形式

    二进制B： 由0和1两个数字组成

    八进制Q： 由0-7数字组成，为了区分与其他进制的数字区别，**开头都是以0开始**

    十进制D： 都是以0-9这九个数字组成，不能以0开头

    十六进制H：由0-9和A-F组成。为了区分于其他数字的区别，**开头都是以0x开始**

- **整数进制表**

| 二进制 | 八进制 | 十进制 | 十六进制 |
| --- | --- | --- | --- |
| 0000 | 0 | 0 | 0 |
| 0001 | 1 | 1 | 1 |
| 0010 | 2 | 2 | 2 |
| 0011 | 3 | 3 | 3 |
| 0100 | 4 | 4 | 4 |
| 0101 | 5 | 5 | 5 |
| 0110 | 6 | 6 | 6 |
| 0111 | 7 | 7 | 7 |
| 1000 | 10 | 8 | 8 |
| 1001 | 11 | 9 | 9 |
| 1010 | 12 | 10 | A |
| 1011 | 13 | 11 | B |
| 1100 | 14 | 12 | C |
| 1101 | 15 | 13 | D |
| 1110 | 16 | 14 | E |
| 1111 | 17 | 15 | F |
- **小数进制表**

| 指数 | 二进制 | 十进制 |
| --- | --- | --- |
| 2^-1 | .1 | .5 |
| 2^-2 | .01 | .25 |
| 2^-3 | .001 | .125 |
| 2^-4 | .0001 | .0625 |
| 2^-5 | .00001 | .03125 |
| 2^-6 | .000001 | .015625 |

💡 8进制和16进制只能用来表示无符号的数。


## 进制转换


- **十进制转换为二进制、八进制、十六进制**

    - 整数转换

    **原理1：**除以2/8/16，取余数，直到商为0终止，然后反向输出余数。

    **原理2：**十进制转二进制可以反向思考二进制转十进制，十进制转八/十六进制可以先转二进制再转八/十六进制。

    十进制转二进制：

    原理1：比如91，45余1 — 22余1 — 11余0 — 5余1 — 2余1 — 1余0 — 0余1，即01011011

    原理2：比如352，就是256+64+32，即 0001 0110 0000

    - 小数转换

    **原理：**乘2/8/16取整，顺序输出

    比如0.68 D转换成二进制，精确到小数点后5位：

    0.68*2=1.36 — 1

    0.36*2=0.72 — 0

    0.72*2=1.44 — 1

    0.44*2=0.88 — 0

    0.88*2=1.76 — 1

    即0.68 D=0.10101 B

- **二进制、八进制、十六进制转十进制**

    **原理：**举例二进制10101101.0101转换成十进制173.9375，八/十六进制转换十进制同理。
    $$
    1*2^7+0*2^6+1*2^5+0*2^4+1*2^3+1*2^2+0*2^1+1*2^0+0*2^{-1}+1*2^{-2}+0*2^{-3}+1*2^{-4}=173.9375
    $$

- **二进制与八进制和十六进制的转换**
  
    - 二进制转八进制原理：取三合一法，即从二进制的小数点为分界点，向左（或向右）每三位取成一位。
    - 二进制转十六进制原理：取四合一法，即从二进制的小数点为分界点，向左（或向右）每四位取成一位。

# 认识C语言

## 变量、常量

### 局部变量与全局变量

当局部变量和全局变量同名的时候，局部变量优先使用。

**全局变量和`static`静态变量默认初始化为0。**

### 标识符/变量的命名规则

1. 只能由**数字、字母（区分大小写）、下划线**组成
2. 不能以数字开头
3. 不能是关键字
4. 长度不能超过63个字符

### 变量的作用域和生命周期

- **作用域**

  1. 局部变量的作用域是变量所在的局部范围

  2. 全局变量的作用域是整个工程


- **生命周期**

  1. 局部变量的生命周期是：进入作用域生命周期开始，出作用域生命周期结束

  2. 全局变量的生命周期是：整个程序的生命周期


### 常量

**C语言中的常量分为以下以下几种**：字面常量、`const` 修饰的**常变量**、`#define` 定义的标识符常量、枚举常量

```c
#include <stdio.h>
//举例
enum Sex
{
 MALE,
 FEMALE,
 SECRET
};
//括号中的MALE,FEMALE,SECRET是枚举常量
int main()
{
    //字面常量演示
    3.14;//字面常量
    1000;//字面常量
    
    //const 修饰的**常变量**
    const float pai = 3.14f;   //这里的pai是const修饰的常变量
    pai = 5.14;//是不能直接修改的！
    
    //#define的标识符常量 演示
		#define MAX 100
    printf("max = %d\n", MAX);
    
    //枚举常量演示
    printf("%d\n", MALE);//0
    printf("%d\n", FEMALE);//1
    printf("%d\n", SECRET);//2
    //注：枚举常量的默认是从0开始，依次向下递增1的
    return 0;
}
```

## 字符串+转义字符

### 字符串

`"hello world"`这种由双引号（Double Quote）引起来的一串字符称为字符串字面值（String Literal），或者简称字符串。
**字符串的结束标志是一个 \0 的转义字符**。在计算字符串长度的时候 \0 是结束标志，不算作字符串内容。

```c
#include<stdio.h>
#include<string.h>
int main() {
	char arr1[] = "bit";
	char arr2[] = { 'b','i','t' };
	char arr3[] = { 'b','i','t','\0' };
	printf("%s\n", arr1);//bit
	printf("%s\n", arr2);//bit+乱码
	printf("%s\n", arr3);//bit
	printf("%d\n", strlen(arr1));//3
	printf("%d\n", strlen(arr2));//随机值
	printf("%d\n", strlen(arr3));//3
	return 0;
}
```

### 转义字符

| 转义字符 | 释义 |
| :-- | --- |
| \? | 在书写连续多个问号时使用，防止他们被解析成三字母词 |
| \’ | 用于表示字符常量' |
| \” | 用于表示一个字符串内部的双引号 |
| \\\ | 用于表示一个反斜杠，防止它被解释为一个转义序列符。 |
| \a | 警告字符，蜂鸣 |
| \b | 退格符 |
| \f | 进纸符 |
| \n | 换行 |
| \r | 回车 |
| \t | 水平制表符 |
| \v | 垂直制表符 |
| \ddd | ddd表示1~3个八进制的数字。 如： \130 X |
| \xdd | dd表示2个十六进制数字。 如： \x30  |

## 关键字

- `register` 作用是建议将变量放入寄存器，一般不用
  
    ```c
    register int a = 10;
    ```
    
- `static` 修饰局部变量，修饰全局变量，修饰函数
  
    `static`修饰的局部变量**没有赋值时，默认赋值为 0**，**局部变量被放在静态区，直到程序结束释放，但不会影响作用域**。
    
    ```c
    //static 修饰局部函数
    #include<stdio.h>
    void test() {
    	static int a = 0;
    	a++;
    	printf("%d ", a);
    }
    int main() {
    	int i = 0;
    	while (i < 10) {
    		test();
    		i++;
    	}
    	return 0;
    }
    //打印结果为1 2 3 4 5 6 7 8 9 10
    ```
    
    `static`修饰全局变量，全局变量本身是具有外部链接属性的，但如果被static修饰，这个外部链接属性就变成了内部链接属性，这个全局变量就只能在自己的所在的源文件中使用
    
    ```c
    //add.c文件中定义
    int g_val = 100;
    //test.c文件中声明
    extern int g_val;
    int main() {
    	printf("%d\n", g_val);//正常执行
    	return 0;
    }
    ```
    
    ```c
    //add.c文件中定义
    static int g_val = 100;
    //test.c文件中声明
    extern int g_val;
    int main() {
    	printf("%d\n", g_val);//error
    	return 0;
    }
    ```
    
    `static`修饰函数，与修饰全部变量类似

## `define` 定义常量和宏

```c
#define M 100	//define 定义常量
#define MAX(x,y) (x>y?x:y)//define 定义宏
```

# 分支和循环语句

## 分支语句

### if语句

```c
语法结构：
if(表达式)
    语句;
//双分支
if(表达式)
    语句1;
else
    语句2;
//多分支    
if(表达式1)
    语句1;
else if(表达式2)
    语句2;
else
    语句3;
```

如果表达式的结果为真，则语句执行。在C语言中**0表示假，非0表示真。**

如果条件成立，要执行多条语句，应该使用{...}代码块。

```c
if(表达式)
{
    语句列表1；
}
else
{
    语句列表2；
}
```

**悬空`else`**：`else`与最近的if结合

```c
#include <stdio.h>
int main()
{
    int a = 0;
    int b = 2;
    if(a == 1)
        if(b == 2)
            printf("hehe\n");
    else
        printf("haha\n");
    return 0;
}
//无打印结果，因为else与if(b==2)结合，而不是if(a==1),且a==1表达式的结果为0，所以无打印结果
```

```c
//书写不规范的代码
//代码1
if (condition) {
    return x;
}
return y;
//代码2
int num = 1;
if(num == 5)
{
    printf("hehe\n");
}
```

```c
//规范的代码
//代码1
if(condition)
{
    return x;
}
else
{
    return y;
}
//代码2
int num = 1;
if(5 == num)
{
    printf("hehe\n");
}
```

### switch语句

```c
语句结构：
switch (整型表达式)
{
    case 整形常量表达式:
        语句;
    default:
        写在任何一个case标签可以出现的位置。
}
```

> 如果表达式的值与所有的`case`标签值都不匹配，则执行`default`中的语句。
> `default` 写在任何一个`case`标签可以出现的位置。
> 每个`switch`中只能有一个`default`。

```c
//输入1-7，打印对应的星期
#include <stdio.h>
int main()
{
    int day = 0;
    switch(day)
   {
        case 1：
            printf("星期一\n");
            break;
        case 2:
            printf("星期二\n");
            break;
        case 3:
            printf("星期三\n");
            break;    
        case 4:
            printf("星期四\n");
            break;    
        case 5:
            printf("星期五\n");
            break;
        case 6:
            printf("星期六\n");
            break;
        case 7:
            printf("星期天\n");    
            break;
   }
    return 0;
}
//输入1-5输出的是“weekday”，输入6-7输出“weekend”
#include <stdio.h>
int main()
{
    int day = 0;
    switch (day)
    {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
            printf("weekday\n");
            break;
        case 6:
        case 7:
            printf("weekend\n");
            break;
        default:
            printf("error\n");
            break;
    }
    return 0;
}
```

## 循环语句

### `while`

```c
语法结构：
while(表达式){
    循环语句；
}
```

**`while`语句中的`break`和`continue`：**

```c
#include<stdio.h>
int main() {
	int n = 0;
	while (n < 10) {
	  n++;
		if (5 == n) {
			continue;
		}
		if (8 == n) {
			break;
		}
		printf("%d ", n);
	}
	return 0;
}
//1 2 3 4 6 7 
```

> `break`的作用：`break`是用于终止循环，在循环中只要遇到`break`，就直接跳出循环。
>
> `continue`的作用：`continue`是用于终止本次循环的，也就是本次循环中`continue`后面的代码不会再执行，而是直接跳转到`while`语句的判断部分。进行下一次循环的入口判断。

**循环输入字符**

```c
#include <stdio.h>
int main()
{
    int ch = 0;
    while ((ch = getchar()) != EOF)
        putchar(ch);
    return 0;
}
//按ctrl+Z停止循环
```

###  `for`

```c
语句结构：
for(初始化条件表达式；循环判断表达式；调整表达式){
    循环语句；
}
```

建议for语句的循环控制变量的取值采用“<u>前闭后开区间</u>”写法

```c
int i = 0;
//前闭后开的写法
for(i=0; i<10; i++)
{}
```

一些for循环变种：<u>for循环中的初始条件表达式、循环判断表达式与调整表达式均可省略</u>

```c
#include <stdio.h>
int main()
{
    //变种1：死循环
    for (;;)
    {
        printf("hehe\n");
    }
    //变种2
    int x, y;
    for (x = 0, y = 0; x < 2 && y < 5; ++x, y++)
    {
        printf("hehe\n");
    }
    return 0;
}
```

### `do...while`

```c
语句结构：
do{
    循环语句；
}while(循环判断表达式);
```

`do...while`循环**至少执行一次**，使用的场景有限，所以不是经常使用

### **练习**

```c
// 计算 1!+2!+3!+……+10!
#include<stdio.h>
int main() {
	int i = 0, ret = 1, sum = 0;
	for (i = 1; i <= 3; i++) {
		ret *= i;
		sum += ret;
	}
	printf("%d\n", sum);
	return 0;
}

//演示多个字符从两端移动，向中间汇聚
#include<stdio.h>
#include<string.h>
#include<windows.h>
#include<stdlib.h>
int main() {
	char str1[] = "welcome to bit!!!";
	char str2[] = "#################";
	int left = 0, right = strlen(str1) - 1;
	printf("%s\n", str2);
	while (left <= right) {
		str2[left] = str1[left];
		str2[right] = str1[right];
		left++;
		right--;
		Sleep(1000);//实现睡眠，单位是毫秒
		system("cls");//system是一个库函数，用于执行系统命令，cls是清空屏幕的命令
		printf("%s\n", str2);
	}
	return 0;
}
```

- **sleep函数**

  windows下函数名为`Sleep()`，其函数头文件为：`#include <windows.h>`，函数原型为`void Sleep(DWORD dwMilliseconds);` 参数为<u>毫秒</u>

  linux下函数名`sleep()`，其函数头文件为：`#include <unistd.h>`，函数原型为`unsigned int sleep(unsigned int seconds);` 参数为<u>秒</u> （更精确用`usleep`，微秒）

## goto语句

goto语句只能在同一函数内部跳转，不能跨函数跳转

```c
//关机程序
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
int main() {
	char input[20] = { 0 };
	system("shutdown -s -t 60");
again:
	printf("请注意你的电脑将在1分钟后关机，如果输入：我是猪，则取消关机\n");
	scanf("%s", input);
	if (0 == strcmp(input, "我是猪")) {
		printf("这就取消关机\n");
		system("shutdown -a");
	}
	else {
		goto again;
	}
	return 0;
}
```

- **system函数**

​	函数头文件为：`#include<stdlib.h>`，函数原型为：`int system (const char* command);`

​	如果为 `null` 指针，则该函数仅检查命令处理器是否可通过此函数使用，而不调用任何命令。
​	调用命令的效果取决于系统和库的实现，并可能导致程序以非标准方式运行或终止。

```c
#include<stdio.h>
#include<string.h>
#include<stdlib.h>
int print()
{
    printf("---------------------------------------\n");
    printf("-----------  C语言关机程序  -----------\n");
    printf("----1.实现10分钟内的定时关闭计算机-----\n");
    printf("----2.立即关闭计算机-------------------\n");
    printf("----3.注销计算机-----------------------\n");
    printf("----4.取消自动计算机-------------------\n");
    printf("----0.退出系统-------------------------\n");
    printf("---------------------------------------\n");
    return 0;
}
int main()
{
    system("title C语言关机程序");//设置cmd窗口标题
    system("mode con cols=48 lines=25");//窗口宽度高度
    system("color 0B");
    system("date /T");
    system("TIME /T");
    char cmd[20] = "shutdown -s -t ";
    char t[5] = "0";
    print();
    int c;
    scanf("%d", &c);
    getchar();
    switch (c)
    {
        case 1:printf("您想在多少秒后自动关闭计算机？（0~600）\n"); 
            scanf("%s", t);
            system(strcat(cmd, t)); break;
        case 2:system("shutdown -p"); break;
        case 3:system("shutdown -l"); break;
        case 4:system("shutdown -a"); break;
        case 0:break;
        default:printf("Error!\n");
    }
    system("pause");
    return 0;
}
```

## 猜数字游戏

```c
#include<stdio.h>
#include<stdlib.h>
#include<time.h>
void meun() {
	printf("***************\n");
	printf("****1. PLAY****\n");
	printf("****0. EXIT****\n");
	printf("***************\n");
}
void game() {
    //1-100的随机数
	int ret = rand() % 100 + 1;
	int num;
	while (1) {
		scanf("%d", &num);
		if (num > ret) {
			printf("猜大了\n");
		}
		else if (num < ret) {
			printf("猜小了\n");
		}
		else {
			printf("猜中了\n");
			break;
		}
	}
}
int main() {
	int input = 0;
    //初始化随机数函数
	srand((unsigned int)time(NULL));
	do {
		meun();
		scanf("%d", &input);
		switch (input) {
		case 1:
			printf("游戏开始\n");
			game();
			break;
		case 0:
			printf("退出游戏\n");
			break;
		default:
			printf("重新输入\n");
			break;
		}
	} while (input);
	return 0;
}
```

- **随机数函数**

1. rand()生成随机数函数，头文件为`#include<stdlib.h>`，函数原型为`int rand (void);`
   rand函数会返回⼀个伪随机数，这个随机数的范围是在0~RAND_MAX之间，这个RAND_MAX的大小是依赖编译器上实现的，但是大部分编译器上是32767。
2. srand()初始化随机数生成器函数，头文件为`#include<stdlib.h>`，函数原型为`void srand (unsigned int seed);`
   程序中在调用 rand 函数之前先调用 srand 函数，通过 srand 函数的参数seed来设置rand函数生成随机数的时候的种子，只要种子在变化，每次生成的随机数序列也就变化起来了。
   srand函数在程序中只需调一次即可，频繁重复调用可能会使得种子差距很小或一样，从而使得随机数差距很小或相同。
3. time()时间函数，头文件为`#include<time.h>`，函数原型为`time_t time (time_t* timer);`
   返回的值通常表示自 1970 年 1 月 1 日 00：00以来的秒数（即当前 *unix 时间戳*）。
   time函数的参数 timer 如果是非NULL的指针的话，函数也会将这个返回的差值放在timer指向的内存中带回去。如果timer 是NULL，就只返回这个时间的差值。

```c
#include<stdio.h>
#include<stdlib.h>
#include<time.h>
int main() {
	srand((unsigned int)time(NULL));
	int ret1 = rand() % 100;		//0~99
	int ret2 = rand() % 100 + 1;	//1~100
	int ret3 = rand() % 101 + 100;	//100~200
	printf("%d\n", ret1);
	printf("%d\n", ret2);
	printf("%d\n", ret3);
	return 0;
}
```

## 练习

```c
//打印1-100之间所有3的倍数的数字
#include<stdio.h>
int main()
{
	int i;
	for (i = 3; i < 100; i += 3)
		printf("%d ", i);
	return 0;
}

//将三个整数从大到小输出
#include<stdio.h>
void swap(int* a, int* b) {
	int temp = *a;
	*a = *b;
	*b = temp;
}
int main()
{
	int a = 2, b = 3, c = 1;
	if (a < b)
		swap(&a, &b);
	if (a < c)
		swap(&a, &c);
	if (b < c)
		swap(&b, &c);
	printf("%d %d %d\n", a, b, c);
	return 0;
}

//打印1000年到2000年之间的闰年
#include<stdio.h>
int is_leap_year(int y) {
	return (y % 400 == 0) || (y % 4 == 0 && y % 100 != 0);
}
int main()
{
	int i;
	for (i = 1000; i < 2000; i++)
		if (is_leap_year(i))
			printf("%d ", i);
	return 0;
}

//打印100-200之间的素数
//方法：如果i能够被[2, sqrt(i)]之间的任意数据整除，则i不是素数。因为如果 m 能被 2 ~ m-1 之间任一整数整除，其二个因子必定有一个小于或等于sqrt(m)，另一个大于或等于 sqrt(m)。但是实际在操作时i不用从101逐渐递增到200，因为除了2和3之外，不会有两个连续相邻的数据同时为素数
#include<stdio.h>
#include<math.h>
int is_prime(int x) {
	if (x < 2)
		return 0;
	int i;
	for (i = 2; i <= sqrt(x); i++)
		if (x % i == 0)
			return 0;
	return 1;
}
int main()
{
	int i;
	for (i = 101; i <= 200; i += 2)
		if (is_prime(i))
			printf("%d ", i);
	return 0;
}

//给定两个数，求这两个数的最大公约数
//方法：辗转相除法，先用小的一个数除大的一个数,得第一个余数；再用第一个余数除小的一个数,得第二个余数；又用第二个余数除第一个余数,得第三个余数；这样逐次用后一个数去除前一个余数,直到余数是0为止.那么,最后一个除数就是所求的最大公约数
#include<stdio.h>
int main() {
	int a = 10;
	int b = 20;
	int c = 0;
	while (c = a % b) {
		a = b;
		b = c;
	}
	printf("%d\n", b);
	return 0;
}
#include<stdio.h>
int GCD(int a, int b) {
	if (b == 0)
		return a;
	else
		return GCD(b, a % b);
}
int main() {
	int a = 10;
	int b = 20;
	printf("%d\n", GCD(a, b));
	return 0;
}
```

# 函数

## 库函数

- 简单的总结，C语言常用的库函数都有：
  
    I/O函数、字符串操作函数、字符操作函数、内存操作函数、时间/日期函数、数学函数、其他库函数
    

## 自定义函数

```c
ret_type fun_name(para1, * ) 
{ 
	statement;//语句项 
} 
```

函数的返回类型不写时，默认返回的是int类型，注意不要写模棱两可的代码

### 函数的调用

1. **值传递**：函数的形参和实参分别占有不同内存块，对形参的修改不会影响实参。
2. **地址传递**：地址传递把实参的存储地址传送给对应的形参，从而使得形参指针和实参指针指向同一个地址。因此，被调用函数中对形参指针所指向的地址中内容的任何改变都会影响到实参。
3. **引用传递（C++）**：以引用为参数，则既可以使得对形参的任何操作都能改变相应的数据，又使得函数调用显得方便、自然。引用传递方式是在函数定义时在形参前面加上引用运算符“&”。引用相当于实参的别名，他和实参是同一个变量或数值，它的改变就是实参的改变。

```c
#include<stdio.h>
void change1(int n)
{
    n = 200;
    printf("函数操作的地址>>%p\n", &n);
}
void change2(int* n)
{
    *n = 200;
    printf("函数操作的地址>>%p\n", n);
}
void change3(int &n)
{
    n = 300;
    printf("函数操作的地址>>%p\n", &n);
}
int main()
{
    int n = 100;
    printf("原值>>%d\n", n);
    printf("原址>>%p\n\n", &n);
    printf("值传递\n");
    change1(n);
    printf("修改后的值>>%d\n\n", n);
    printf("地址传递\n");
    change2(&n);
    printf("修改后的值>>%d\n\n", n);
    printf("引用传递\n");
    change3(n);
    printf("修改后的值>>%d\n", n);
    return 0;
}
//原值 >> 100
//原址 >> 000000BBC79CF994
//
//值传递
//函数操作的地址 >> 000000BBC79CF970
//修改后的值 >> 100
//
//地址传递
//函数操作的地址 >> 000000BBC79CF994
//修改后的值 >> 200
//
//引用传递
//函数操作的地址 >> 000000BBC79CF994
//修改后的值 >> 300
```

- **二分查找**

```c
//写一个函数，实现一个整形有序数组的二分查找
#include<stdio.h>
int binary_search(int arr[], int sz, int k) 
{
	int left = 0;
	int right = sz - 1;
	int mid;
	while (left <= right)
	{
		mid = (left + right) / 2;
		if (arr[mid] > k)
			right = mid - 1;
		else if (arr[mid] < k)
			left = mid + 1;
		else
			return mid;
	}
	return -1;
}
```

### 函数的嵌套调用和链式访问

函数可以嵌套调用，不能嵌套定义

链式访问：把一个函数的返回值作为另外一个函数的参数

```c
int main()
{
	printf("%d", printf("%d", printf("%d", 43))); //printf函数返回值为打印字符个数
	//4321
	return 0;
}
```

### 函数的声明和定义

```c
//add.h的内容
#include<stdio.h>
int Add(int x, int y);//函数声明
//add.c的内容
int Add(int x, int y)//函数定义
{
	return x + y;
}
//test.c的内容
#include"add.h"//调用头文件
int main()
{
	int a = 2, b = 3;
	printf("%d\n", Add(a, b));//函数调用
	return 0;
}

//也可以使用extern调用
#include<stdio.h>
extern int Add(int x, int y);
int main()
{
	int a = 2, b = 3;
	printf("%d\n", Add(a, b));
	return 0;
}
```

### 递归与迭代

> **递归的两个必要条件**
存在限制条件，当满足这个限制条件的时候，递归便不再继续。
每次递归调用之后越来越接近这个限制条件。

```c
//接受一个整型值（无符号），按照顺序打印它的每一位。 例如： 输入：1234，输出 1 2 3 4
#include<stdio.h>
void Print(unsigned int n)
{
	if (n > 9)
	{
		Print(n / 10);
	}
	printf("%d ", n % 10);

}
int main()
{
	unsigned int num = 0;
	scanf("%u", &num);
	Print(num);
	return 0;
}

//编写函数不允许创建临时变量，求字符串的长度。
#include<stdio.h>
int my_strlen(char* str)
{
	if (*str != '\0')
		return 1 + my_strlen(str + 1);
	else
		return 0;
}

//求n的阶乘
#include<stdio.h>
int fac1(int n)//递归
{
	if (n > 1)
		return n * fac1(n - 1);
	else
		return 1;
}
int fac2(int n)//迭代
{
	int i;
	int ret = 1;
	for (i = 1; i <= n; i++)
	{
		ret *= i;
	}
	return ret;
}
int main()
{
	int n = 0;
	scanf("%d", &n);
	printf("%d\n", fac1(n));
	printf("%d\n", fac2(n));
	return 0;
}

//字符串逆序
#include<stdio.h>
#include<string.h>
void reverse_string(char arr[]) {
	int sz = strlen(arr);
	if (sz <= 1)
		return;
	char temp = *arr;
	*arr = *(arr + sz - 1);
	*(arr + sz - 1) = '\0';
	reverse_string(arr + 1);
	*(arr + sz - 1) = temp;

}
int main() {
	char arr[] = "abcdef";
	reverse_string(arr);
	printf("%s\n", arr);
	return 0;
}
```

```c
//求第n个斐波那契数
long long fib1(int n)//递归
{
	if (n <= 2)
		return 1;
	else
		return fib1(n - 1) + fib1(n - 2);
}
long long fib2(int n)//迭代
{
	long long f1 = 1, f2 = 1;
	long long f = 1;
	while (n > 2)
	{
		f = f1 + f2;
		f1 = f2;
		f2 = f;
		n--;
	}
	return f;
}
int main()
{
	int n;
	scanf("%d", &n);
	printf("%lld\n", fib1(n));
	return 0;
}
```

为什么斐波那契额函数的递归写法不如迭代写法效率高？
因为递归运算中包含太多重复运算，如在计算fib1(5)的过程中，fib1(1)计算了2次、fib1(2)计算了3次，fib1(3)计算了2次，而迭代运算中只需要5次迭代即可计算出。
![img](https://cdn.jsdelivr.net/gh/SYLV14/PicGo_Save/typora_images/202406112239383.webp)

> 结论：
>
> 1. 许多问题是以递归的形式进行解释的，这只是因为它比非递归的形式更为清晰。
> 2. 但是这些问题的迭代实现往往比递归实现效率更高，虽然代码的可读性稍微差些。（斐波那契函数）
> 3. 当一个问题相当复杂，难以用迭代实现时，此时递归实现的简洁性便可以补偿它所带来的运行时开销。

**自主研究**

汉诺塔、青蛙跳台

## 函数栈帧的创建与销毁

### 了解main函数

**main函数的多种写法**：

1. `void main()`
   C/C++ 标准中从来没有定义过`void main()` 这种写法，虽然在一些编译器中，`void main()` 可以通过编译（如 vc6），但并非所有编译器都支持。一定不要使用`void main()`。
2. `main()`
   在 C89 中，`main()` 是可以接受的。后来的改进版为了兼容以前的代码于是规定：不明确标明返回值的，默认返回值为int。但是还是不建议使用`main()`。
3. `int main(void)`
   在最新的 C99 标准中，定义了这种定义方式。**main 函数的返回值类型必须是 int ，这样返回值才能传递给程序的激活者（如操作系统）。**如果 main 函数的最后没有写 return 语句的话，C99 规定编译器要自动在生成的目标文件中（如 exe 文件）加入return 0。
4. `int main()`
   C++98 中定义这种定义方式，`int main()` 等同于 C99 中的 `int main( void )` 。**强烈建议使用这种定义方式**。
5. `int main(int argc,char *argv[])`
   在最新的 C99 和C++98中都定义了这种方式，用法相同。如果不需要从命令行中获取参数，请用`int main()` 或`int main(void)` ，否则请用`int main( int argc, char *argv[] )` 。

众所周知，一段代码运行一定是从main函数开始执行的，但是main函数其实也是被调用的。

![image-20240601230537914](https://cdn.jsdelivr.net/gh/SYLV14/PicGo_Save/typora_images/202406112239384.png)

在VS2022编译环境下，main函数是被invoke_main函数调用的，

![image-20240601230650390](https://cdn.jsdelivr.net/gh/SYLV14/PicGo_Save/typora_images/202406112239385.png)

而invoke_main函数又是被main_result函数调用的，

![image-20240601230757262](https://cdn.jsdelivr.net/gh/SYLV14/PicGo_Save/typora_images/202406112239386.png)

类似这样逐层调用的，具体调用多少层函数由编译器实现。

### 详解函数栈帧的创建与销毁

```c++
int main() {
00181840  push        ebp  
00181841  mov         ebp,esp  
00181843  sub         esp,0E4h  
00181849  push        ebx  
0018184A  push        esi  
0018184B  push        edi  
0018184C  lea         edi,[ebp-24h]  
0018184F  mov         ecx,9  
00181854  mov         eax,0CCCCCCCCh  
00181859  rep stos    dword ptr es:[edi]  
	int a = 10;
0018185B  mov         dword ptr [ebp-8],0Ah  
	int b = 20;
00181862  mov         dword ptr [ebp-14h],14h  
	int c = Add(a, b);
00181869  mov         eax,dword ptr [ebp-14h]  
0018186C  push        eax  
0018186D  mov         ecx,dword ptr [ebp-8]  
00181870  push        ecx  
00181871  call        001810B9  
00181876  add         esp,8  
00181879  mov         dword ptr [ebp-20h],eax  
	printf("%d\n", c);
0018187C  mov         eax,dword ptr [ebp-20h]  
0018187F  push        eax  
00181880  push        187B30h  
00181885  call        001810D7  
0018188A  add         esp,8  
	return 0;
0018188D  xor         eax,eax  
}
0018188F  pop         edi  
00181890  pop         esi  
00181891  pop         ebx  
00181892  add         esp,0E4h  
00181898  cmp         ebp,esp  
0018189A  call        00181253  
0018189F  mov         esp,ebp  
001818A1  pop         ebp  
001818A2  ret  
```

- **main函数调用前栈帧情况**：

<img src="https://cdn.jsdelivr.net/gh/SYLV14/PicGo_Save/typora_images/202406112239387.png" alt="image-20240602153450799" style="zoom: 50%;" />

- **函数栈帧的创建**：

```c++
00181840  push        ebp  			//将ebp中的内容压栈，此时ebp中存放的是invoke_main函数栈帧的基底地址
00181841  mov         ebp,esp  		//将esp的值拷贝给ebp，此时的ebp为main函数栈帧的基底地址
00181843  sub         esp,0E4h  	//将esp的值减0E4H，此时运算后的esp为main函数栈帧的基顶地址
00181849  push        ebx  			//将寄存器ebx的值压栈
0018184A  push        esi  			//将寄存器esi的值压栈
0018184B  push        edi  			//将寄存器edi的值压栈
0018184C  lea         edi,[ebp-24h] //将ebp-24H的值存放入edi
0018184F  mov         ecx,9  		//把ecx的值设为9
00181854  mov         eax,0CCCCCCCCh  //把eax的值设为0xCCCCCCCC
00181859  rep stos    dword ptr es:[edi]//将ebp-4H至[edi]的9个4B内存空间初始化为0xCCCCCCCC
```

<img src="https://cdn.jsdelivr.net/gh/SYLV14/PicGo_Save/typora_images/202406112239388.png" alt="image-20240602155032736" style="zoom:50%;" />

```c++
	int a = 10;
0018185B  mov         dword ptr [ebp-8],0Ah  //将0AH存入ebp-8的内存空间
	int b = 20;
00181862  mov         dword ptr [ebp-14h],14h  //将14H存入ebp-14的内存空间
	int c = Add(a, b);
00181869  mov         eax,dword ptr [ebp-14h]  //传递b，将ebp-14内存空间的内容存入eax
0018186C  push        eax  					   //将eax的内容压栈
0018186D  mov         ecx,dword ptr [ebp-8]  //传递a，将ebp-8内存空间的内容存入ecx
00181870  push        ecx  					 //将ecx的内容压栈
00181871  call        001810B9  			//函数调用
00181876  add         esp,8  
00181879  mov         dword ptr [ebp-20h],eax  
```

<img src="https://cdn.jsdelivr.net/gh/SYLV14/PicGo_Save/typora_images/202406112239389.png" alt="image-20240602155919127" style="zoom:50%;" />

在执行call指令之前先会把call指令的下一条指令的地址进行压栈操作，然后跳转至Add函数执行。

```c++
int Add(int x, int y) {
00181780  push        ebp  		//将main函数栈帧的基底地址压栈
00181781  mov         ebp,esp  	//将esp的值拷贝给ebp，此时的ebp为Add函数栈帧的基底地址
00181783  sub         esp,0CCh  //将esp的值减0CCH，此时运算后的esp为Add函数栈帧的基顶地址
00181789  push        ebx  		//将ebx的值压栈
0018178A  push        esi  		//将esi的值压栈
0018178B  push        edi  		//将edi的值压栈
	int z = 0;
0018178C  mov         dword ptr [ebp-8],0  //将0存入ebp-8的内存空间
	z = x + y;
00181793  mov         eax,dword ptr [ebp+8]  //将ebp+8地址处的形参x存储到eax中
00181796  add         eax,dword ptr [ebp+0Ch]  //将ebp+0CH地址处的形参y加到到eax中
00181799  mov         dword ptr [ebp-8],eax   //将eax的结果保存到ebp-8的地址处，其实就是放到z中
	return z;
0018179C  mov         eax,dword ptr [ebp-8]  //将ebp-8地址处的值放在eax中
}
0018179F  pop         edi  
001817A0  pop         esi  
001817A1  pop         ebx  
001817A2  mov         esp,ebp  
001817A4  pop         ebp  
001817A5  ret 
```

<img src="https://cdn.jsdelivr.net/gh/SYLV14/PicGo_Save/typora_images/202406112239390.png" alt="image-20240602162033919" style="zoom:50%;" />

- **函数栈帧的销毁**

```c++
0018179F  pop         edi  		//出栈，栈顶值存入edi
001817A0  pop         esi   	//出栈，栈顶值存入esi
001817A1  pop         ebx   	//出栈，栈顶值存入ebx
001817A2  mov         esp,ebp  	//将ebp的值拷贝给esp，相当于回收了Add栈帧
001817A4  pop         ebp  		//出栈，栈顶值存入ebp，此时的ebp为main函数栈帧基底地址，esp为main函数栈帧基顶地址
001817A5  ret  //通过执行ret指令，从栈顶找到call指令下一条指令的地址，然后返回到上一层函数栈帧，跳转到call指令下一条指令的地址处继续执行。
```

调用完Add函数后，回到main函数继续执行

```c++
00181876  add         esp,8  	//esp直接+8，相当于回收了形参x和y的内存空间
00181879  mov         dword ptr [ebp-20h],eax  //将eax中值，存入ebp-20H的内存空间处，此时eax中就是Add函数中计算的x和y的和
```

> **【问题】**
>
> 1. 局部变量是怎么创建的？
>    在函数开辟的栈帧空间中，初始化一块从ebp至低地址的空间，然后将定义的局部变量存入这块空间。越靠前定义的局部变量越靠近栈底存放。
> 2. 局部变量未初始化为什么是随机的？
>    VS2022编译器会自动将存放局部变量的内存空间初始化为0xcccccccc，若某局部变量未初始化，那存放该局部变量的内存空间内容就为0xcccccccc。
> 3. 函数是怎么传参的？传参的顺序是怎么样的？
>    在调用函数前，将实参按照函数参数列表中形参顺序从右至左依次压栈，压入栈顶的就是形参，然后调用函数。
> 4. 形参和实参是什么关系？
>    形参是压栈时开辟的空间，形参与实参在值上是相同的，但是空间上是独立的。
> 5. 函数的调用是怎么做的？
>    通过执行call指令来调用函数，在执行call指令之前先会把call指令的下一条指令的地址进行压栈操作，然后跳转至被调用函数。
> 6. 函数调用结束后是怎么返回的？
>    通过执行ret指令，从栈顶找到call指令下一条指令的地址，然后返回到上一层函数栈帧，跳转到call指令下一条指令的地址处继续执行。

# 数组

## 一维数组的创建和初始化

```c
int main()
{
	int arr1[10] = { 1,2,3,4,5,6,7,8,9,10 };//完全初始化
	int arr2[10] = { 1,2,3 };//不完全初始化，剩余元素默认初始化为0
	int arr3[] = { 1,2,3,4,5,6,7,8,9,10 };//数组大小有元素个数确定
	char str1[3] = { 'a','b','c' };//存放内容为'a','b','c'
	char str2[] = { 'a','b','c' };//存放内容为'a','b','c'
	char str3[5]= { 'a','b','c' };//存放内容为'a','b','c','\0','\0'
	char str4[5] = "abc";//存放内容为'a','b','c','\0','\0'
	char str5[] = "abc";//存放内容为'a','b','c','\0'
	char str6[3] = "abc";//存放内容为'a','b','c'
	char str7[5] = { 'a',98,'c' };//存放内容为'a','b','c','\0','\0'
	int n=10;
	int arr4[n]; //变长数组不可以不完全初始化
	return 0;
}
```

## 一维数组在内存中的存储

数组在内存中是连续存放的，随着下标的增长，地址是由低到高分布的

```c
#include <stdio.h>
int main()
{
	int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
	int i = 0;
	int sz = sizeof(arr) / sizeof(arr[0]);
	int* p = arr;
	for (i = 0; i < sz; i++)
		printf("arr[%d] = %d\n", i, *(p + i));
	for (i = 0; i < sz; ++i)
		printf("&arr[%d] = %p\n", i, &arr[i]);
	return 0;
}
```

## 二维数组的创建和初始化

```c
int main()
{
	int arr1[3][4] = { 1,2,3,4,5,6,7,8,9,10,11,12 };
	int arr2[3][4] = { 1,2,3,4,5,6 };
	int arr3[3][4] = { {1,2},{3,4,5},{6} };
	//可以省略行下标，不能省略列下标
	int arr4[][4] = { 1,2,3,4,5,6,7,8,9 };
	return 0;
}
```

## 二维数组在内存中的存储

```c
#include<stdio.h>
int main()
{
    int arr[3][4] = { 1,2,3,4,5,6,7,8,9,10,11,12 };
    int i = 0;
    int* p = &arr[0][0];
    for (i = 0; i < sizeof(arr)/sizeof(arr[0][0]); i++)
        printf("%d ", *(p + i));
    printf("\n");
    for (i = 0; i < 3; i++)
    {
        int j = 0;
        for (j = 0; j < 4; j++)
            printf("&arr[%d][%d] = %p ", i, j, &arr[i][j]);
        printf("\n");
    }
    return 0;
}
```

## 数组作为函数参数

```c
//冒泡排序
#include<stdio.h>
void bubble_sort(int arr[],int sz)//void bubble_sort(int* arr,int sz)
{
	int i, j;
	for (i = 0; i < sz - 1; i++)
	{
		for (j = 0; j < sz - 1 - i; j++)
			if (arr[j] > arr[j + 1])
			{
				int temp = arr[j];
				arr[j] = arr[j + 1];
				arr[j + 1] = temp;
			}
	}
}
int main()
{
	int arr[] = { 3,1,7,5,8,9,0,2,4,6 };
	int sz = sizeof(arr) / sizeof(arr[0]);
	bubble_sort(arr, sz);
	int i = 0;
	for (i = 0; i < sz; i++)
		printf("%d ", arr[i]);
	return 0;
}
```

**数组名是什么？**

```c
//数组名是数组首元素的地址。
//有两个例外:
//1、sizeof(数组名)，计算整个数组的大小，sizeof内部单独放一个数组名，数组名表示整个数组。
//2、&数组名，取出的是数组的地址。&数组名，数组名表示整个数组。
#include<stdio.h>
int main()
{
    int arr[] = { 1,2,3,4,5,6,7 };
    int sz = sizeof(arr) / sizeof(arr[0]);  //arr代表整个数组
    printf("%p\n", arr);                //首元素地址
    printf("%p\n", arr + 1);
    printf("%p\n", &arr[0]);            //首元素地址
    printf("%p\n", &arr[0] + 1);
    printf("%p\n", &arr);               //整个数组的地址
    printf("%p\n", &arr + 1);
    return 0;
}
//0000001744F9FBA8
//0000001744F9FBAC
//0000001744F9FBA8
//0000001744F9FBAC
//0000001744F9FBA8
//0000001744F9FBC4
```

## 应用实例

三子棋、扫雷

# 操作符

## 算术操作符

1. 除了 % 取模操作符之外，其他的几个操作符可以作用于整数和浮点数。
2. 对于 / 除法操作符如果两个操作数都为整数，执行整数除法。而只要有浮点数执行的就是浮点数除法。
3. % 取模操作符的两个操作数必须为整数。返回的是整除之后的余数。

```c
#include<stdio.h>
int main()
{
	int ret1 = 10 / 3;
	double ret2 = 10.0 / 3;
	int ret3 = 10 % 3;
	printf("%d\n", ret1);
	printf("%lf\n", ret2);
	printf("%d\n", ret3);
	return 0;
}   
```

## 移位操作符

**左移**操作符移位规则：左边抛弃，右边补0

**右移**操作符移位规则：

1. 逻辑移位，左边用0填充，右边丢弃
2. **算术移位（常用）**，左边用原该值的符号位填充，右边丢弃

```c
#include<stdio.h>
int main()
{
	int num1 = 10;//00000000 00000000 00000000 00001010
	int num2 = -10;//11111111 11111111 11111111 11110110
	//左移规则：左边抛弃，右边补0
	int ret1 = num1 << 1;
	//00000000 00000000 00000000 00010100
	int ret2 = num2 << 1;
	//11111111 11111111 11111111 11101100
	//10000000 00000000 00000000 00010100
	printf("%d\n", ret1);//20
	printf("%d\n", ret2);//-20
	//右移规则：
	//算数右移：左边用原该值的符号位填充，右边丢弃
	int ret3 = num1 >> 1;
	//00000000 00000000 00000000 00000101
	int ret4 = num2 >> 1;
	//11111111 11111111 11111111 11111011
	//10000000 00000000 00000000 00000101
	printf("%d\n", ret3);//5
	printf("%d\n", ret4);//-5
	return 0;
}
```

左移右移操作可以等价实现乘2除2操作，除了以下几个数

```c
#include<stdio.h>
#include <limits.h>
int main() {
	int n1 = 0;//00000000 00000000 00000000 00000000
	int n2 = INT_MAX;//2^31-1 //01111111 11111111 11111111 11111111
	int n3 = -1;//11111111 11111111 11111111 11111111
	int n4 = INT_MIN;//-2^31 //10000000 00000000 00000000 00000000
	printf("%d\n", (n1 << 1));//0
	printf("%d\n", (n2 << 1));//-2
	printf("%d\n", (n3 << 1));//-2
	printf("%d\n", (n4 << 1));//0
	printf("%d\n", (n1 >> 1));//0
	printf("%d\n", (n2 >> 1));//1073741823 //2^30-1
	printf("%d\n", (n3 >> 1));//-1
	printf("%d\n", (n4 >> 1));//-1073741824 //-2^30
	return 0;
}
```

对于移位运算符，不要移动负数位，这个是标准未定义的。

```c
int num = 10;
num >> -1;//error
```

## 位操作符

按位与`&`：只有当两个对应位都为1时，结果才为1，否则结果为0，【有0则0】

按位或`|`：只要两个对应位中有一个为1，结果就为1，否则结果为0，【有1则1】

按位异或`^`：如果两个对应位值不同，则结果为1，否则结果为0，【同0异1】

```c
#include<stdio.h>
int main()
{
	int a = 3; //00000000 00000000 00000000 00000011
	int b = -5;//11111111 11111111 11111111 11111011
	int c = a & b;
	//00000000 00000000 00000000 00000011
	int d = a | b;
	//11111111 11111111 11111111 11111011
	//10000000 00000000 00000000 00000101
	int e = a ^ b;
	//11111111 11111111 11111111 11111000
	//10000000 00000000 00000000 00001000
	printf("%d\n", c);//3
	printf("%d\n", d);//-5
	printf("%d\n", e);//-8
	return 0;
}
```

- 异或操作符：**a^a=0**，**0^a=a，异或支持交换律和结合律**

```c
//不能创建临时变量，实现两个数的交换。
#include<stdio.h>
int main()
{
	int a = 3, b = 5;
	a = a + b;
	b = a - b;
	a = a - b;
	printf("%d %d", a, b);
	return 0;
}

#include<stdio.h>
int main()
{
	int a = 3, b = 5;
	a = a ^ b;
	b = a ^ b;//a ^ b ^ b = a
	a = a ^ b;//a ^ b ^ a = b
	printf("%d %d", a, b);
	return 0;
}
```

```c
//统计二进制中1的个数
/*
方法一：
思路：
循环进行以下操作，直到n被缩减为0：
   1. 用该数据模2，检测其是否能够被2整除
   2. 可以：则该数据对应二进制比特位的最低位一定是0，否则是1，如果是1给计数加1
   3. 如果n不等于0时，继续1
*/
int NumberOf1(int n)
{
	int count = 0;
	while(n)
	{
		if(n%2==1)
			count++;
		n = n/2;
	}
	return count;
}
/*
上述方法缺陷：进行了大量的取模以及除法运算，取模和除法运算的效率本来就比较低。
方法二思路：
一个int类型的数据，对应的二进制一共有32个比特位，可以采用位运算的方式一位一位的检测，具体如下
*/
int NumberOf1(unsigned int n)
{
	int count = 0;
	int i = 0;
	for(i=0; i<32; i++)
	{
		if(((n>>i)&1) == 1)
			count++;
	}
	return count;
}
/*
方法二优点：用位操作代替取模和除法运算，效率稍微比较高
  缺陷：不论是什么数据，循环都要执行32次
方法三：
思路：采用相邻的两个数据进行按位与运算
举例：
9999：‭10 0111 0000 1111‬
第一次循环：n=9999   n=n&(n-1)=9999&9998= 9998
第二次循环：n=9998   n=n&(n-1)=9998&9997= 9996
第三次循环：n=9996   n=n&(n-1)=9996&9995= 9992
第四次循环：n=9992   n=n&(n-1)=9992&9991= 9984
第五次循环：n=9984   n=n&(n-1)=9984&9983= 9728
第六次循环：n=9728   n=n&(n-1)=9728&9727= 9216
第七次循环：n=9216   n=n&(n-1)=9216&9215= 8192
第八次循环：n=8192   n=n&(n-1)=8192&8191= 0
可以观察下：此种方式，数据的二进制比特位中有几个1，循环就循环几次，而且中间采用了位运算，处理起来比较高效
*/
int NumberOf1(int n)
{
	int count = 0;
	while(n)
	{
		n = n&(n-1);
		count++;
	}
	return count;
}
```

```c
//打印整数二进制的奇数位和偶数位
#include<stdio.h>
int main() {
	int n;
	scanf("%d", &n);
	int i, m = n;
	printf("偶数位：");
	for (i = 31; i >= 0; i -= 2)
		printf("%d ", (m >> i) & 1);
	printf("\n奇数位：");
	for (i = 30; i >= 0; i -= 2)
		printf("%d ", (m >> i) & 1);
	return 0;
}
```

```c
//求两个数二进制中不同位的个数
#include<stdio.h>
int main() {
	int m = 1999, n = 2299;
	int tmp = m ^ n;
	int count = 0;
	for (int i = 0; i < 32; i++)
		if ((tmp >> i) & 1 == 1)
			count++;
	printf("%d\n", count);
	return 0;
}
```

```c
//找单身狗2
#include<stdio.h>
void find_singledog(int arr[], int sz, int singledog[]) {
	int i = 0;
	int ret = 0;
    //先找到两个数互相异或的结果
	for (i = 0; i < sz; i++)
		ret ^= arr[i];
	int pos = 0;
    //再找到有分歧的一位。在这一位上，两个数一定是一个1一个0
	for(i=0;i<32;i++){
		if (((ret >> i) & 1) == 1) {
			pos = i;
			break;
		}
	}
	for (i = 0; i < sz; i++) {
		if (((arr[i] >> pos) & 1) == 1)
			singledog[0] ^= arr[i];//这一位是1的，有1、3、5，经过异或后只剩下6
		else
			singledog[1] ^= arr[i];//这一位是0的，有2、4、6，经过异或后只剩下5
	}
}
int main() {
	int arr[] = { 1,2,3,4,5,1,2,3,4,6 };
	int sz = sizeof(arr) / sizeof(arr[0]);
	int singledog[2] = { 0 };
	find_singledog(arr, sz, singledog);
	printf("%d %d\n", singledog[0], singledog[1]);
	return 0;
}
```

## 赋值操作符

```c
+=、-=、*=、/=、%=、>>=、<<=、&=、|=、^=
```

## 单目操作符

```c
!           逻辑反操作
-           负值
+           正值
&           取地址
sizeof      操作数的类型长度（以字节为单位）
~           对一个数的二进制按位取反
--          前置、后置--
++          前置、后置++
*           间接访问操作符(解引用操作符)
(类型)       强制类型转换
```

```c
#include<stdio.h>
int main()
{
	int a = 10;
	printf("%d\n", sizeof(a));
	printf("%d\n", sizeof a);
	printf("%d\n", sizeof(int));
	//printf("%d\n", sizeof int);		//error
	int arr[10] = { 0 };
	printf("%d\n", sizeof(arr));
	printf("%d\n", sizeof(int[10]));
	short s = 5;
	printf("%d\n", sizeof(s = a + 3));	//sizeof内部的表达式不计算
	printf("%d\n", s);
	return 0;
}
```

```c
#include<stdio.h>
int main()
{
	int a = 9;	  //00000000 00000000 00000000 00001001
	a |= (1 << 4);//00000000 00000000 00000000 00010000
	//00000000 00000000 00000000 00011001
	printf("%d\n", a);//25
	a &= (~(1 << 4));//11111111 11111111 11111111 11101111
	//00000000 00000000 00000000 00001001
	printf("%d\n", a);//9
	return 0;
}
```

## 关系操作符

```c
>、>=、<、<=
!=      用于测试“不相等”
==      用于测试“相等
```

## 逻辑操作符

**逻辑与`&&`，左边为假右边不执行**

**逻辑或`||`，左边为真右边不执行**

```c
#include <stdio.h>
int main()
{
	int a = 0, b = 2, c = 3;
	int i = a++ && ++b && c++;//0 && 不执行 && 不执行
	printf("%d %d %d\n", a, b, c);//1 2 3
	int d = 0, e = 2, f = 3;
	int j = d++ || ++e || f++;// 0 || 3 || 不执行
	printf("%d %d %d\n", d, e, f);//1 3 3
	return 0;
}
```

## 条件操作符

```c
exp1 ? exp2 : exp3
```

```c
//三个数中的最大值
#include<stdio.h>
int main()
{
	int a = 0, b = 10, c = -5;
	int ret = a > (b > c ? b : c) ? a : (b > c ? b : c);
	printf("%d\n", ret);
	return 0;
}
```

## 逗号表达式

```c
exp1, exp2, exp3, …expN
```

逗号表达式，就是用逗号隔开的多个表达式。 逗号表达式，**从左向右依次执行**。整个表达式的结果是**最后一个表达式的结果**。

```c
//代码1
int a = 1;
int b = 2;
int c = (a > b, a = b + 10, a, b = a + 1);//逗号表达式，c是13
//代码2
if (a = b + 1, c = a / 2, d > 0)
//代码3
a = get_val();
count_val(a);
while (a > 0)
{
    //业务处理
    a = get_val();
    count_val(a);
}
如果使用逗号表达式，改写：
while (a = get_val(), count_val(a), a>0)
{
    //业务处理
}
```

## 下标引用、函数调用和结构成员

## 表达式求值

### 隐式类型转换

整型提升：为了获得这个精度，表达式中的字符和短整型操作数在使用之前被转换为普通整型

> 通用CPU（general-purpose CPU）是难以直接实现两个8比特字节直接相加运算（虽然机器指令中可能有这种字节相加指令）。所以，表达式中各种长度可能小于int长度的整型值，都必须先转换为int或unsigned int，然后才能送入CPU去执行运算。
> 
- **有符号数整型提升时，高位补充符号位**
- **无符号数整型提升时，高位补0**

```c
//负数的整形提升
char c1 = -1;
变量c1的二进制位(补码)中只有8个比特位：
1111111
因为 char 为有符号的 char
所以整形提升的时候，高位补充符号位，即为1
提升之后的结果是：
11111111 11111111 11111111 11111111
//正数的整形提升
char c2 = 1;
变量c2的二进制位(补码)中只有8个比特位：
00000001
因为 char 为有符号的 char
所以整形提升的时候，高位补充符号位，即为0
提升之后的结果是：
00000000 00000000 00000000 00000001
//无符号整形提升，高位补0
unsigned char c1 = 255;
变量c1的二进制位(补码)中只有8个比特位：
1111111
因为unsigned char 无符号
所以整形提升的时候，高位补充0
提升之后的结果是：
00000000 00000000 00000000 11111111
```

```c
int main()
{
    char a = 3, b = 127;
    //00000000000000000000000000000011
    //00000000000000000000000001111111
    char c = a + b;
    //00000000000000000000000010000010
    //截断存于c中 10000010
    printf("%d\n", c);
    //11111111111111111111111110000010  //补码
    //11111111111111111111111110000001  //反码
    //10000000000000000000000001111110  //原码
    //-126
    return 0;
}

int main()
{
    char a = 0xb6;
    //10110110
    short b = 0xb600;
    //1011011000000000
    int c = 0xb6000000;
    //10110110000000000000000000000000
    if (a == 0xb6)          //11111111111111111111111110110110
        printf("a");
    if (b == 0xb600)            //11111111111111111011011000000000
        printf("b");
    if (c == 0xb6000000)        //10110110000000000000000000000000
        printf("c");    
    return 0;
}

int main()
{
    char c = 1;
    printf("%u\n", sizeof(c));      //1
    printf("%u\n", sizeof(+c));     //4 //整型提升
    printf("%u\n", sizeof(-c));     //4 //整型提升
    printf("%u\n", sizeof(!c));     //1
    return 0;
}
```

### 算术转换

```c
long double
double
float
unsigned long int
long int
unsigned int
int
```

如果某个操作数的类型在上面这个列表中排名较低，那么由低位转到高位不会丢失精度，正常转换，由高位转到低位则可能会丢失精度，转换由风险。


### 操作符的属性

操作符表格



```c
//表达式 1
int a, b, c, d, e, f;
a* b + c * d + e * f;
//注释：代码1在计算的时候，由于* 比 + 的优先级高，只能保证， * 的计算是比 + 早，但是优先级并不能决定第三个* 比第一个 + 早执行。
a* b;
c* d;
a* b + c * d;
e* f;
a* b + c * d + e * f;
//或者：
a* b;
c* d;
e* f;
a* b + c; *d;
a* b + c * d + e * f;

//表达式 2
c + --c;
//注释：同上，操作符的优先级只能决定自减--的运算在+的运算的前面，但是我们并没有办法得知，+操作符的左操作数的获取在右操作数之前还是之后求值，所以结果是不可预测的，是有歧义的。

//表达式 3
int main()
{
    int i = 10;
    i = i-- - --i * (i = -3) * i++ + ++i;
    printf("i = %d\n", i);
    return 0;
}
//表达式3在不同编译器中测试结果不同

//表达式 4
int fun()
{
    static int count = 1;
    return ++count;
}
int main()
{
    int answer;
    answer = fun() - fun() * fun();
    printf("%d\n", answer); 
    return 0;
}
/*虽然在大多数的编译器上求得结果都是相同的。
但是上述代码 answer = fun() - fun() * fun(); 中我们只能通过操作符的优先级得知：先算乘法，再算减法。
函数的调用先后顺序无法通过操作符的优先级确定。*/

//表达式 5
int main()
{
    int i = 1;
    int ret = (++i) + (++i) + (++i);
    printf("%d\n", ret);
    printf("%d\n", i);
    return 0;
}
//这段代码中的第一个 + 在执行的时候，第三个++是否执行，这个是不确定的，因为依靠操作符的优先级和结合性是无法决定第一个 + 和第三个前置 ++ 的先后顺序。
```

# 指针

## 指针是什么

指针是个变量，存放内存单元的地址（编号）。

```c
#include <stdio.h>
int main()
{
 int a = 10;//在内存中开辟一块空间
 int *p = &a;//这里我们对变量a，取出它的地址，可以使用&操作符。
 //将a的地址存放在p变量中，p就是一个指针变量。
 return 0;
}
```

- 指针变量是用来存放地址的，地址是唯一标示一块地址空间的。
- **指针的大小在32位平台是4个字节，在64位平台是8个字节。**

## 指针和指针类型

- **指针类型决定指针进行解引用操作时能够访问空间的大小**

```c
int* p;	        *p能够访问4个字节
char* p;	    *p能够访问1个字节
double* p;	    *p能够访问8个字节
```

```c
int a = 0x11223344;
//0x000000389D0FF854  44 33 22 11 ....
int* pa = &a;
*pa = 0;
//0x000000389D0FF854  00 00 00 00 ....

int a = 0x11223344;
//0x000000389D0FF854  44 33 22 11 ....
char* pa = &a;
*pa = 0;
//0x000000389D0FF854  00 33 22 11 ....
```

- **指针的类型决定了指针的步长**

```c
int a = 0x11223344;
int* pa = &a;
char* pc = &a;
printf("%p\n", pa); 		//000000FE018FFAF4
printf("%p\n", pa+1);		//000000FE018FFAF8
printf("%p\n", pc);			//000000FE018FFAF4
printf("%p\n", pc+1);		//000000FE018FFAF5
return 0;
```

## 野指针

- **野指针成因**

​	1. 指针未初始化

```c
int* p;		//局部变量指针未初始化，默认为随机值
*p = 20;
```

​	2. 指针越界访问

```c
int arr[10] = { 0 };
int* p = arr;
int i = 0;
for (i = 0; i <= 11; i++)
{
    //当指针指向的范围超出数组arr的范围时，p就是野指针
    *(p++) = i;
}
```

​	3. 指针指向的空间释放

```c
int* test()
{
    int a = 1;
    return &a;
}
int main()
{
    int* p = test();
    *p = 20;		
    return 0;
}
```

- **规避野指针**
  1. 指针初始化
  2. 小心指针越界
  3. 指针指向空间释放即使置NULL
  4. 避免返回局部变量的地址
  5. 指针使用之前检查有效性

## 指针运算

- **指针 +- 整数**

```c
#define N_VALUES 5
int main()
{
	float values[N_VALUES];
	float* vp;
	//指针+-整数；指针的关系运算
	for (vp = &values[0]; vp < &values[N_VALUES];)
	{
		printf("%p\n", vp);
		*vp++ = 0;			//**先*vp = 0 ，后 vp++**
		printf("%d\n", *(vp-1));
	}
	return 0;
}
```

- **指针 - 指针**：得到的是两个指针之间的元素个数

```c
int main()
{
	int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
	for (int i = 0; i < 10; i++)
	{
		printf("%p\n", &arr[i]);
		printf("%d\n", &arr[i] - &arr[0]);		//相减得到指针间元素个数
	}
	return 0;
}
```

```c
//求字符串长度
int my_strlen(char* str)			
{
	char* start = str;
	char* end = str;
	while (*end++ != '\0');
	return end - start - 1;		//末地址间首地址
}
int main()
{
	char arr[] = "bit";
	int len = my_strlen(arr);
	printf("%d\n", len);		//3
	return 0;
}
```

- **指针的关系运算**
  **标准规定：**允许指向数组元素的指针与**指向数组最后一个元素后面的那个内存位置**的指针比较，但是**不允许与指向第一个元素之前的那个内存位置**的指针进行比较。

```c
#define N_VALUES 5
int main()
{
	float values[N_VALUES];
	float* vp;
	//正确，vp最后指向&values[0]
	for (vp = &values[N_VALUES]; vp > &values[0];)
	{
		*--vp = 0;
	}
	//错误,vp最后指向&values[-1]
	for (vp = &values[N_VALUES]; vp >= &values[0];vp--)
	{
		*vp = 0;
	}
	return 0;
}

```

## 指针和数组

```c
#include<stdio.h>
int main()
{
	int arr[10] = { 0 };
	int* p = arr;
	int sz = sizeof(arr) / sizeof(arr[0]);
	int i = 0;
	for (i = 0; i < sz; i++)
		*(p + i) = i + 1;
	for (i = 0; i < sz; i++)
	{
        //多种访问数组元素的方式
		printf("%d ", *(p + i));
		printf("%d ", p[i]);
		printf("%d ", arr[i]);
		printf("%d ", i[arr]);
		printf("%d ", *(arr + i));
		printf("%d ", *(i + arr));
	}
	return 0;
}
```

## 二级指针

```c
#include<stdio.h>
int main()
{
	int a = 10;
	int* pa = &a;
	int** ppa = &pa;		//前 * 代表ppa指向的对象的类型是指针，后 * 代表ppa是指针
	printf("a = %d\t\t&a = %p\n", a, &a);
	printf("*pa = %d\tpa = %p\t\t&pa = %p\n", *pa, pa, &pa);
	printf("**ppa = %d\t*ppa = %p\t\tppa = %p\n", **ppa, *ppa, ppa);
	return 0;
}

//**ppa = *pa = a = 10
//*ppa = pa = &a = 0000007B2352F9A4
//ppa = &pa = 0000007B2352F9C8
```

## 指针数组

指针数组是数组，是存放指针的数组。

```c
#include<stdio.h>
int main()
{
	int a = 10, b = 20, c = 30;
	int* arr[3] = { &a,&b,&c };
	for (int i = 0; i < 3; i++)
	{
		printf("%d\t", *(arr[i]));	//10	20		30
	}
	return 0;
}

//一维数组模拟二维数组
#include<stdio.h>
int main()
{
	int a[] = { 1,2,3,4 };
	int b[] = { 2,3,4,5 };
	int c[] = { 3,4,5,6 };
	int* arr[3] = { a,b,c };
	int i, j;
	for (i = 0; i < 3; i++)
		for (j = 0; j < 4; j++)
			printf("%d ", arr[i][j]);
	return 0;
}
```

# 实用调试技巧

## 调试

调试（debug）是发现和减少计算机程序或电子仪器设备中程序错误的一个过程。

Debug – 调试版本 – 它包含调试信息，并且不作任何优化，便于程序员调试程序。
Release – 发布版本 – 它往往是进行了各种优化，使得程序在代码大小和运行速度上都是最优的，以便用户很好地使用。

## windows环境调试

- 调试环境的准备

![image-20240520185141923](https://cdn.jsdelivr.net/gh/SYLV14/PicGo_Save/typora_images/202406112239391.png)

Debug环境才能调试代码

- VS快捷键

  F5：启动调试，经常用来直接调到下一个断点处。 

  F9：创建断点和取消断点 断点的重要作用，可以在程序的任意位置设置断点。这样就可以使得程序在 想要的位置随意停止执行，继而一步步执行下去。 

  F10：逐过程，通常用来处理一个过程，一个过程可以是一次函数调用，或者是一条语句。 

  F11：逐语句，就是每次都执行一条语句，但是这个快捷键可以使我们的执行逻辑进入函数内部（这是 最长用的）。 

  CTRL + F5：开始执行不调试，如果你想让程序直接运行起来而不调试就可以直接使用。

- 调试的时候查看程序当前信息

  1. **查看临时变量**

     ![image-20240520190902727](https://cdn.jsdelivr.net/gh/SYLV14/PicGo_Save/typora_images/202406112239392.png)

  2. **查看内存信息**

     ![image-20240520191202267](https://cdn.jsdelivr.net/gh/SYLV14/PicGo_Save/typora_images/202406112239393.png)

  3. **查看调用堆栈**

     ![image-20240520191429380](https://cdn.jsdelivr.net/gh/SYLV14/PicGo_Save/typora_images/202406112239394.png)

  4. **查看汇编**

     方法1：

     <img src="https://cdn.jsdelivr.net/gh/SYLV14/PicGo_Save/typora_images/202406112239395.png" alt="image-20240520191539972" style="zoom: 50%;" />

     方法2：

     ![image-20240520191630557](https://cdn.jsdelivr.net/gh/SYLV14/PicGo_Save/typora_images/202406112239396.png)

  5. **查看寄存器**
     ![image-20240520191724339](https://cdn.jsdelivr.net/gh/SYLV14/PicGo_Save/typora_images/202406112239397.png)

## 调试实例

```c
int main()
{
	int i = 0;									//i 先创建先使用高地址
	int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };		//arr 后创建使用低地址
	for (i = 0; i <= 12; i++)					//i 与 arr[12] 同地址 (VS编译器特性)
	{
		printf("hehe\n");
		arr[i] = 0;
	}
	return 0;
}
```

![image-20240520192113656](https://cdn.jsdelivr.net/gh/SYLV14/PicGo_Save/typora_images/202406112239398.png)

## 优秀代码的示例

```c
#include<stdio.h>
#include<assert.h>
char* my_strcpy(char* dest, const char* src)
{
	char* ret = dest;
	assert(dest && src);			//目标字符串和源字符串的函数都不能是指向空指针
	while (*dest++ = *src++);		//将源字符串拷贝到目标字符串，包含'\0'
	return ret;
}
int my_strlen(const char* str)
{
	assert(str);
	char* start = str;
	char* end = str;
	while (*end++);				//end 指向'\0'的地址
	end--;					//end 指向'\0前一位的地址
	return end - start;			//指针相减为两指针中间的数组元素
}
int main()
{
	char arr1[] = "########";		
	char arr2[] = "bittttt";		//目标数组长度要大于源数组，否则会缓冲溢出
	printf("%s\n", my_strcpy(arr1, arr2));
	printf("%d\n", my_strlen(arr2));
	return 0;
}
```

- **`assert`中的表达式结果为假就报错，结果为真就继续执行**

  ```c
  void assert ( 表达式 );
  ```

- **`const`修饰指针的作用**

```c
int main()				//const修饰指针的作用
{
	int n1 = 10;
	int n2 = 20;
	const int* p = &n1;	
	*p = 20;		//err
	p = &n2;		//ok
	//可以修改地址，不能修改值
	int m1 = 100;
	int m2 = 200;
	int* const q = &m1;
	*q = 200;		//ok
	q = &m2;		//err
	//可以修改值，不能修改地址
	return 0;
}
```

1. `const`如果放在`*`的左边，修饰的是指针指向的内容，保证指针指向的内容不能通过指针来改变，但是指针变量本身的内容可变。
2. `const`如果放在`*`的右边，修饰的是指针变量本身，保证了指针变量的内容不能修改，但是指针指向的内容，可以通过指针改变。

# 数据的存储

## 数据类型

```c
整型
char        //字符数据类型
	unsigned char\signed char
short       //短整型
	unsigned short [int]\signed short [int]
int         //整形
	unsigned int\signed int
long        //长整型
	unsigned long [int]\signed long [int]
long long   //更长的整形
	unsigned long long [int]\signed long long [int]
浮点数
float       //单精度浮点数
double      //双精度浮点数
构造类型
> 数组类型
> 结构体类型 struct
> 枚举类型 enum
> 联合类型 union
指针类型
空类型 void
```

## 整型在内存中的存储

### 原码反码补码

1. 无符号数的原、反、补码相同

2. 有符号数的正整数的原、反、补码相同

3. 有符号数的负整数的原、反、补码根据以下规则：
   原码：直接将二进制按照正负数的形式翻译成二进制就可以
   反码：将原码的符号位不变，其他位依次按位取反就可以得到了
   补码：反码+1就得到补码

### 大端小端

大端（存储）模式，是指数据的低位保存在内存的高地址中，而数据的高位保存在内存的低地址中

小端（存储）模式，是指数据的低位保存在内存的低地址中，而数据的高位,保存在内存的高地址中。常用小端模式

```c
#include<stdio.h>
int main() {
	int i = 1;
	char* p = (char*)&i;
	if (*p == 1)
		printf("小端\n");
	else
		printf("大端\n");
	return 0;
}
```

### 练习

```c
int main()
{
    char a = -1;            
    //10000000 00000000 00000000 00000001
    //11111111 11111111 11111111 11111110
    //11111111 11111111 11111111 11111111
    //11111111
    //整型提升
    //11111111 11111111 11111111 11111111
    signed char b = -1;     //同上
    unsigned char c = -1;   //11111111
    //整型提升
    //00000000 00000000 00000000 11111111
    printf("a = %d\nb = %d\nc = %d", a, b, c);
    //-1 -1 255
    return 0;
}

int main()
{
    char a = -128;
    //10000000 00000000 00000000 10000000
    //11111111 11111111 11111111 01111111
    //11111111 11111111 11111111 10000000
    //10000000
    //有符号数整型提升
    //11111111 11111111 11111111 10000000
    printf("%u\n", a);
    char b = 128;
    //00000000 00000000 00000000 10000000
    //01111111 11111111 11111111 01111111
    //01111111 11111111 11111111 10000000
    //10000000
    //有符号数整型提升
    //11111111 11111111 11111111 10000000
    printf("%u\n", b);
    //有符号的char类型数值范围时-128~127，当127+1时128等于-128，循环往复
    return 0;
}

int main()
{
    int i = -20;
    //10000000000000000000000000010100
    //11111111111111111111111111101011
    //11111111111111111111111111101100
    unsigned int j = 10;
    //00000000000000000000000000001010
    printf("%d\n", i + j);
    //11111111111111111111111111110110
    //11111111111111111111111111110101
    //10000000000000000000000000001010
    return 0;
}

int main()
{
		unsigned int i;
		for (i = 9; i >= 0; i--)//i为无符号整型，当i=0时再自减会变为2^32-1，从而死循环
		    printf("%u\n", i);
		return 0;
}

int main()
{
    char a[1000];
    int i;
    for (i = 0; i < 1000; i++)
    {
        a[i] = -1 - i;
    }
    printf("%d", strlen(a));//255
    return 0;
}

unsigned char i = 0;
int main()
{
    for (i = 0; i <= 255; i++)//i为无符号字符型，当i=255时再自增会变为0，从而死循环
        printf("hello world\n");
    return 0;
}
```

## 浮点数在内存中的存储

根据国际标准IEEE754，任意一个二进制浮点数V可以表示成下面的形式：

- (-1)^S * M * 2^E
- (-1)^S表示符号位，当S=0，V为正数；当S=1，V为负数。
- M表示有效数字，大于等于1，小于2。
- 2^E表示指数位。

如：十进制的5.0，写成二进制是 101.0 ，相当于 1.01×2^2 。 那么，按照上面V的格式，可以得出S=0，M=1.01，E=2。

对于32位的浮点数（单精度浮点数float），最高的1位是符号位S，接着的8位是指数E，剩下的23位为有效数字M。

对于64位的浮点数（双精度浮点数double），最高的1位是符号位S，接着的11位是指数E，剩下的52位为有效数字M。

```c
int main()
{
    int n = 9;
    float* pfloat = &n;
    printf("%d\n", n);
    //00000000 00000000 00000000 00001001
    printf("%f\n", *pfloat);
		//0 00000000 00000000000000000001001
		//S = 0
		//E全为0,为1-127=-126
		//M = 1. 00000000000000000001001 , 由于E全为0 , M省略第一位的1
    //(-1)^0*0.00000000000000000001001*2^(-126) - 无限接近于0的数字
    *pfloat = 9.0;
    //1001.0
		//(-1)^0*1.001*2^3
		//S = 0
		//E = 3 , 存入内存时3+127 = 1000 0010
		//M = 1.001 , , 存入内存时0010 0000 0000 0000 0000 000
		//0 10000010 00100000000000000000000
    printf("%d\n", n);
    //1091567616
    printf("%f\n", *pfloat);
    //9.000000
    return 0;
}
```

- **有效数字M的特别规定：**

M可以写成 1.xxxxxx 的形式，，**默认这个数的第一位总是1，因此可以被舍去，只保存后面的 xxxxxx部分。**

- **指数E的特别规定：**

**存入内存时E的真实值必须再加上一个中间数，对于8位的E，这个中间数是127；对于11位的E，这个中间数是1023。**比如，2^10的E是10，所以保存成32位浮点数时，必须保存成10+127=137，即10001001。

- **指数E从内存中取出还可以再分成三种情况：**
    - E不全为0或不全为1
    
    浮点数就采用下面的规则表示，即指数E的计算值减去127（或1023），得到真实值，再将有效数字M前加上第一位的1。
    
    - E全为0
    
    浮点数的指数E等于1-127（或者1-1023）即为真实值， 有效数字M不再加上第一位的1，而是还原为0.xxxxxx的小数。这样做是为了表示±0，以及接近于 0的很小的数字。
    
    - E全为1
    
    如果有效数字M全为0，表示±无穷大（正负取决于符号位s）；
    

## 作业

猜名次：

5位运动员参加了10米台跳水比赛，有人让他们预测比赛结果：

A选手说：B第二，我第三；

B选手说：我第二，E第四；

C选手说：我第一，D第二；

D选手说：C最后，我第三；

E选手说：我第四，A第一；

比赛结束后，每位选手都说对了一半，请编程确定比赛的名次。

```c
#include<stdio.h>
int main()
{
	int a = 0, b = 0, c = 0, d = 0, e = 0;
	for (a = 1; a <= 5; a++)
		for (b = 1; b <= 5; b++)
			for (c = 1; c <= 5; c++)
				for (d = 1; d <= 5; d++)
					for (e = 1; e <= 5; e++)
						if ((b == 2) + (a == 3) == 1 &&
							(b == 2) + (e == 4) == 1 &&
							(c == 1) + (d == 2) == 1 &&
							(c == 5) + (d == 3) == 1 &&
							(e == 4) + (a == 1) == 1 &&
							a * b * c * d * e == 120)
							printf("a=%d,b=%d,c=%d,d=%d,e=%d\n", a, b, c, d, e);
	return 0;
}
```

猜凶手：

日本某地发生了一件谋杀案，警察通过排查确定杀人凶手必为4个嫌疑犯的一个。

以下为4个嫌疑犯的供词:

A说：不是我。

B说：是C。

C说：是D。

D说：C在胡说

已知3个人说了真话，1个人说的是假话。

现在请根据这些信息，写一个程序来确定到底谁是凶手。

```c
#include<stdio.h>
int main() {
	char killer = 0;
	for (killer = 'a'; killer <= 'd'; killer++)
		if ((killer != 'a') + (killer == 'c') + (killer == 'd') + (killer != 'd') == 3)
			printf("%c\n", killer);
	return 0;
}
```

杨辉三角

```c
#include<stdio.h>
int main() {
	int arr[10][10] = { 0 };
	int i = 0, j = 0;
	int n = 0;
	scanf("%d", &n);
	for(i=0;i<n;i++)
		for (j = 0; j <= i; j++) {
			if (j == 0 || j == i)
				arr[i][j] = 1;
			else
				arr[i][j] = arr[i - 1][j - 1] + arr[i - 1][j];
		}
	for (i = 0; i < n; i++) {
		for (j = 0; j <= i; j++)
			printf("%d\t", arr[i][j]);
		printf("\n");
	}
	return 0;
}
```

# 指针的进阶

## 字符指针

```c
#include <stdio.h>
int main()
{
    char str1[] = "hello bit.";
    char str2[] = "hello bit.";
    const char* str3 = "hello bit.";
    const char* str4 = "hello bit.";
    if (str1 == str2)
        printf("str1 and str2 are same\n");
    else
        printf("str1 and str2 are not same\n");
	//str1 and str2 are not same
    if (str3 == str4)
        printf("str3 and str4 are same\n");
    else
        printf("str3 and str4 are not same\n");
	//str3 and str4 are same
    return 0;
}
```

 `char* pstr = "hello bit.";` 本质是把常量字符串 `hello bit.` 的首字符的地址放到了`pstr`中。

## 指针数组

```c
int* arr1[10]; //整形指针的数组
char *arr2[4]; //一级字符指针的数组
char **arr3[5];//二级字符指针的数组
```

## 数组指针

数组指针是能够指向数组的指针

```c
#include <stdio.h>
int main()
{
    int arr[10] = { 1,2,3,4,5,6,7,8,9,0 };
    int(*p)[10] = &arr;//把数组arr的地址赋值给数组指针变量p
    for (int i = 0; i < 10; i++)
        printf("%d ", (*p)[i]);
    return 0;
}
```

```c
#include <stdio.h>
void print_arr1(int arr[3][5], int row, int col)
{
    int i = 0;
    for (i = 0; i < row; i++)
    {
        int j = 0;
        for (j = 0; j < col; j++)
            printf("%d ", arr[i][j]);
        printf("\n");
    }
}
void print_arr2(int(*arr)[5], int row, int col)
{
    int i = 0;
    for (i = 0; i < row; i++)
    {
        int j = 0;
        for (j = 0; j < col; j++)
            printf("%d ", arr[i][j]);
        printf("\n");
    }
}
int main()
{
    int arr[3][5] = { 1,2,3,4,5,6,7,8,9,10 };
    print_arr1(arr, 3, 5);
    //数组名arr，表示首元素的地址
    //但是二维数组的首元素是二维数组的第一行
    //所以这里传递的arr，其实相当于第一行的地址，是一维数组的地址
    //可以数组指针来接收
    print_arr2(arr, 3, 5);
    return 0;
}
```

## 数组参数、指数参数

### 一维数组传参

```c
void test1(int arr[], int sz);
void test2(int* arr, int sz);
void test3(int* str[], int sz);
void test4(int** str, int sz);
int main() {
	int arr[] = { 1,2,3,4,5,6,7,8,9,0 };
	int sz1 = sizeof(arr) / sizeof(arr[0]);
	test1(arr, sz1);
	test2(arr, sz1);
	char* str[] = { "hello","hi","nihao" };
	int sz2 = sizeof(str) / sizeof(str[0]);
	test3(str, sz2);
	test4(str, sz2);
	return 0;
}
```

### 二维数组传参

```c
void test1(int arr[3][4], int row, int col);
void test1(int arr[][4], int row, int col);
void test1(int(*arr)[4], int row, int col);
int main() {
	int arr[3][4] = { {1,2,3,4},{2,3,4,5},{3,4,5,6} };
	int row = sizeof(arr) / sizeof(arr[0]);
	int col = sizeof(arr[0]) / sizeof(arr[0][0]);
	return 0;
}
```

### 一级指针传参

```c
void test(int* p);
int main() {
	int a = 10;
	int* p= &a;
	int arr[] = { 1,2,3,4,5,6,7,8,9,0 };
	test(&a);
	test(p);
	test(arr);
	return 0;
}
```

### 二级指针传参

```c
void test(int** ptr);
int main(){
	int n = 10;
	int* p = &n;
	int** pp = &p;
	test(pp);
	test(&p);
	return 0;
}
```

## 函数指针

```c
int Add(int x, int y)
{
	return x + y;
}
int main()
{
	printf("%p\n", Add);		//函数Add的地址
	printf("%p\n", &Add);		//函数Add的地址
	//&函数名 和 函数名 都是函数的地址
	//int(*p)(int, int) = &Add;
	int(*p)(int, int) = Add; 	//Add是函数地址，类似于数值指针的定义
	//p - 函数指针名 ， int(*)(int,int) - p的类型
	printf("%d\n", p(2, 3));//5
	printf("%d\n", (*p)(2, 3));//5
	printf("%d\n", (**p)(2, 3));//5
	printf("%d\n", (***p)(2, 3));//5	//*就是摆设
	//printf("%d\n", *p(2, 3));	//err
	return 0;
}

逆天的两个函数指针的解释：
(*(void (*)())0)();
void (*)() 				- 函数指针类型
(void (*)())0 			- 将0强制转换类型成函数的地址
*(void (*)())0)		 	- 解引用函数地址 - 调用0地址处的该函数
(*(void (*)())0)(); 		- 调用0地址的函数，无参，返回类型为void

void (*signal(int, void(*)(int)))(int);
signal(int, void(*)(int)) 			- signal是一个函数的声明，int 和  void(*)(int) 是函数参数类型
void (*			)(int);	  	-signal函数的返回类型也是函数指针，该函数指针指向的函数的参数是int，返回类型是void
简化该函数
typedef void(*pfun_t)(int);
pfun_t signal(int, pfun_t);
```

## 函数指针数组

```c
#include<stdio.h>
void menu() {
	printf("*********************\n");
	printf("*****1.Add 2.Sub*****\n");
	printf("*****3.Mul 4.Div*****\n");
	printf("*****0.Exit     *****\n");
	printf("*********************\n");
}
void Add(int x, int y) {
	return x + y;
}
void Sub(int x, int y) {
	return x - y;
}
void Mul(int x, int y) {
	return x * y;
}
void Div(int x, int y) {
	return x / y;
}
int (*p[5])(int, int) = { NULL,Add,Sub,Mul,Div };
int main() {
	int input = 0;
	int x, y;
	int ret = 0;
	do {
		menu();
		printf("请选择:>");
		scanf("%d", &input);
		if (input == 0) {
			printf("退出计算器\n");
			break;
		}
		else if (input >= 1 && input <= 4) {
			printf("请输入两个整数:>");
			scanf("%d %d", &x, &y);
			ret = p[input](x, y);
			printf("结果为:>%d\n", ret);
		}
		else {
			printf("请重新选择\n");
		}
	} while (input);
	return 0;
}
```

## 指向函数指针数组的指针

```c
int (*(*pp)[5])(int, int) = &p;
```

## 回调函数

回调函数就是一个通过函数指针调用的函数

```c
void menu(){
	printf("************************\n");
	printf("***1.Add        2.Sub***\n");
	printf("***3.Mul        4.Div***\n");
	printf("***      0.exit      ***\n");
	printf("************************\n");
}
int Add(int x, int y){
	return x + y;
}
int Sub(int x, int y){
	return x - y;
}
int Mul(int x, int y){
	return x * y;
}
int Div(int x, int y){
	return x / y;
}
void Calc(int(*p)(int, int)){
	int x = 0, y = 0;
	printf("请输入操作数>>");
	scanf("%d%d", &x, &y);
	printf("%d\n", p(x, y));
}
int main(){
	int input = 0;
	do{
		menu();
		printf("请选择>>");
		scanf("%d", &input);
		switch (input){
		case 1:
			Calc(Add);
			break;
		case 2:
			Calc(Sub);
			break;
		case 3:
			Calc(Mul);
			break;
		case 4:
			Calc(Div);
			break;
		case 0:
			printf("退出");
			break;
		default:
			printf("选择错误");
			break;
		}
	} while (input);
	return 0;
}
```

关于`void*`的解释：

`void*` 类型的指针不能进行解引用操作，可以接收任意类型的地址，不能进行+-整数的操作

```c
int main()
{
	int a = 10;
	char ch = 'w';
	void* p = &a;
	//*p = 20;		//void* 类型的指针不能进行解引用操作
	p = &ch;		//void* 类型的指针可以接收任意类型的地址
	//p++;			//void* 类型的指针不能进行+-整数的操作
	return 0;
}
```

- **`qsort`**函数

```c
void qsort(void* base, size_t num, size_t size, int(*compar)(const void* e1, const void* e2));
头文件： #include<stdlib.h>
base —— 就是要排序数组的首元素地址
num —— 数组元素的个数
size —— 就是数组中每一个元素的所占字节数，用sizeof(arr[0])来计算
int(*compar)(const void* e1, const void* e2))
	这个函数是自己定义的，* e1和* e2是你要排序数组的两个进行比较的元素，你必须保证你所定义的函数返回值遵守下列规则：
	如果* e1大于* e2，就返回大于0的数（函数的返回类型为整形）
	如果* e1小于* e2，就返回小于0的数
	如果* e1等于* e2，就返回等于0的数
	强制类型转换时，类型应该为实参的类型，比如你要比较int型数据，那么强制转换为int型，如果是结构体就强制转换为结构体
	升序：return *(type*)e1 - *(type*)e2;，降序：return *(type*)e2 - *(type*)e1;，字符串用strcmp
```

```c
#include<stdlib.h>
#include<string.h>
int cmp_int(const void* e1,const void* e2)
{
	return *(int*)e1 - *(int*)e2;
}
struct stu
{
	char name[20];
	short age;
};
int cmp_stu_by_age(const void* e1, const void* e2)
{
	//return  ((struct stu*)e1)->age - ((struct stu*)e2)->age;
	return (*(struct stu*)e1).age - (*(struct stu*)e2).age;
}
int cmp_stu_by_name(const void* e1, const void* e2)
{
	return strcmp((*(struct stu*)e1).name, (*(struct stu*)e2).name);
	//字符串比较不能直接相减，要使用strcmp
}
void test1()
{
	int arr[] = { 10,9,8,7,6,5,4,3,2,1 };
	int sz = sizeof(arr) / sizeof(arr[0]);
	qsort(arr, sz, sizeof(arr[0]), cmp_int);
	int i = 0;
	for (i = 0; i < sz; i++)
	{
		printf("%d ", arr[i]);
	}
	printf("\n");
}
void test2()
{
	struct stu s[] = { {"zhangsan",18},{"wangwu",8},{"lisi",28} };
	int sz = sizeof(s) / sizeof(s[0]);
	qsort(s, sz, sizeof(s[0]), cmp_stu_by_age);
	int i = 0;
	for (i = 0; i < sz; i++)
	{
		printf("%s %d    ", s[i].name, s[i].age);
	}
	printf("\n");
	qsort(s, sz, sizeof(s[0]), cmp_stu_by_name);
	for (i = 0; i < sz; i++)
	{
		printf("%s %d    ", s[i].name, s[i].age);
	}
	printf("\n");
}
int main()
{
	test1();	//整型数组快排
	test2();	//结构体快排
	return 0;
}
```

使用回调函数实现bubble_sort

```c
#include<stdio.h>
#include<string.h>
int cmp_int(const void* e1,const void* e2)
{
	return *(int*)e1 - *(int*)e2;
}
struct stu
{
	char name[20];
	short age;
};
int cmp_stu_by_age(const void* e1, const void* e2)
{
	//return  ((struct stu*)e1)->age - ((struct stu*)e2)->age;
	return (*(struct stu*)e1).age - (*(struct stu*)e2).age;
}
int cmp_stu_by_name(const void* e1, const void* e2)
{
	return strcmp((*(struct stu*)e1).name, (*(struct stu*)e2).name);
	//字符串比较不能直接相减，要使用strcmp
}
void Swap(char* buf1, char* buf2, int width)
{
	int i = 0;
	for (i = 0; i < width; i++)
	{
		char tmp = *buf1;
		*buf1 = *buf2;
		*buf2 = tmp;
		buf1++;
		buf2++;
	}
}
void bubble_sort(void* base, int sz, int width, int(*cmp)(void* e1, void* e2))
{
	int i = 0;
	int ret = 0;
	for (i = 0; i < sz - 1;  i++)
	{
		int j = 0;
		for (j = 0; j < sz - 1 - i; j++)
		{
			ret = cmp((char*)base + j * width, (char*)base + (j + 1) * width);
			if (ret > 0)
				Swap((char*)base + j * width, (char*)base + (j + 1) * width, width);
		}
	}
}
void test1()
{
	int arr[] = { 10,8,7,9,6,2,1,3,5,4 };
	int sz = sizeof(arr) / sizeof(arr[0]);
	bubble_sort(arr, sz, sizeof(arr[0]), cmp_int);
	int i = 0;
	for (i = 0; i < sz; i++)
	{
		printf("%d ", arr[i]);
	}
	printf("\n");
}
void test2()
{
	struct stu s[] = { {"zhangsan",18},{"wangwu",8},{"lisi",28} };
	int sz = sizeof(s) / sizeof(s[0]);
	bubble_sort(s, sz, sizeof(s[0]), cmp_stu_by_age);
	int i = 0;
	for (i = 0; i < sz; i++)
	{
		printf("%s %d    ", s[i].name, s[i].age);
	}
	printf("\n");
	bubble_sort(s, sz, sizeof(s[0]), cmp_stu_by_name);
	for (i = 0; i < sz; i++)
	{
		printf("%s %d    ", s[i].name, s[i].age);
	}
	printf("\n");
}
int main()
{
	test1();	//整型数组冒泡排序
	test2();	//结构体冒泡排序
	return 0;
}
```

## 指针和数组笔试题解析

```c
int main()
{
	//一维数组
	int a[] = { 1,2,3,4 };
	printf("%d\n", sizeof(a));				//16	//a 代表整个数组
	printf("%d\n", sizeof(a + 0));			//4/8   //a 是首元素地址，a+0 还是首元素地址
	printf("%d\n", sizeof(*a));				//4		//a 是首元素地址，*a 是首元素
	printf("%d\n", sizeof(a + 1));			//4/8	//a 是首元素地址，a+1 还是第二个元素地址
	printf("%d\n", sizeof(a[1]));			//4		//a[1] == 2
	printf("%d\n", sizeof(&a));				//4/8	//&a 是整个数组的地址
	printf("%d\n", sizeof(*&a));			//16	//*&a 相当于 a
	printf("%d\n", sizeof(&a + 1));			//4/8	//越过数组的地址
	printf("%d\n", sizeof(&a[0]));			//4/8	//首元素地址
	printf("%d\n", sizeof(&a[0] + 1));		//4/8	//第二个元素的地址
	//字符数组
	char arr[] = { 'a','b','c','d','e','f' };
	printf("%d\n", sizeof(arr));			//6		//数组的地址，计算整个数组大小
	printf("%d\n", sizeof(arr + 0));		//4/8	//首元素地址
	printf("%d\n", sizeof(*arr));			//1		//首元素
	printf("%d\n", sizeof(arr[1]));			//1		//第二个元素
	printf("%d\n", sizeof(&arr));			//4/8	//整个数组的地址
	printf("%d\n", sizeof(&arr + 1));		//4/8	//越过数组的地址
	printf("%d\n", sizeof(&arr[0] + 1));	//4/8	//第二个元素的地址
	printf("%d\n", strlen(arr));			//随机值//计算字符串arr长度，找不到‘\0'
	printf("%d\n", strlen(arr + 0));		//随机值//计算从下标0开始的字符串arr长度找不到‘\0'
	printf("%d\n", strlen(*arr));			//err	//strlen(char*)，非法访问内存
	printf("%d\n", strlen(arr[1]));			//err	//strlen(char*)，非法访问内存
	printf("%d\n", strlen(&arr));			//随机值//计算字符串arr长度，找不到‘\0'
	printf("%d\n", strlen(&arr + 1));		//随机值//计算越过数组的字符串长度，找不到‘\0'
	printf("%d\n", strlen(&arr[0] + 1));	//随机值//计算从下标1开始的字符串arr长度找不到‘\0'

	char arr[] = "abcdef";
	printf("%d\n", sizeof(arr));			//7		//数组所占内存的大小
	printf("%d\n", sizeof(arr + 0));		//4/8	//首元素地址
	printf("%d\n", sizeof(*arr));			//1		//首元素'a'
	printf("%d\n", sizeof(arr[1]));			//1		//第二个元素'b'
	printf("%d\n", sizeof(&arr));			//4/8	//数组地址
	printf("%d\n", sizeof(&arr + 1));		//4/8	//越过数组的地址
	printf("%d\n", sizeof(&arr[0] + 1));	//4/8	//第二个元素'b'的地址
	printf("%d\n", strlen(arr));			//6		//字符串长度
	printf("%d\n", strlen(arr + 0));		//6		//字符串长度	
	printf("%d\n", strlen(*arr));			//err	//strlen(char*)，非法访问内存
	printf("%d\n", strlen(arr[1]));			//err	//strlen(char*)，非法访问内存
	printf("%d\n", strlen(&arr));			//6		//字符串长度
	printf("%d\n", strlen(&arr + 1));		//随机值//越过数组的字符串长度
	printf("%d\n", strlen(&arr[0] + 1));	//5		//计算从下标1开始的字符串长度

	char* p = "abcdef";
	printf("%d\n", sizeof(p));				//4/8	//p是指针变量，字符串首元素地址
	printf("%d\n", sizeof(p + 1));			//4/8	//第二个元素地址
	printf("%d\n", sizeof(*p));				//7		//字符串所占内存空间的大小
	printf("%d\n", sizeof(p[0]));			//1		//首元素'a'的大小，arr[0] == *(arr+0) p[0] == *(p+0)
	printf("%d\n", sizeof(&p));				//4/8	//取p的地址
	printf("%d\n", sizeof(&p + 1));			//4/8	//取越过p的地址
	printf("%d\n", sizeof(&p[0] + 1));		//4/8	//第二个元素'b'的地址
	printf("%d\n", strlen(p));				//6		//字符串大小
	printf("%d\n", strlen(p + 1));			//5		//计算从下标1开始的字符串长度
	printf("%d\n", strlen(*p));				//err	
	printf("%d\n", strlen(p[0]));			//err
	printf("%d\n", strlen(&p));				//随机值
	printf("%d\n", strlen(&p + 1));			//随机值
	printf("%d\n", strlen(&p[0] + 1));		//5

	//二维数组
	int a[3][4] = { 0 };
	printf("%d\n", sizeof(a));				//4/8	//二维数组的大小
	printf("%d\n", sizeof(a[0][0]));		//4		//第一行第一列元素的大小
	printf("%d\n", sizeof(a[0]));			//16	//a[0]是第一行的数组名，计算第一行全部元素的大小
	printf("%d\n", sizeof(a[0] + 1));		//4/8	//第一行第二列元素的地址，相当于&a[0][1]
	printf("%d\n", sizeof(*(a[0] + 1)));	//4		//第一行第二列元素的大小，相当于a[0][1]
	printf("%d\n", sizeof(a + 1));			//4/8	//第二行地址的大小
	printf("%d\n", sizeof(*(a + 1)));		//16	//第二行全部元素的大小
	printf("%d\n", sizeof(&a[0] + 1));		//4/8	//第二行地址的大小
	printf("%d\n", sizeof(*(&a[0] + 1)));	//16	//第二行全部元素的大小
	printf("%d\n", sizeof(*a));				//16	//第一行全部元素的大小
	printf("%d\n", sizeof(a[3]));			//16	//sizeof括号内参数不会参与真实计算的
	return 0;
}
```

```c
int main()
{
    int a[5] = { 1, 2, 3, 4, 5 };
    int* ptr = (int*)(&a + 1);      
    //强制类型转换后ptr只可访问4个字节，ptr指向越过数组a后的地址
    printf("%d,%d", *(a + 1), *(ptr - 1));//2，5
    //*(a+1)==a[1] *(ptr-1)==ptr[-1]
    return 0;
}

struct Test
{
	int Num;
	char* pcName;
	short sDate;
	char cha[2];
	short sBa[4];
}*p;
//假设p的值为0x100000,下面表达式求值
int main()
{
	p = (struct Test*)0x100000;
	//十六进制的0x1和十进制1一样
	printf("%p\n", p + 0x1);
	//地址+-整数的知识点，指针的类型决定了指针向前或者向后走一步有多大
	//0x100014
	printf("%p\n", (unsigned long) p + 0x1);
	//整型加1
	//0x100001
	printf("%p\n", (unsigned int*)p + 0x1);
	//无符号整型指针变量加1就移动4个字节
	//0x100004
	return 0;
}

int main()
{
	int a[4] = { 1,2,3,4 };
	int* ptr1 = (int*)(&a + 1);
	//强制转换成整型类型，指向越过数组a的地址
	int* ptr2 = (int*)((int)a + 1);
	//强制转换成整型类型，（int)a+1就是指向首元素1(01 00 00 00)的第二个字节00
	//地址向后偏一个字节，*ptr2 == 00 00 00 02
	printf("%x,%x", ptr1[-1], *ptr2);
	//4，2000000
	return 0;
}

int main()
{
	int a[3][2] = { (0,1),(2,3),(4,5) };
	//a[3][2] = { 1, 3, 5};
	int* p;
	p = a[0];//a[0]是第一行数组名，p指向第一行第一列元素的地址
	printf("%d\n", p[0]);
	//p[0] == a[0][0] == 1
	return 0;
}

int main()
{
	int a[5][5];
	int(*p)[4];
	p = a;
	//p指向第一行的地址,p的数组每列有4个元素
	printf("%p,%d\n", &p[4][2] - &a[4][2], &p[4][2] - &a[4][2]);
	//-4用指针打印，其补码会被视为无符号数打印
	//11111111 11111111 11111111 11111100
	//FF FF FF FC,-4
	return 0;
}

int main()
{
	int aa[2][5] = { 1,2,3,4,5,6,7,8,9,10 };
	int* ptr1 = (int*)(&aa + 1);
	//指向越过数组的地址
	int* ptr2 = (int*)(*(aa + 1));
	//aa+1是第二行的地址，解引用得到第二行的数组名
	//*(aa+1) == aa[1]
	printf("%d,%d", *(ptr1 - 1), *(ptr2 - 1));
	return 0;
}

int main()
{
	char* a[] = { "work","at","alibaba" };
	//指针指向常量字符串的首元素地址
	char** pa = a;
	//指向a数组的首元素地址
	pa++;
	printf("%s\n", *pa);
	return 0;
}

int main()
{
	char* c[] = { "ENTER","NEW","POINT","FIRET" };
	char** cp[] = { c + 3,c + 2,c + 1,c };
	char*** cpp = cp;
	//注意++cpp后cpp存储的地址也会变
	printf("%s\n", **++cpp);
	//cpp指向c+2，两次解引用得到"POINT"的首元素地址
	//POINT
	printf("%s\n", *--*++cpp + 3);
	//cpp指向c+1，*--(c+1)，*c，得到"ENTER"的首元素地址，再+3就指向"ER"的"E"的地址
	//ER
	printf("%s\n", *cpp[-2] + 3);
	//**(cpp-2)后cpp的值不会发生变化，还是指向c+1
	//(cpp-2)指向了c+3，两次解引用得到"FIRST"的首元素地址，再+3就指向"ET"的"E"的地址
	//ET
	printf("%s\n", cpp[-1][-1] + 1);
	//*(*(cpp-1)-1)
	//cpp-1指向了c+2，*(c+1)得到"NEW"的首元素地址，再+1就指向"EW"的"E"的地址
	//EW
	return 0;
}

int main()
{
	unsigned int a = 0x1234;
	unsigned char b = *(unsigned char*)&a;
	//取地址a再解引用只能访问1个字节
	printf("%d\n", b);
	return 0;
}
```

# 字符函数和字符串函数

## 字符串函数

### `strlen`

```c
size_t strlen ( const char * str );
```

- 字符串已经`'\0'`作为结束标志，`strlen`函数返回的是在字符串中`'\0'`前面出现的字符个数（不包含`'\0'`)。
- 参数指向的字符串必须要以`'\0'`结束。
- 注意函数的返回值为`size_t`，是无符号的。

```c
//my_strlen的三种方法：1、计数器  2、递归  3、指针减指针
//计数器
#include<stdio.h>
#include<assert.h>
unsigned int my_strlen(const char* str)
{
	assert(str);
    int count = 0;
    while (*str)
    {
        count++;
        str++;
    }
    return count;
}

//递归(不创建临时变量)
unsigned int my_strlen(const char* str)
{
	assert(str);
    if (*str)
        return 1 + my_strlen(++str);
    else
        return 0;
}

//指针减指针
unsigned int my_strlen(const char* str)
{
	assert(str);
    const char* p = str;
    while (*p++);
    p--;
    return p - str;
} 
int main()
{
    char arr[] = "abcdef";
    printf("字符串长度 = %d\n", my_strlen(arr));
    return 0;
}
```

### **`strcpy`**

```c
char* strcpy(char * destination, const char * source );
```

- 返回目标字符串地址。
- source必须以`'\0'`结束，会将source中的`'\0'`拷贝到destination空间。
- destination必须足够大，以确保能存放source。destination空间必须可变。

```c
#include<stdio.h>
#include<assert.h>
char* my_strcpy(char* dest, const char* src)
{
    assert(dest && src);
    char* tmp = dest;
    while (*dest++ = *src++);
    return tmp;
}
int main()
{
    char arr1[] = "abcdef";
    char arr2[] = "bit";
    printf("%s\n", my_strcpy(arr1, arr2));
    return 0;
}
```

### **`strcat`**

```c
char * strcat ( char * destination, const char * source );
```

- 把source所指向的字符串（包括`'\0'`）复制到destination所指向的字符串后面（删除destination原来末尾的`'\0'`）。
- 要保证destination足够长，以容纳被复制进来的source。source中原有的字符不变。返回destination。
- **字符串不能用`strcat`自己给自己追加。**

```c
#include<stdio.h>
#include<assert.h>
char* my_strcat(char* dest, const char* src)
{
    assert(dest && src);
    char* p = dest;
    while (*dest)
        dest++;
    while (*dest++ = *src++);
    return p;
}
int main()
{
    char arr1[] = "abcdef\0xxxxxx";
    char arr2[] = "bit";
    printf("%s\n", my_strcat(arr1, arr2));
    return 0;
}
```

### **`strcmp`**

```c
int strcmp(const char* str1, const char* str2);
```

- 当`str1 < str2`时，返回为负数；当`str1 == str2`时，返回值= 0；当`str1 > str2`时，返回正数。
- 两个字符串自左向右逐个字符相比（按ASCII值大小相比较），直到出现不同的字符或遇`'\0'`为止。
- 当两个字符串不相等时，C标准没有规定返回值会是1 或 -1，只规定了正数和负数。（VS编译器下返回1、-1、0）。有些会把两个字符的ASCII码之差作为比较结果由函数值返回。但无论如何不能以此条依据作为程序中的流程逻辑。

```c
#include<stdio.h>
#include<assert.h>
int my_strcmp(const char* str1, const char* str2)
{
    assert(str1 && str2);
    while (*str1 == *str2)
    {
        if (*str1 == '\0')
            return 0;
        str1++;
        str2++;
    }
    return *str1 - *str2;
}
int main()
{
    char arr1[] = "abcdef";
    char arr2[] = "abcqwe";
    int ret = my_strcmp(arr1, arr2);
    if (ret > 0)
        printf("arr1>arr2\n");
    else if (ret < 0)
        printf("arr1<arr2\n");
    else
        printf("arr1=arr2\n");
    return 0;
}
```

### **`strncpy`**

```c
char* strncpy(char* strDestination, const char* strSource, size_t num);
```

- 拷贝num个字符从源字符串到目标空间。
- 如果源字符串的长度小于num，则拷贝完源字符串之后，在目标的后边追加`'\0'`，直到num个。

```c
#include<stdio.h>
#include<assert.h>
char* my_strncpy(char* dest, const char* src, unsigned int num)
{
    assert(dest && src);
    char* p = dest;
    while (num && *src)
    {
        *dest++ = *src++;
        num--;
    }
    while(num--)
        *dest++ = '\0';
    return p;
}
int main()
{
    char p1[] = "abcde";
    char p2[] = "qwer";
    int num = 3;
    printf("%s\n", my_strncpy(p1, p2, num));
    //qwede\0

    char p1[] = "abcde";
    char p2[] = "qw";
    int num = 4;
    printf("%s\n", my_strncpy(p1, p2, num));
    //qw\0\0e\0
    return 0;
}
```

### **`strncat`**

```c
char* strncat(char* destination, const char* source, size_t num);
```

- 追加num个字符从源字符串到目标空间。
- 如果源字符串的长度小于num，则追加完源字符串之后，在目标的后边追加`'\0'`。

```c
#include<stdio.h>
#include<assert.h>
char* my_strncat(char* dest, const char* src, unsigned int num)
{
	assert(dest && src);
	char* p = dest;
	while (*dest)
		dest++;
	while (num && *src)
	{
		*dest++ = *src++;
		num--;
	}
	*dest = '\0';
	return p;
}
int main()
{
	char p1[] = "hello\0xxxxxx";
	char p2[] = "world";
	int num = 3;
	printf("%s\n", my_strncat(p1, p2, num));
	//hellowor\0xxx\0   当num == 3时
	//helloworld\0x\0   当num == 7时
	return 0;
}
```

### **`strncmp`**

```c
int strncmp(const char* str1, const char* str2, size_t num);
```

- 比较两个字符串的前num个字符

```c
#include<stdio.h>
#include<assert.h>
int my_strncmp(const char* str1, const char* str2, unsigned int num)
{
	assert(str1 && str2);
	while (num && *str1 && *str1 == *str2)
	{
		str1++;
		str2++;
		num--;
	}
	return *str1 - *str2;
}
int main()
{
	char p1[] = "abcde";
	char p2[] = "abcf";
	int num = 4;
	int ret = my_strncmp(p1, p2, num);
	if (ret > 0)
		printf("p1>p2\n");
	else if (ret < 0)
		printf("p1<p2\n");
	else
		printf("p1=p2\n");
	return 0;
}
```

### **`strstr`**

```c
char *strstr( const char *string, const char *strCharSet );
```

- `strstr`函数用于判断字符串str2是否是str1的子串。如果是，则该函数返回 str1字符串从 str2第一次出现的位置开始到 str1结尾的字符串；否则，返回NULL。

```c
#include<stdio.h>
#include<assert.h>
char* my_strstr(const char* str1, const char* str2) {
	assert(str1 && str2);
	const char* p1 = str1;
	const char* p2 = str2;
	while (*str1) {
		p1 = str1;
		p2 = str2;
		while (*p1 && *p2 && *p1 == *p2) {
			p1++, p2++;
		}
		if (*p2 == '\0')
			return str1;
		str1++;
	}
	return NULL;
}
int main() {
	char str1[] = "abababccabc";
	char str2[] = "abc";
	char* p = my_strstr(str1, str2);
	if (p)
		printf("找到了\n");
	else
		printf("找不到\n");

	return 0;
}
```

### **`strtok`**

```c
char *strtok( char *str, const char *sep );
```

- sep参数是个字符串，定义了用作分隔符的字符集合。
- 第一个参数指定一个字符串，它包含了0个或者多个由sep字符串中一个或者多个分隔符分割的标记。
- `strtok`函数找到str中的下一个标记，并将其用 `\0` 结尾，返回一个指向这个标记的指针。（注： `strtok`函数会改变被操作的字符串，所以在使用`strtok`函数切分的字符串一般都是临时拷贝的内容并且可修改。）
- `strtok`函数的第一个参数不为`NULL` ，函数将找到str中第一个标记，`strtok`函数将保存它在字符串 中的位置。
- `strtok`函数的第一个参数为`NULL`，函数将在同一个字符串中被保存的位置开始，查找下一个标记。
- 如果字符串中不存在更多的标记，则返回`NULL`指针。

```c
#include<stdio.h>
int main()
{
    char str[] = "-This.a,sample-string.";
    char* sep = "-,.";
    char* pch = NULL;
    printf("Splitting string \"%s\" into tokens:\n", str);
    for (pch = strtok(str, sep); pch != NULL; pch = strtok(NULL, sep))
        printf("%s\n", pch);
    return 0;
}
```

### **`strerror`**

```c
char* strerror( int errnum );
```

```c
#include<stdio.h>
#include<string.h>
#include<errno.h>
int main()
{
    //errno - 是一个全局的错误的变量
    FILE* pf = fopen("test.txt", "r");
    if (pf == NULL) {
        printf("%s\n", strerror(errno));
        //perror("fopen");
       return 1;
    }
    else
        printf("open file successfully");
    fclose(pf);
    pf = NULL;
    return 0;
}
```

## 字符函数

```c
#include<stdio.h>
#include<ctype.h>		//字符函数引用头文件
int main()
{
    //字符分类函数
    char ch = '10';
    //isdight   是否是数字
    int ret = isdigit(ch);
    printf("%d\n", ret);    //4

    //isxdight  是否是十六进制
    ret = isxdigit('0');
    printf("%d\n", ret);    //128

    //iscntrl   是否是控制字符
    ret = iscntrl('\n');
    printf("%d\n", ret);    //32

    //isspace   是否空白字符
    ret = isspace(' ');
    printf("%d\n", ret);    //8

    //islower   是否是小写字母
    ret = islower('a');
    printf("%d\n", ret);    //2

    //isupper   是否是大写字母
    ret = isupper('A');
    printf("%d\n", ret);    //1

    //isalpha   是否是字母
    ret = isalpha('a');
    printf("%d\n", ret);    //2

    //isalnum   是否是字母或数字
    ret = isalnum('0');
    printf("%d\n", ret);    //4
    
    //ispunct   是否是标点
    ret = ispunct(';');
    printf("%d\n", ret);    //16

    //isgraph   是否是图形字符
    ret = isgraph('0');
    printf("%d\n", ret);    //4

    //isprint 任何可打印字符 包括图形字符和空白字符
    ret = isprint('\n');
    printf("%d\n", ret);    //0

    //以上函数返回值：如果参数是则返回非0，否则返回0。
    return 0;
}

int main()
{
    //字符转换函数
    char ch = 'a';
    //tolower 将大写字母转换为小写字符。
    //如果传递给tolower()函数的参数不是大写字母，则它返回传递给该函数的相同字符。
    char ret = toupper(ch);
    printf("%c\n", ret);

    //toupper 将小写字母转换为大写字符。
    //如果传递给toupper()函数的参数不是小写字母，则它返回传递给该函数的相同字符。
    ret = tolower(ret);
    printf("%c\n", ret);
    return 0;
}
```

| 函数 | 功能描述 |
| --- | --- |
| iscntrl | 任何控制字符（如换页、换行等） |
| isspace | 如包括空格、换页、换行、回车、制表符或垂直制表符 |
| isdigit | 十进制数字（0~9） |
| isxdigit | 十六进制数字（包括所有十进制数字、小写字母a~f 或 大写字母A~F） |
| islower | 小写字母（a~z） |
| isupper | 大写字母（A~Z） |
| isalpha | 字母（a~z 或 A~Z） |
| isalnum | 字母或数字（包括a~z、 A~Z 和 0~9） |
| ispunct | 标点符号（即任何不属于数字或字母的图形字符） |
| isgraph | 任何图形字符（即非空格字符） |
| isprint | 任何可打印字符（包括图形字符和空白字符） |

## 内存函数

### `memcpy`

```c
void *memcpy( void *dest, const void *src, size_t count );
```

- 函数`memcpy`从source的位置开始向后复制num个字节的数据到destination的内存位置。
- 这个函数在遇到 '\0' 的时候并不会停下来。
- 如果source和destination有任何的重叠，复制的结果都是未定义的。
- C语言标准中的`memcpy`函数只拷贝不重叠的字节，而在VS编译器中可以处理重叠拷贝，类似于`memmove`。

```c
#include<stdio.h>
#include<string.h> //内存函数头文件
int main()
{
    int arr1[] = { 1,2,3,4,5 };
    int arr2[5] = { 0 };
    memcpy(arr2, arr1, sizeof(arr1));
    int i = 0;
    for (i = 0; i < 5; i++)
        printf("%d ", arr2[i]);
    return 0;
}

//模拟实现memcpy
#include<stdio.h>
#include<assert.h>
void* my_memcpy(void* dst, const void* src, size_t num)
{
    assert(dst && src);
    void* ret = dst;
    while (num--)
    {
        *(char*)dst = *(char*)src;
        ++(char*)dst;
        ++(char*)src;
    }
    return ret;
}
int main()
{
    int arr1[] = { 1,2,3,4,5,6,7,8,9,10 };
    int arr2[10] = { 0 };
    my_memcpy(arr2, arr1+2, 20);
    int sz = sizeof(arr2) / sizeof(arr2[0]);
    int i = 0;
    for (i = 0; i < sz; i++)
        printf("%d ", arr2[i]);
    return 0;
}
```

### `memmove`

```c
void *memmove( void *dest, const void *src, size_t count );
```

- 和`memcpy`的差别就是`memmove`函数处理的源内存块和目标内存块是可以重叠的。
- 如果源空间和目标空间出现重叠，就得使用`memmove`函数处理。

```c
#include<stdio.h>
#include<assert.h>
void* my_memmove(void* dst, const void* src, size_t num)
{
    assert(dst && src);
    void* ret = dst;
    if (dst < src)
        while (num--)
        {
            *(char*)dst = *(char*)src;
            ++(char*)dst, ++(char*)src;
        }
    else
        while (num--)
        {
            *((char*)dst + num) = *((char*)src + num);
        }
    return ret;
}
int main()
{
    int arr[] = { 1,2,3,4,5,6,7,8,9,10 };
    my_memmove(arr + 2, arr, 20);
    int sz = sizeof(arr) / sizeof(arr[0]);
    int i = 0;
    for (i = 0; i < sz; i++)
        printf("%d ", arr[i]);
    return 0;
}
```

### `memcmp`

```c
int memcmp( const void *ptr1, const void *ptr2, size_t count );
```

- 比较从ptr1和ptr2指针开始的num个字节
- 如果返回值 < 0，则表示 str1 小于 str2。如果返回值 > 0，则表示 str2 小于 str1。如果返回值 = 0，则表示 str1 等于 str2。

```c
#include<stdio.h>
#include<assert.h>
int my_memcmp(const void* ptr1, const void* ptr2, size_t num)
{
    assert(ptr1 && ptr2);
    if (!num)
        return 0;
    while ((num--) && (*(char*)ptr1 == *(char*)ptr2))
        ++(char*)ptr1, ++(char*)ptr2;
    return *(char*)ptr1 - *(char*)ptr2;
}
int main()
{
    int p1[] = { 1,2,3,4,5 };
    int p2[] = { 1,2,3,3,3 };
    int ret = my_memcmp(p1, p2,8);
    if (ret > 0)
        printf("p1 > p2");
    else if (ret < 0)
        printf("p1 < p2");
    else
        printf("p1 = p2");
    return 0;
}
```

### `memset`

```c
void *memset( void *dest, int c, size_t count );  
```

- dest指向要填充的内存块。
- c是要被设置的值。
- count是要被设置该值的字符数。
- 返回类型是一个指向存储区的指针。

```c
#include<stdio.h>
#include<string.h>
int main() {
	int arr[10];
	memset(arr, 1, sizeof(arr));
	int i = 0;
	for (i = 0; i < 10; i++)
		printf("%d ", arr[i]);
	return 0;
}
```

# 自定义类型

## 结构体

**初阶结构体**

```c
#include<stdio.h>
struct S
{
	char arr[10];
	int i;
}s1 = { "123",4 };//全局变量
struct P
{
	char ch;
	struct S s;
	float f;
	struct P* next;//结构体自引用
};
struct P p1 = { 'A',{"hello",10},95.5f,NULL };//全局变量

void Print1(struct P sp)
{
	printf("%c %s %d %f\n", sp.ch, sp.s.arr, sp.s.i, sp.f);
}
void Print2(struct P* p)
{
	printf("%c %s %d %f\n", (*p).ch, (*p).s.arr, (*p).s.i, (*p).f);
	printf("%c %s %d %f\n", p->ch, p->s.arr, p->s.i, p->f);
}

int main()
{
	struct P p2 = { 'B',{"hi",99},3.14f,NULL };//局部变量
	Print1(p2);
	Print2(&p2);
	return 0;
}
```

> 结构体传参首选**传地址**。函数传参的时候，参数是需要压栈的。如果传递一个结构体对象的时候，结构体过大，参数压栈的的系统开销比较大，所以会导致性能的下降。


```c
typedef struct stu      
{
    char name[20];
    short age;
    char sex[5];
    int id[20];
}stu;//结构体类型 struct stu 重命名为 stu
stu s1;

struct//匿名结构体类型
{
    int a;
    char b;
    float c;
}x;//匿名结构体类型只能在声明时定义。
struct
{
    int a;
    char b;
    float c;
}a[20], * p;
//*p = &x;  非法，编译器会把上面的两个声明当成完全不同的两个类型。
//匿名结构体类型不适用结构体重命名。
```

**自引用**

```c
//错误自引用
struct Node
{
    int data;
    struct Node next;
};
//正确自引用
struct Node
{
    int data;
    struct Node* next;
};
typedef struct Node
{
 int data;
 struct Node* next;//不能写成Node* next;
}Node;
```

**乱序初始化**

```c
typedef struct stu      
{
    char name[20];
    short age;
    char sex[5];
    int id[20];
}stu;
int main() {
    stu s = { .age = 18,.id = 20240423,.name = "zhangsan",.sex = "male" };
    return 0;
}
```

**结构体内存对齐**

1. 第一个成员在与结构体变量偏移量为0的地址处。
2. 其他成员变量要**对齐到某个数字（对齐数）的整数倍的地址处**。 对齐数 = 编译器默认的一个对齐数 与 该成员大小的较小值。数组的最大对齐数依据元素类型。 VS中默认的值为8
3. **结构体总大小为最大对齐数（每个成员变量都有一个对齐数）的整数倍**。
4. 如果嵌套了结构体的情况，嵌套的结构体对齐到**自己成员的最大对齐数的整数倍处**，结构体的整体大小就是所有最大对齐数（含嵌套结构体的对齐数）的整数倍。

```c
struct S1
{
    char c1;
    int i;
    char c2;
};
printf("%d\n", sizeof(struct S1));//12

struct S2
{
    char c1;
    char c2;
    int i;
};
printf("%d\n", sizeof(struct S2));//8

struct S3
{
    double d;
    char c;
    int i;
};
printf("%d\n", sizeof(struct S3));//16

struct S4
{
    char c1;
    struct S3 s3;
    double d;
};
printf("%d\n", sizeof(struct S4));//32
```

- 为什么存在内存对齐?
    - 平台原因(移植原因)：不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。
    - 性能原因：数据结构(尤其是栈)应该尽可能地在自然边界上对齐。原因在于，为了访问未对齐的内存，处理器需要作两次内存访问；而对齐的内存访问仅需要一次访问。

> 那在设计结构体的时候，让占用空间小的成员尽量集中在一起，既满足对齐，又节省空间。


```c
#include <stdio.h>
#pragma pack(8)//设置默认对齐数为8
//编译选项，表示8字节对齐
struct S1
{
    char c1;
    int i;
    char c2;
};
#pragma pack()//取消设置的默认对齐数，还原为默认
#pragma pack(1)//设置默认对齐数为1
struct S2
{
    char c1;
    int i;
    char c2;
};
#pragma pack()//取消设置的默认对齐数，还原为默认
int main()
{
    //输出的结果是什么？
    printf("%d\n", sizeof(struct S1));
    printf("%d\n", sizeof(struct S2));
    return 0;
}
```

**偏移量计算**

```c
#include<stdio.h>
#define OFFSETOF(type,member) (int)&(((type*)0)->member)
struct S
{
    char a;
    int b;
    char c;
};
int main()
{
    printf("%d\n", OFFSETOF(struct S, a));
    printf("%d\n", OFFSETOF(struct S, b));
    printf("%d\n", OFFSETOF(struct S, c));
    return 0;
}
```

## 位段

1. 位段的成员可以是 int unsigned int signed int 或者是 char （属于整形家族）类型
2. 位段的空间上是按照需要以4个字节（ int ）或者1个字节（ char ）的方式来开辟的。
3. 位段涉及很多不确定因素，位段是不跨平台的，注重可移植的程序应该避免使用位段。

```c
struct S
{
	char a : 3;
	char b : 4;
	char c : 5;
	char d : 4;
};
int main()
{
	struct S s = { 0 };
	s.a = 10;	//00001010	//010
	s.b = 12;	//00001100	//1100
	s.c = 3;	//00000011	//00011
	s.d = 4;	//00000100	//0100
	//以1字节开辟内存 
	//0110 0010 0000 0011 0000 0100
	//  6   2    0   3    0   4
	return 0;
}
```

**位段的跨平台问题**

1. int 位段被当成有符号数还是无符号数是不确定的。
2. 位段中最大位的数目不能确定。（16位机器最大16，32位机器最大32，写成27，在16位机器会出问题。
3. 位段中的成员在内存中从左向右分配，还是从右向左分配标准尚未定义。
4. 当一个结构包含两个位段，第二个位段成员比较大，无法容纳于第一个位段剩余的位时，是舍弃剩余的位还是利用，这是不确定的。

**位段的应用**

<img src="https://cdn.jsdelivr.net/gh/SYLV14/PicGo_Save/typora_images/202406112239399.png" alt="image" style="zoom: 33%;" />

## 枚举

```c
#include<stdio.h>
enum Day//星期
{
	Mon,	//0
	Tues,	//1
	Wed,	//2
	Thur,	//3
	Fri,	//4
	Sat,	//5
	Sun		//6
};
enum Sex//性别
{
	MALE = 1,	//1
	FEMALE,	//2
	SECRET	//3
};
enum Color//颜色
{
	RED,	//0
	GREEN = 9,//9
	BLUE	//10
};
int main()
{
	enum Day a = Mon;// 只能拿枚举常量给枚举变量赋值，才不会出现类型的差异。
	enum Color b = BLUE;
	b = 11;	//err
	//b 是enum Color类型，11 是int类型
	//虽然在C语言编译环境下未报错，但实际是错误语法，在C++中会报错。
	printf("%d %d\n", sizeof(enum Day), sizeof(Mon));	//4 4
	return 0;
}
```

我们可以使用 `#define` 定义常量，为什么非要使用枚举？

枚举的优点：

1. 增加代码的可读性和可维护性
2. 和`#define`定义的标识符比较枚举有类型检查，更加严谨
3. 防止了命名污染（封装）
4. 便于调试
5. 使用方便，一次可以定义多个常量

## 联合

联合也是一种特殊的自定义类型，这种类型定义的变量也包含一系列的成员，特征是**这些成员公用同一块空间**（所以联合也叫共用体）。

```c
#include<stdio.h>
union Un
{
	char c;
	int i;
};
int main()
{
	//联合变量的定义
	union Un un;
	//计算连个变量的大小
	printf("%d\n", sizeof(un));		//4
	//地址相同
	printf("%p\n", &un);//0133FE88
	printf("%p\n", &(un.i));//0133FE88
	printf("%p\n", &(un.c));//0133FE88
	un.i = 0x11223344;
	un.c = 0x55;
	printf("%x\n", un.i);
	//11223355
	return 0;
}
```

**计算联合的大小**

联合的大小至少是最大成员的大小。

当最大成员大小不是最大对齐数的整数倍的时候，就要对齐到最大对齐数的整数倍。

```c
union Un1
{
	char c[5];	//数组元素的类型算对齐数 对齐数是1
	int i;		//对齐数是4
};
union Un2
{
	short c[7];	//对齐数是2
	int i;		//对齐数是4
};
int main()
{
	//下面输出的结果是什么？
	printf("%d\n", sizeof(union Un1));//8
	printf("%d\n", sizeof(union Un2));//16
	return 0;
}
```

```c
判断大小端：
#include<stdio.h>
union Un
{
	char c;
	int i;
};
int main()
{
	union Un u;
	u.i = 1;
	if (u.c == 1)
		printf("小端\n");
	else
		printf("大端\n");
	return 0;
}
```

# 动态内存管理

## 动态内存函数

### `malloc和free`

```c
void* malloc(size_t size);
```

这个函数向内存申请一块连续可用的空间，并返回指向这块空间的指针。

- 如果开辟成功，则返回一个指向开辟好空间的指针。
- 如果开辟失败，则返回一个`NULL`指针，因此`malloc`的返回值一定要做检查。
- 返回值的类型是 `void*` ，所以`malloc`函数并不知道开辟空间的类型，具体在使用的时候使用者自己来决定。
- 如果参数 size 为0，`malloc`的行为是标准是未定义的，取决于编译器。

C语言提供了另外一个函数free，专门是用来做动态内存的释放和回收的，函数原型如下：

```c
void free(void* ptr);
```

`free`函数用来释放动态开辟的内存。

- 如果参数 ptr 指向的空间不是动态开辟的，那`free`函数的行为是未定义的。
- 如果参数 ptr 是`NULL`指针，则函数什么事都不做。

```c
#include<stdio.h>
#include<stdlib.h>
#include<errno.h>
#include<string.h>
int main()
{
	int* p = malloc(10 * (sizeof(int)));
	if (p == NULL)
	{
		printf("%s\n", strerror(errno));
		return 1;
		//Not enough space
	}
	int i = 0;
	for (i = 0; i < 10; i++)
	{
		*(p + i) = i + 1;
		printf("%d ", *(p + i));
	}
	printf("\n");
	//当动态申请的空间不再使用时，就应该还给操作系统，释放该空间。
	free(p);
	p = NULL;
	return 0;
}
```

### `calloc`

```c
void* calloc(size_t num, size_t size);
```

- 函数的功能是为 num 个大小为 size 的元素开辟一块空间，**并且把空间的每个字节初始化为0**。

```c
#include<stdio.h>
#include<stdlib.h>
int main()
{
	int* p = (int*)calloc(10, sizeof(int));
	if (p == NULL)
	{
		printf("%s\n", strerror(errno));
		return 1;
	}
	else
	{
		int i = 0;
		for (i = 0; i < 10; i++)
		{
			printf("%d ", *(p + i));
			//每个字节初始化为0
		}
	}
	free(p);
	p = NULL;
	return 0;
}
```

### `realloc`

有时会我们发现过去申请的空间太小了，有时候我们又会觉得申请的空间过大了，那为了合理的时候内存，我们一定会对内存的大小做灵活的调整。那`realloc` 函数就可以做到对动态开辟内存大小的调整。

```c
void* realloc(void* ptr, size_t size);
```

- ptr 是要调整的内存地址
- size 调整之后新大小
- 返回值为调整之后的内存起始位置。
- 这个函数调整原内存空间大小的基础上，还会将原来内存中的数据移动到新的空间。
- `realloc`在调整内存空间的是存在两种情况：
  
    情况1：要扩展内存就直接原有内存之后直接追加空间，原来空间的数据不发生变化。
    
    情况2：原有空间之后没有足够多的空间时，扩展的方法是：在堆空间上另找一个合适大小的连续空间来使用，**释放掉原来的空间**。这样函数返回的是一个新的内存地址。
    

```c
#include<stdio.h>
#include<stdlib.h>
int main() {
	int* p = (int*)malloc(5 * sizeof(int));
	if (!p) {
		perror("malloc");
		return 1;
	}
	int i = 0;
	for (i = 0; i < 5; i++)
		*(p + i) = i;
	int* ptr = (int*)realloc(p, 10 * sizeof(int));
	if (ptr)
		p = ptr;
	for (i = 0; i < 10; i++)
		*(p + i) = i;
	free(p);
	p = NULL;
	return 0;
}

int* p = (int*)realloc(NULL, 40);
等价于
int* p = (int*)malloc(40);
```

## 常见的动态内存错误

```c
//对NULL指针的解引用操作
void test()
{
	int* p = (int*)malloc(INT_MAX / 4);
	*p = 20;//如果p的值是NULL，就会有问题
	free(p);
}

//对动态开辟空间的越界访问
void test()
{
	int i = 0;
	int* p = (int*)malloc(10 * sizeof(int));
	if (NULL == p)
	{
		exit(EXIT_FAILURE);
	}
	for (i = 0; i <= 10; i++)
	{
		*(p + i) = i;//当i是10的时候越界访问
	}
	free(p);
}

//对非动态开辟内存使用free释放
void test()
{
	int a = 10;
	int* p = &a;
	free(p);//p属于局部变量，在栈区开辟，free只释放堆区开辟的内存空间
}

//使用free释放一块动态开辟内存的一部分
void test()
{
	int* p = (int*)malloc(100);
	p++;
	free(p);//p不再指向动态内存的起始位置，向后跳了4个字节。
	//注意：p++后p指向的位置就跟着变了，p+i不会改变p指向的位置。
}

//对同一块动态内存多次释放
void test()
{
	int* p = (int*)malloc(100);
	free(p);
	free(p);//重复释放
}

//动态开辟内存忘记释放（内存泄漏）
void test()
{
	int* p = (int*)malloc(100);
	if (NULL != p)
	{
		*p = 20;
	}
}
int main()
{
	test();
	while (1);
}
```

## 经典笔试题

**题目一**

```c
void GetMemory(char* p)
{
	p = (char*)malloc(100);
}
void Test(void)
{
	char* str = NULL;
	GetMemory(str);
	strcpy(str, "hello world");	//程序崩溃
	printf(str);
}
int main()
{
	Test();
	return 0; 
}
//关于空指针传参问题:
//str以值的形式传递给p，则调用GetMemory函数后p的值为NULL，然后开辟内存空间的地址再赋值给p，此值并未传给str
//GetMemory结束后动态内存空间未释放，并且无法找到，造成内存泄漏
改正1：
void GetMemory(char** p)
{
	*p = (char*)malloc(100);
}
void Test(void)
{
	char* str = NULL;
	GetMemory(&str);
	strcpy(str, "hello world");
printf(str);
	free(str);
	str = NULL;
}
int main()
{
	Test();
	return 0;
}
```

**题目二**

```c
char* GetMemory(void)
{
	char p[] = "hello world";
	return p;
}
void Test(void)
{
	char* str = NULL;
	str = GetMemory();
	printf(str);
}
int main()
{
	Test();
	return 0;
}
//关于返回栈空间地址的问题：
//在函数结束后，地址确实传递给了str，但地址中的内容已经被释放，造成野指针非法访问内存
改正：
char* GetMemory(void)
{
	char* p = "hello world";//常量字符串并不会随函数销毁
	//static char p[] = "hello world";
	return p;
}

void Test(void)
{
	char* str = NULL;
	str = GetMemory(str);
	printf(str);
}
int main()
{
	Test();
	return 0;
}
```

**题目三**

```c
void GetMemory(char** p, int num)
{
	*p = (char*)malloc(num);
}
void Test(void)
{
	char* str = NULL;
	GetMemory(&str, 100);
	strcpy(str, "hello");
	printf(str);
}
int main()
{
	Test();
	return 0;
}
//未释放空间，造成内存泄漏
void GetMemory(char** p, int num)
{
	*p = (char*)malloc(num);
}
void Test(void)
{
	char* str = NULL;
	GetMemory(&str, 100);
	strcpy(str, "hello");
	printf(str);
	free(str);
	str = NULL;
}
int main()
{
	Test();
	return 0;
}
```

**题目四**

```c
void Test(void)
{
	char* str = (char*)malloc(100);
	strcpy(str, "hello");
	free(str);
	if (str != NULL)
	{
		strcpy(str, "world");
		printf(str);
	}
}
int main()
{
	Test();
	return 0;
}
//释放空间早了，str变成野指针，非法访问内存
void Test(void)
{
	char* str = (char*)malloc(100);
	strcpy(str, "hello");
	if (str != NULL)
	{
		strcpy(str, "world");
		printf(str);
	}
	free(str);
	str = NULL;
}
int main()
{
	Test();
	return 0;
}
```

## C/C++程序的内存开辟

详见C++ 5.1章节

## 柔性数组

C99中，结构中的最后一个元素允许是未知大小的数组，这就叫做『柔性数组』成员。

```c
typedef struct st_type
{
	int i;
	int a[0];//柔性数组成员
}type_a;
//有些编译器会报错无法编译可以改成：
typedef struct st_type
{
	int i;
	int a[];//柔性数组成员
}type_a;
```

**特点：**

- 结构中的柔性数组成员前面必须至少一个其他成员。
- `sizeof` 返回的这种结构大小不包括柔性数组的内存。
- 包含柔性数组成员的结构用`malloc`函数进行内存的动态分配，并且分配的内存应该大于结构的大小，以适应柔性数组的预期大小。

```c
typedef struct st_type
{
	int i;
	int a[0];//柔性数组成员
}type_a;
printf("%d\n", sizeof(type_a));//输出的是4
```

**使用**

```c
#include<stdio.h>
typedef struct st_type
{
	int i;
	int a[0];//柔性数组成员
}type_a;
int main()
{
	int i = 0;
	type_a* p = (type_a*)malloc(sizeof(type_a) + 100 * sizeof(int));
	if (p == NULL) {
		perror("malloc");
		return 1;
	}
	p->i = 100;
	for (i = 0; i < 100; i++)
	{
		p->a[i] = i;
	}
	free(p);
	p = NULL;
	return 0;
}
```

**柔性数组的优势**

```c
#include<stdio.h>
typedef struct st_type
{
	int i;
	int* a;
}type_a;
int main()
{
	type_a* p = (type_a*)malloc(sizeof(type_a));
	if (p == NULL) {
		perror("malloc::p");
		return 1;
	}
	p->i = 100;
	p->a = (int*)malloc(p->i * sizeof(int));
	if(p->a==NULL) {
		perror("malloc::a");
		return 1;
	}
	int i = 0;
	for (i = 0; i < 100; i++)
		p->a[i] = i;
	free(p->a);
	p->a = NULL;
	free(p);
	p = NULL;
	return 0;
}
```

第一个好处方便内存释放，第二个好处有利于访问速度

# 文件操作

## 定义

磁盘上的文件是文件。但是在程序设计中，我们一般谈的文件有两种：程序文件、数据文件（从文件功能的角度来分类的）。

- 程序文件

包括源程序文件（后缀为.c）,目标文件（windows环境后缀为.obj）,可执行程序（windows环境后缀为.exe）。

- 数据文件

根据数据的组织形式，数据文件被称为**文本文件或者二进制文件**。

数据在内存中以二进制的形式存储，如果不加转换的输出到外存，就是**二进制文件**。

如果要求在外存上以ASCII码的形式存储，则需要在存储前转换。以ASCII字符的形式存储的文件就是**文本文件**。

- 文件名

一个文件要有一个唯一的文件标识，以便用户识别和引用。 文件名包含3部分：文件路径+文件名主干+文件后缀

例如： `c:\code\test.txt` 为了方便起见，文件标识常被称为文件名。

## 文件缓冲区

ANSIC 标准采用“缓冲文件系统”处理的数据文件的，所谓缓冲文件系统是指系统自动地在内存中为程序中每一个正在使用的文件开辟一块“文件缓冲区”。从内存向磁盘输出数据会先送到内存中的缓冲区，装满缓冲区后才一起送到磁盘上。如果从磁盘向计算机读入数据，则从磁盘文件中读取数据输入到内存缓冲区（充满缓冲区），然后再从缓冲区逐个地将数据送到程序数据区（程序变量等）。缓冲区的大小根据C编译系统决定的。

<img src="https://cdn.jsdelivr.net/gh/SYLV14/PicGo_Save/typora_images/202406112239400.png" alt="image-20240508200453709" style="zoom: 50%;" />

## 文件打开和关闭

**文件指针**：缓冲文件系统中，关键的概念是“文件类型指针”，简称“文件指针”。头文件时`stdio.h`

```c
FILE* pf;	//文件指针变量
```

**打开和关闭文件**

文件在读写之前应该先打开文件，在使用结束之后应该关闭文件。

```c
//打开文件
FILE* fopen(const char* filename, const char* mode);
//关闭文件
int fclose(FILE * 流);
```

`fopen`：如果文件成功打开，该函数将返回指向 FILE 对象的指针，该对象可用于在将来的操作中标识流。打开失败则返回 `NULL`

`fclose`：如果 流 成功关闭，则返回0。失败时，返回 `EOF`。

只要打开一个文件，就会得到一个文件流。有了文件流之后，就可以对文件进行相应的读写操作。

| 文件使用方式 | 含义 | 如果指定文件不存在 |
| --- | --- | --- |
| "r"（只读） | 为了输入数据，打开一个已经存在的文本文件 | 出错 |
| "w"（只写） | 为了输出数据，打开一个文本文件 | 建立一个新的文件 |
| "a"（追加） | 向文本文件尾添加数据 | 出错 |
| "rb"（只读） | 为了输入数据，打开一个二进制文件 | 出错 |
| "wb"（只写） | 为了输出数据，打开一个二进制文件 | 建立一个新的文件 |
| "ab"（追加） | 向一个二进制文件尾添加数据 | 出错 |
| "r+"（读写） | 为了读和写，打开一个文本文件 | 出错 |
| "w+"（读写） | 为了读和写，建议一个新的文件 | 建立一个新的文件 |
| "a+"（读写） | 打开一个文件，在文件尾进行读写 | 建立一个新的文件 |
| "rb+"（读写） | 为了读和写打开一个二进制文件 | 出错 |
| "wb+"（读写） | 为了读和写，新建一个新的二进制文件 | 建立一个新的文件 |
| "ab+"（读写） | 打开一个二进制文件，在文件尾进行读和写 | 建立一个新的文件 |

> 绝对路径写法
> 由于斜杠\\在C语言中是作为转义字符来使用的，因此，必须用 \\\\ ，才能表示一个斜杠字符本身
> fopen("F:\\\\cs\\\\Code\\\\C\\\\C\\\\text.txt", "r");
>
> 相对路径写法
> fopen("text.txt", "r");//当前目录中的文件
>  .. 表示上一级路径
>  .  表示当前路径
> fopen("../test.txt", "r");//上一级路径
> fopen("../../test.txt", "r");//上上一级路径

```c
#include<stdio.h>
int main()
{
	FILE* pf = fopen("text.txt", "r");
	if (!pf)
	{
		perror("fopen");
		//No such file or directory
		return 1;
	}
	fclose(pf);
	pf = NULL;
	return 0;
}
```

**标准文件流**

C语言还有3个特殊的文件流**，即标准输入流（stdin）、标准输出流（stdout）和标准错误输出流（stderr）。**

标准输入流是和键盘相关联的，标准输出流和标准错误输出流是和控制台窗口相关联的。

## 文件的顺序读写

| 功能 | 函数名 | 适用于 | 函数名 | 适用于 |
| --- | --- | --- | --- | --- |
| 字符输入函数 | fgetc | 所有的输入流 | getchar | stdin |
| 字符输出函数 | fputc | 所有的输出流 | putchar | stdout |
| 文本行输入函数 | fgets | 所有的输入流 | gets | stdin |
| 文本行输出函数 | fputs | 所有的输出流 | puts | stdout |
| 格式化输入函数 | fscanf | 所有的输入流 | scanf | stdin |
| 格式化输出函数 | fprintf | 所有的输出流 | printf | stdout |
| 二进制输入函数 | fread | 文件 |  |  |
| 二进制输出函数 | fwrite | 文件 |  |  |
| 格式化输入函数 | sscanf | 缓冲区 |  |  |
| 格式化输出函数 | sprintf | 缓冲区 |  |  |

### 字符输入输出函数`fgetc fputc getchar putchar`

- **`fgetc`**

  ```c
  int fgetc ( FILE * stream );
  ```

  返回指定流的内部文件位置指示器当前指向的字符（提升为 int 值）。然后，内部文件位置指示器将前进到下一个字符。
  如果调用时流位于文件末尾，则该函数将返回 `EOF` 并设置流的文件末尾指示器 （`feof`） 。如果发生读取错误，该函数将返回 `EOF` 并设置流的错误指示器 （`ferror`）。

- **`fputs`**

  ```c
  int fputc ( int character, FILE * stream );
  ```

  将字符写入流并推进位置指示器。
  成功后，将返回所写字符。如果发生写入错误，则返回`EOF`并设置错误指示器（`ferror`）。

- **`getchar`**

  ```c
  int getchar ( void );
  ```

  返回标准输入`stdin`中的下一个字符（提升为 int 值）。
  如果调用时流位于文件末尾，则该函数将返回 `EOF` 并设置流的文件末尾指示器 （`feof`） 。如果发生读取错误，该函数将返回 `EOF` 并设置流的错误指示器 （`ferror`）。

- **`putchar`**

  ```c
  int putchar ( int character );
  ```

  将字符写入标准输出 `stdout`。
  成功后，将返回所写字符。如果发生写入错误，则返回`EOF`并设置*错误指示器*（`ferror`）。

```c
#include<stdio.h>
int main()
{
	//fputc
	char buf1[] = "hello world";
	FILE* pf = fopen("test.txt", "w");
	if (!pf)
	{
		perror("fopen");
		return 1;
	}
	char* p1 = buf1;
	while (*p1) {
		fputc(*p1, pf);
		p1++;
	}
	fclose(pf);
	pf = NULL;

	///fgetc
	char buf2[50] = { 0 };
	pf = fopen("test.txt", "r");
	if (!pf)
	{
		perror("fopen");
		return 1;
	}
	char* p2 = buf2;
	while ((*p2 = fgetc(pf)) != EOF)
		p2++;
	*p2 = '\0';
	printf("%s\n", buf2);
	fclose(pf);
	pf = NULL;
	return 0;
}
```

### 文本行输入输出函数`fgets fputs gets puts`

- **`fgets`**

  ```c
  char * fgets(char* str, int num, FILE * stream);
  ```

  从流中读取字符，并将它们作为字符串存储到 str 中，直到读取 **num-1**个字符或**到达换行符或文件未尾**。
  **换行符**使 `fgets` 停止读取，但它被函数视为有效字符，并包含在**复制到 str 的字符串中**。**`‘\0’`字符会自动附加到复制到 str** 的字符之后。
  成功后，该函数返回 str。
  如果在尝试读取字符时遇到文件未尾，则设置 `eof` 指示符(`feof`)。如果在读取任何字符之前发生这种情况，则返回的指针为`NULL`(并且 str 的内容保持不变)。
  如果发生读取错误，则设置错误指示符(`ferror`)，并返回`NULL`(但 str 指向的内容可能已更改)。

- **`fputs`**

  ```c
  int fputs(const char* str, FILE * stream);
  ```

  将 str 指向的字符串写入流。该函数从指定的地址str开始复制，直到到达`‘\0’`字符。此`‘\0’`字符不会复制到流中。
  成功后，将返回一个非负值。
  出错时，该函数返回 `EOF` 并设置错误指示器(`ferror`)。

- **`gets`**，此函数在 C 或 C++ 中不再可用（从 C11 和 C++ 14 开始）

  ```c
  char * gets ( char * str );
  ```

  从标准输入`stdin`读取字符，并将它们作为字符串存储到 str 中，直到到达换行符或文件末尾。**换行符不会复制到 str 中。`‘\0’`字符会自动附加到复制到 str 的字符之后。**
  成功后，该函数返回 str。
  如果在尝试读取字符时遇到文件未尾，则设置 `eof` 指示符(`feof`)。如果在读取任何字符之前发生这种情况，则返回的指针为`NULL`(并且 str 的内容保持不变)。
  如果发生读取错误，则设置错误指示符(`ferror`)，并返回`NULL`(但 str 指向的内容可能已更改)。

- **`puts`**，此函数在 C 或 C++ 中不再可用（从 C11 和 C++ 14 开始）

  ```c
  int puts ( const char * str );
  ```

  将 str 指向的字符串写入标准输出`stdout`并**附加换行符 **。该函数从指定的地址 (str)开始复制，直到到达`‘\0’` 字符。`‘\0’` 字符不会复制到流中。
  成功后，将返回一个非负值。
  出错时，该函数返回 `EOF` 并设置错误指示器(`ferror`)。

```c
#include<stdio.h>
int main()
{
	//fputs
	FILE* pf = fopen("text.txt", "w");
	if (!pf)
	{
		perror("fopen");
		return 1;
	}
	char str[] = "FUCK YOU NVDIA";
	fputs(str, pf);
	fclose(pf);
	pf = NULL;
	//fgets
	char buf[256] = { 0 };
	pf = fopen("text.txt", "r");
	if (!pf)
	{
		perror("fopen");
		return 1;
	}
	while (fgets(buf, 256, pf))
		puts(buf);
	fclose(pf);
	pf = NULL;
	return 0;
}
```

### 格式化输入输出函数`fscanf fprintf scanf printf sscanf sprintf`

- **`fscanf`**

  ```c
  int fscanf ( FILE * stream, const char * format, ... );
  ```

  从流中读取数据，并根据参数格式将它们存储到其他参数所指向的位置。
  成功后，该函数返回成功填充的参数列表的项数。此计数可能与预期的项目数匹配，也可能由于匹配失败、读取错误或文件末尾的范围而更少（甚至为零）。
  如果在读取时发生读取错误或到达文件末尾，则设置正确的指示器（`feof`或`ferror`）。而且，如果在成功读取任何数据之前发生任何情况，则返回`EOF`。

- **`fprintf`**

  ```c
  int fprintf ( FILE * stream, const char * format, ...);
  ```

  将按格式指向的字符串写入流。
  成功后，将返回写入的字符总数。
  如果发生写入错误，则设置错误指示符（`ferror`） 并返回负数。

- **`scanf`**

  ```c
  int scanf ( const char * format, ... );
  ```

  从 `stdin` 读取数据，并根据参数格式将它们存储到相应的变量。**该函数将读取并忽略在下一个非空格字符之前遇到的任何空格字符（空格字符包括空格、换行符和制表符）**
  **成功后，该函数返回成功填充的参数列表的项数。**此计数可能与预期的项目数匹配，也可能由于匹配失败、读取错误或文件末尾的范围而更少（甚至为零）。
  如果在读取时发生读取错误或到达文件末尾，则设置正确的指示器（`feof`或`ferror`）。而且，如果在成功读取任何数据之前发生任何情况，则返回`EOF`。

- **`printf`**

  ```c
  int printf ( const char * format, ... );
  ```

  将格式指向的字符串写入标准输出 `stdout`。
  成功后，将返回写入的字符总数。如果发生写入错误，则设置错误指示符（`ferror`） 并返回负数。

- **`sscanf`**

  ```c
  int sscanf ( const char * s, const char * format, ...);
  ```

  从str读取数据，并根据参数*格式*将它们存储到附加参数给定的位置，就像使用 `scanf` 一样。
  成功后，该函数返回成功填充的参数列表的项数。此计数可能与预期的项目数匹配，也可能由于匹配失败、读取错误或文件末尾的范围而更少（甚至为零）。如果在成功读取任何数据之前发生输入失败，则返回EOF。

- **`sprintf`**

  ```c
  int sprintf ( char * str, const char * format, ... );
  ```

  将字符串存储在 str 指向的缓冲区。缓冲区的大小应足够大，以包含整个生成的字符串。`‘\0’`字符会自动追加在内容之后。
  成功后，将返回写入的字符总数。此计数不包括自动追加在字符串末尾的`‘\0’`字符。失败时，返回负数。

```c
#include<stdio.h>
typedef struct STU
{
	int num;
	char name[20];
	float score;
}STU;

int main()
{
	//fprintf
	STU stu1[] = { {1,"zhangsan",95.5},{2,"lisi",97.8},{3,"wangwu",60.0} };
	FILE* pf = fopen("test.txt", "w");
	int sz = sizeof(stu1) / sizeof(stu1[0]);
	if (!pf)
	{
		perror("fopen");
		return 1;
	}
	int i = 0;
	for (i = 0; i < sz; i++)
		fprintf(pf, "%-3d %-10s %-3.1f\n", stu1[i].num, stu1[i].name, stu1[i].score);
	fclose(pf);
	pf = NULL;
	//fscanf
	pf = fopen("test.txt", "r");
	if (!pf)
	{
		perror("fopen");
		return 1;
	}
	STU stu2[5] = { 0 };
	i = 0;
	while (fscanf(pf, "%d%s%f", &stu2[i].num, stu2[i].name, &stu2[i].score) != EOF)
	{
		printf("%-3d %-10s %-3.1f\n", stu2[i].num, stu2[i].name, stu2[i].score);
		i++;
	}
	fclose(pf);
	pf = NULL;
	return 0;
}
```

```c
#include<stdio.h>
typedef struct STU
{
	int num;
	char name[20];
	float score;
}STU;
int main()
{
	STU stu1 = { 1,"zhangsan",95.5 };
	char buf[1024];
	int i = sprintf(buf, "%d %s %f\n", stu1.num, stu1.name, stu1.score);
	printf("%s%d\n", buf, i);	//21个字符包括空格和换行
	STU stu2 = { 0 };
	sscanf(buf, "%d%s%f", &(stu2.num), stu2.name, &(stu2.score));
	printf("output : %d %s %f\n", stu2.num, stu2.name, stu2.score);
	return 0;
}
```

### 二进制输入输出函数`fwrite fread`

- **`fread`**

  ```c
  size_t fread(void* ptr, size_t size, size_t count, FILE * stream);
  ```


  从流中读取 count 个元素，每个元素的大小为字节大小，并将它们存储在 ptr 指定的内存块中。流的位置指示器按读取的总字节数前进。
  返回成功读取的元素总数。如果此数字与 count 参数不同，则表示读取时发生读取错误或到达文件未尾。在这两种情况下，都设置了正确的指标，可以分别使用`ferror` 和 `feof` 进行检查。
  如果 size 或 count 为零，则该函数返回零，并且 ptr 指向的流状态和内容保持不变。

- **`fwrite`**

  ```c
  size_t fwrite(const void* ptr, size_t size, size_t count, FILE * stream);
  ```

  从 ptr 指向的内存块读取count个元素接着写入流，每个元素的大小为字节大小。流的位置指示器按写入的总字节数前进。
  返回成功写入的元素总数。如果此数字与 count 参数不同，则写入错误会阻止函数完成。在这种情况下，将为流设置错误指示器(`ferror`)。
  如果 size 或 count 为零，则函数返回零，错误指示器保持不变。

```c
#include<stdio.h>
typedef struct
{
	char name[20];
	short age;
	char sex[6];
}Info;
int main()
{
	//fwrite
	Info a1[] = { {"zhangsan",18,"male"} ,{"lisi",20,"female"},{"wangwu",38,"male"} };
	FILE* pf = fopen("test.dat", "wb");
	int sz = sizeof(a1) / sizeof(a1[0]);
	if (!pf) {
		perror("fopen");
		return 1;
	}
	if (fwrite(a1, sizeof(Info), sz, pf) == sz)
		printf("File wirtten successfully!\n");
	fclose(pf);
	pf = NULL;
	//fread
	Info a2[5] = { 0 };
	pf = fopen("test.dat", "rb");
	if (!pf) {
		perror("fopen");
		return 1;
	}
	if (fread(a2, sizeof(Info), sz, pf) == sz)
	{
		int i = 0;
		for (i = 0; i < sz; i++)
			printf("%s %d %s\n", a2[i].name, a2[i].age, a2[i].sex);

	}
	fclose(pf);
	pf = NULL;
	return 0;
}
```

## 文件的随机读写

- **`fseek`**

```c
int fseek ( FILE * stream, long int offset, int origin );
```

将与流关联的位置指示器设置为新位置。
对于以二进制模式打开的流，新位置是通过向原点指定的参考位置添加偏移量来定义的。对于在文本模式下打开的流，偏移量应为零或上一次调用 `ftell` 返回的值，并且必须SEEK SET源。

如果成功，该函数将返回零。否则，它将返回非零值。如果发生读取或写入错误，则设置*错误指示符* （`ferror`）。

设置的指针的位置是 **起始位置 + 偏移量**， offset 偏移量参数 , 可以为正数 , 也可以为负数。

其中的origin参数就是起始位置 , 有以下三种选择 :

文件头 SEEK_SET 0，当前位置 SEEK_CUR 1，文件尾 SEEK_END 2

```c
#include<stdio.h>
int main()
{
	FILE* pf = fopen("test.txt", "w");
	if (!pf) {
		perror("fopen");
		return 1;
	}
	fputs("This is an apple.", pf);
	fseek(pf, 9, SEEK_SET);
	fputs(" sam", pf);
	fclose(pf);
	pf = NULL;
	return 0;
}
```

- **`ftell`**

```c
long int ftell ( FILE * stream );
```

获取文件的当前指针位置相对于文件首地址的偏移字节数。

成功后，返回位置指标的当前值。

失败时，返回-1L，并将errno设置为特定于系统的正值。

**使用场景 :** 随机方式存取文件时 , 使用 `fseek` 函数来回移动指针 , 不容易确定当前指针位置 , 通过调用 `ftell` 函数确定指针位置 。

```c
#include<stdio.h>
int main()
{
    FILE* pf = fopen("test.txt", "w");
    if (!pf) {
    	perror("fopen");
    	return 1;
    }
    fputs("This is an apple.", pf);
    fseek(pf, 0, SEEK_END);
    long int size = ftell(pf);
    fclose(pf);
    pf = NULL;
    printf("Size of myfile.txt: %ld bytes.\n", size);
    return 0;
}
```

- **`rewind`**

```c
void rewind ( FILE * stream );
```

让文件指针的位置回到文件的起始位置

```c
#include<stdio.h>
int main()
{
	FILE* pf = fopen("test.txt", "w+");
	if (!pf) {
	    perror("fopen");
	    return 1;
	}
	char buffer[27];
	char i = 0;
	for (i = 'A'; i <= 'Z'; i++)
		fputc(i, pf);
	rewind(pf);
	fread(buffer, 1, 26, pf);
	fclose(pf);
	pf = NULL;
	buffer[26] = '\0';
	puts(buffer);
	return 0;
}
```

- **`ferror`**

```c
int ferror ( FILE * stream);
```

用于检测文件读写过程中是否有产生错误。

如果设置了与流关联的错误指示器，则返回非零值。否则，将返回零。

```c
#include <stdio.h>
int main()
{
	FILE* pf = fopen("test.txt", "w+");
	if (!pf) {
		perror("fopen");
		return 1;
	}
	fputc('x', pf);
	if (ferror(pf))
		printf("Error Writing to myfile.txt\n");
	fclose(pf);
	pf = NULL;
	return 0;
}
```

- **`feof`**

```c
int feof ( FILE * stream );
```

在文件读取过程中，不能用`feof`函数的返回值直接用来判断文件的是否结束。而是应用于当文件读取结束的时候，判断是读取失败结束，还是遇到文件尾结束。 

1. 文本文件读取是否结束，判断返回值是否为 `EOF` （ `fgetc` ），或者 `NULL` （ `fgets`）。
2. 二进制文件的读取结束判断，判断返回值是否小于实际要读的个数。
例如：`fread`判断返回值是否小于实际要读的个数。

```c
#include<stdio.h>
int main()
{
    int c; // 注意：int，非char，要求处理EOF
    FILE* fp = fopen("test.txt", "r");
    if (!fp) {
        perror("File opening failed");
        return 1;
    }
    //fgetc 当读取失败的时候或者遇到文件结束的时候，都会返回EOF
    while ((c = fgetc(fp)) != EOF)
    {
        putchar(c);
    }
    //判断是什么原因结束的
    if (ferror(fp))
        puts("I/O error when reading");
    else if (feof(fp))
        puts("End of file reached successfully");
    fclose(fp);
    fp = NULL;
    return 0;
}
```

```c
#include<stdio.h>
#define SIZE 5
int main()
{
    double a[SIZE] = { 1.,2.,3.,4.,5. };
    FILE* fp = fopen("test.bin", "wb"); // 必须用二进制模式
    fwrite(a, sizeof * a, SIZE, fp); // 写 double 的数组
    fclose(fp);
    double b[SIZE];
    fp = fopen("test.bin", "rb");
    size_t ret_code = fread(b, sizeof * b, SIZE, fp); // 读 double 的数组
    if (ret_code == SIZE) {
        puts("Array read successfully, contents: ");
        for (int n = 0; n < SIZE; ++n) printf("%f ", b[n]);
        putchar('\n');
    }
    else { // error handling
        if (feof(fp))
            printf("Error reading test.bin: unexpected end of file\n");
        else if (ferror(fp)) {
            perror("Error reading test.bin");
        }
    }
    fclose(fp);
    fp = NULL;
    return 0;
}
```

- **`fflush`**

```c
int fflush ( FILE * stream );
```

如果给定的流是打开的以供写入(或者如果它是为更新而打开的，并且最后一个 I/O 操作是输出操作)，则其输出缓冲区中的任何未写入数据都将写入文件。如果 流 为`null`指针，则刷新所有此类流。

当文件关闭（`fclose`）时，无论是由于关闭调用还是程序终止，都会自动刷新与其关联的所有缓冲区。
返回零值表示成功。如果发生错误，将返回`EOF`并设置错误指示器（`ferror`）。

```c
#include <stdio.h>
#include <windows.h>
int main()
{
    FILE* pf = fopen("test.txt", "w");
    fputs("abcdef", pf);//先将代码放在输出缓冲区
    printf("睡眠10秒-已经写数据了，打开test.txt文件，发现文件没有内容\n");
    Sleep(10000);
    printf("刷新缓冲区\n");
    fflush(pf);//刷新缓冲区时，才将输出缓冲区的数据写到文件（磁盘）
    //注：fflush 在高版本的VS上不能使用了
    printf("再睡眠10秒-此时，再次打开test.txt文件，文件有内容了\n");
    Sleep(10000);
    fclose(pf);
    //注：fclose在关闭文件的时候，也会刷新缓冲区
    pf = NULL;
    return 0;
}
```

# 程序的编译和链接

## 详解编译+链接

**程序编译的四个阶段**：**预处理（Preprocessing）、编译（Compilation）、汇编（Assembly）、链接（Linking）**。执行这四个阶段的程序（**预处理器、编译器、汇编器、和链接器**）一起构成了编译系统。

![img](https://cdn.jsdelivr.net/gh/SYLV14/PicGo_Save/typora_images/202406112239401.png)

- 预处理
  1. 预处理器（cpp）将所有的**`#define`**删除，并且展开所有的宏定义。
  2. 处理所有的**条件预编译**指令，比如`#if`、`#ifdef`、`#elif`、`#else`、`#endif`等。
  3. 处理**`#include`**预编译指令，将被包含的文件直接插入到预编译指令的位置。
  4. 删除所有的**注释**。
  5. 添加**行号和文件标识**，以便编译时产生调试用的行号及编译错误警告行号。
  6. 保留所有的**`#pragma`**编译器指令，因为编译器需要使用它们。
- 编译
  编译过程可分为6步：**扫描（词法分析）、语法分析、语义分析、源代码优化、代码生成、目标代码优化**。
- 汇编
  汇编器（as）将`hello.s`翻译成机器语言指令，把这些指令打包成一种叫做**可重定位目标程序**的格式，并将结果保存在目标文件`hello.o`中，`hello.o`是一个二进制文件。
- 链接
  hello程序调用了`printf`函数，它存在于一个名为`printf.o`的单独的预编译好了的目标文件中，而这个文件必须以某种方式合并到我们的hello.o程序中。连接器（ld）就负责处理这种合并。结果就得到了hello文件，它是一个**可执行目标文件**（或者称为**可执行文件**），可以被加载到内存中，由系统执行。（链接程序运行需要的一大堆目标文件，以及所依赖的其它库文件，最后生成可执行文件）。

## 预处理详解

### 预定义符号

```c
__FILE__    //进行编译的源文件 
__LINE__    //文件当前的行号 
__DATE__    //文件被编译的日期 
__TIME__    //文件被编译的时间 
__STDC__    //如果编译器遵循ANSI C，其值为1，否则未定义
```

这些预定义符号都是语言内置的。

```c
#include<stdio.h>
int main()
{
	printf("name: %s\ndate: %s\ntime: %s\nline: %d\n", __FILE__, __DATE__, __TIME__, __LINE__);
	return 0;
}
//name: F:\cs\Code\C\C\16.c
//date : Apr 27 2024
//time : 19 : 09 : 18
//line : 4
```

### `#define`

- `#define` 定义标识符

```c
语法格式：
#define name stuff
举个栗子：
#define MAX 1000
#define reg register          //为 register这个关键字，创建一个简短的名字
#define do_forever for(;;)     //用更形象的符号来替换一种实现
#define CASE break;case        //在写case语句的时候自动把 break写上。
// 如果定义的 stuff过长，可以分成几行写，除了最后一行外，每行的后面都加一个反斜杠(续行符)。
#define DEBUG_PRINT printf("file:%s\nline:%d\ndate:%s\ntime:%s\n" ,\
							__FILE__,__LINE__ ,\
							__DATE__,__TIME__ ) 
#include<stdio.h>
int main()
{
	int input = MAX;
	scanf("%d", &input);
	switch (input)
	{
		case 1:
			printf("1\n");
		CASE 2:
			printf("2\n");
		CASE 3:
			printf("3\n");
	default:
		break;
	}
	DEBUG_PRINT;
	return 0;
}
```

提问：在define定义标识符的时候，要不要在最后加上 `;` ?

```c
#define MAX 100;
int main()
{
	int max = 0;
	int input = 1;
	if (input)
		max = MAX;
	else//报错没有匹配的if,因为if(input) max=1000;;	,第二个分号将if与else隔绝。
		max = 0;
	return 0;
}
```

- **`#define` 定义宏**

```c
声明方式：
#define name( parament-list ) stuff
其中的 parament-list 是一个由逗号隔开的符号表，它们可能出现在stuff中。
参数列表的左括号必须与name紧邻。 如果两者之间有任何空白存在，参数列表就会被解释为stuff的一部分。
```

```c
#include<stdio.h>
#define SQUARE1(X) X+X
#define SQUARE2(X) (X)+(X)
#define SQUARE3(X) ((X)+(X))
int main()
{
	printf("%d\n", 6 * SQUARE1(5 + 1));	//6*5+1+5+1=37
	printf("%d\n", 6 * SQUARE2(5 + 1));	//6*(5+1)+(5+1)=42
	printf("%d\n", 6 * SQUARE3(5 + 1));	//6*((5+1)+(5+1))=72
	return 0;
}
```

> 提示：用于对数值表达式进行求值的宏定义都应该用这种方式加上括号，避免在使用宏时由于参数中 的操作符或邻近操作符之间不可预料的相互作用。

- `#define` 替换规则

在程序中扩展`#define`定义符号和宏时，需要涉及几个步骤：

1. 在调用宏时，首先对参数进行检查，看看是否包含任何由`#define`定义的符号。如果是，它们首先被替换。 
2. 替换文本随后被插入到程序中原来文本的位置。对于宏，参数名被他们的值替换。
3. 最后，再次对结果文件进行扫描，看看它是否包含任何由`#define`定义的符号。如果是，就重复上 述处理过程。 

注意： 

1. 宏参数和`#define` 定义中可以出现其他`#define`定义的变量。但是对于宏，不能出现递归。 
2. 当预处理器搜索`#define`定义的符号的时候，字符串常量的内容并不被搜索。

```c
#define MAX 10
#define MUL(X) ((X)*(X))
int main()
{
	int ret = 3 * MUL(MAX);//3*10*10=300
	printf("MAX = %d", MAX);//""中字符串的MAX不被替换
	return 0;
}
```

- #和`##`

```c
//字符串有自动连接的特点
#include<stdio.h>
int main()
{
	printf("hello bit\n");			//hello bit
	printf("hello" " bit\n");		//hello bit
	printf("hel"  "lo" " bit\n");	//hello bit
	return 0;
}
```

```c
#include<stdio.h>
#define PRINT(FORMAT, VALUE) printf("the value is "FORMAT"\n", VALUE)
int main()
{
	PRINT("%d", 10);
	//printf("the value is ""%d""\n",VALUE);
	//这里只有当字符串作为宏参数的时候才可以把字符串放在字符串中。
	return 0;
}
```

使用 `#` ，把一个宏参数变成对应的字符串：

```c
#include<stdio.h>
#define PRINT(FORMAT, VALUE) printf("the value of "#VALUE" is "FORMAT "\n", VALUE)
int main()
{
	int i = 10;
	PRINT("%d", i + 3);
	//the value of i + 3 is 13
    //代码中的 #VALUE 会预处理器处理为："VALUE"
	return 0;
}
```

使用`##`可以把位于它两边的符号合成一个符号。 它允许宏定义从分离的文本片段创建标识符：

```c
#include<stdio.h>
#define ADD_TO_SUM(num, value) sum##num += value
int main()
{
	int sum5 = 3;
	ADD_TO_SUM(5, 10);//给sum5加10
	printf("%d\n", sum5);
	return 0;
}
```

这样的连接必须产生一个合法的标识符。否则其结果就是未定义的。

- 带副作用的宏参数

```c
#include<stdio.h>
#define MAX(a, b) ( (a) > (b) ? (a) : (b) )
int main()
{
	int x = 5;
	int y = 8;
	int z = MAX(x++, y++);
	//((x++)>(y++)?(x++):(y++))
	//先判断x>y,不成立，然后x y自增成6 9，然后y(9)赋值给z，然后y自增成10
	printf("x=%d y=%d z=%d\n", x, y, z);
	return 0;
}
```

- 宏和函数的对比

宏相较于函数的优势： 

1. 用于调用函数和从函数返回的代码可能比实际执行这个小型计算工作所需要的时间更多。所以**宏比函数在程序 的规模和速度方面更胜一筹**。 
2. 更为重要的是函数的参数必须声明为特定的类型。所以函数只能在类型合适的表达式上使用。反之这个宏怎可 以适用于整形、长整型、浮点型等可以用于>来比较的类型。**宏是类型无关的**。 

当然和宏相比函数也有劣势的地方：

1. 每次使用宏的时候，一份宏定义的代码将插入到程序中。除非宏比较短，否则可能大幅度增加程序的长度。 
2. 宏是没法调试的。 
3. 宏由于类型无关，也就不够严谨。 
4. 宏可能会带来运算符优先级的问题，导致程容易出现错。

> **命名约定：**把宏名全部大写，函数名不要全部大写。

### `#undef`

```c
#define MAX 100
#undef MAX
int main()
{
	int max = MAX;	//error："MAX"未申明的标识符
	return 0;
}
```

### 命令行定义

许多C 的编译器提供了一种能力，允许在命令行中定义符号。用于启动编译过程。

```c
#include<stdio.h>
int main()
{
    int array[ARRAY_SIZE];
    int i = 0;
    for (i = 0; i < ARRAY_SIZE; i++)
    {
        array[i] = i;
    }
    for (i = 0; i < ARRAY_SIZE; i++)
    {
        printf("%d ", array[i]);
    }
    printf("\n");
    return 0;
}
编译指令：
gcc - D ARRAY_SIZE = 10 programe.c	//在Linux系统中可演示，是处于预编译阶段的操作
```

### 条件编译

在编译一个程序的时候我们如果要将一条语句（一组语句）编译或者放弃是很方便的。因为我们有条件编译指令。

比如：调试性的代码，删除可惜，保留又碍事，所以我们可以选择性的编译。

```c
#include<stdio.h>
int main()
{
	int i = 0;
	int arr[10] = { 0 };
	for (i = 0; i < 10; i++)
	{
		arr[i] = i;
#ifdef __DEBUG__
		printf("%d\n", arr[i]);//为了观察数组是否赋值成功。 
#endif //__DEBUG__
	}
	return 0;
}
```

常见的条件编译指令：

```c
1.
#if 常量表达式
//...
#endif
//常量表达式由预处理器求值。
如：
#define __DEBUG__ 1
#if __DEBUG__
//..
#endif

2.多个分支的条件编译
#if 常量表达式
//...
#elif 常量表达式
//...
#else
//...
#endif
例子：
int main()
{
#if 1==1
	printf("hello world\n");
#elif 1==2
	printf("haha\n")
#endif
		return 0;
}

3.判断是否被定义
#if defined(symbol)
#ifdef symbol
#if !defined(symbol)
#ifndef symbol

4.嵌套指令
#if defined(OS_UNIX)
    #ifdef OPTION1
    	unix_version_option1();	
    #endif
    #ifdef OPTION2
    	unix_version_option2();
    #endif
#elif defined(OS_MSDOS)
    #ifdef OPTION2
    	msdos_version_option2();
    #endif
#endif
```

### 文件包含

- 本地文件包含：

```c
#include “filename.h”
```

查找策略：先在**源文件**所在目录下查找，如果该头文件未找到，编译器就像查找**库函数**头文件一样在标准位置查找头文件。 如果找不到就提示编译错误。

- 库文件包含：

```c
#include <filename.h>
```

查找头文件直接去标准路径下去查找，如果找不到就提示编译错误。

库文件也可以使用`“filename.h”`形式包含，但是这样做查找的效率就低些，当然这样也不容易区分是库文件还是本地文件了。

- 嵌套文件包含

<img src="https://cdn.jsdelivr.net/gh/SYLV14/PicGo_Save/typora_images/202406112239402.png" alt="image-20240427203247667" style="zoom:50%;" />

test.h和test.c使用了test1模块和test2模块。这样最终程序中就会出现两份comm.h的内容。这样就造成了文件内容的重复。

使用条件编译解决此类问题，每个头文件的开头写：

```c
#ifndef __TEST_H__
#define __TEST_H__
//头文件的内容
#endif   //__TEST_H__
或者：
#pragma once
```

### 其他预处理指令

```c
#error
#pragma
#line
……
#pragma pack()在结构体部分介绍。
```

## 作业

结构体偏移量`offsetof`宏的实现

```c
#include<stdio.h>
#define OFFSETOF(type,member) (int)&(((type*)0)->member)
struct S
{
    char a;
    int b;
    char c;
};
int main()
{
    printf("%d\n", OFFSETOF(struct S, a));
    printf("%d\n", OFFSETOF(struct S, b));
    printf("%d\n", OFFSETOF(struct S, c));
    return 0;
}
```

写一个宏，可以将一个整数的二进制位的奇数位和偶数位交换。

```c
#include<stdio.h>
#define SWAP(X) (((X&0x55555555)<<1)+((X&0xaaaaaaaa)>>1))
int main() {
	int a = 10;
	int b = SWAP(a);
	printf("%d\n", b);
	return 0;
}
```

