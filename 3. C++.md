# C++入门

## C++关键字

<img src="F:/cs/note/images/image-20240522195341552.png" alt="image-20240522195341552" style="zoom:50%;" />

## 命名空间

在C/C++中，变量、函数和后面要学到的类都是大量存在的，这些变量、函数和类的名称将都存在于全局作用域中，可能会导致很多冲突。使用命名空间的目的是**对标识符的名称进行本地化， 以避免命名冲突或名字污染**，namespace关键字的出现就是针对这种问题的。

```c
#include <stdio.h>
#include <stdlib.h>
int rand = 10;
//stdlib.h中存在rand()函数
// C语言没办法解决类似这样的命名冲突问题，所以C++提出了namespace来解决
int main()
{
	printf("%d\n", rand);
	return 0;
}
// 编译后后报错：error C2365: “rand”: 重定义；以前的定义是“函数”
```

### 命名空间定义

```c
//1.正常的命名空间定义
namespace bit	//bit为命名空间的名字
{
	// 命名空间中可以定义变量/函数/类型
	int rand = 10;
	int Add(int left, int right)
	{
		return left + right;
	}
	struct Node
	{
		struct Node* next;
		int val;
	};
}

//2.命名空间可以嵌套
// test.cpp
namespace N1
{
	int a;
	int b;
	int Add(int left, int right)
	{
		return left + right;
	}
	namespace N2
	{
		int c;
		int d;
		int Sub(int left, int right)
		{
			return left - right;
		}
	}
}

//3.同一个工程中允许存在多个相同名称的命名空间，编译器最后会合成同一个命名空间中。
// ps：一个工程中的test.h和上面test.cpp中两个N1会被合并成一个
// test.h
namespace N1
{
	int Mul(int left, int right)
	{
		return left * right;
	}
}
```

> 注意：**一个命名空间就定义了一个新的作用域**，命名空间中的所有内容都局限于该命名空间中

### 命名空间使用

访问不同作用域中的重名变量的优先级：局部变量 -> 全局变量 -> 命名空间

```c
//局部变量 -> 全局变量 -> 命名空间
#include<iostream>
using std::endl;
using std::cout;
namespace zt {
	int a = 3;
}
int a = 2;
int main() {
	int a = 1;
	cout << a << endl;		//1 //访问局部变量a
	cout << ::a << endl;	//2 //访问全局变量a
	cout << zt::a << endl;	//3 //指定访问命名空间中的a
	//命名空间中的变量需要展开或者指定访问，否则也不会使用
	return 0;
}
```

命名空间的使用有三种方式：

1. **加命名空间名称及作用域限定符**

   ```c
   int main()
   {
       printf("%d\n", N::a);
       return 0;    
   }
   ```

2. **使用using将命名空间中某个成员引入**

   ```c
   using N::b;
   int main()
   {
       printf("%d\n", N::a);
       printf("%d\n", b);
       return 0;    
   }
   ```

3. **使用using namespace 命名空间名称，引入命名空间中的全部变量/函数/类型**

   ```c
   using namespce N;
   int main()
   {
       printf("%d\n", N::a);
       printf("%d\n", b);
       Add(10, 20);
       return 0;    
   }
   ```

## C++输入&输出

1. 使用**`cout`标准输出对象(控制台)**和**`cin`标准输入对象(键盘)**时，必须包含`<iostream>`头文件以及按命名空间使用方法使用std。
2. `cout`和`cin`是全局的流对象，`endl`是特殊的C++符号，表示换行输出，他们都包含在包含`<iostream>`头文件中。
3. **<<是流插入运算符，>>是流提取运算符**。
4. 使用C++输入输出更方便，不需要像`printf/scanf`输入输出时那样，需要手动控制格式。 **C++的输入输出可以自动识别变量类型**。
5. 实际上`cout`和`cin`分别是`ostream`和`istream`类型的对象，`>>`和`<<`也涉及运算符重载等知识，这里只是简单学习他们的使用。

> 注意：早期标准库将所有功能在全局域中实现，声明在.h后缀的头文件中，使用时只需包含对应头文件即可，后来将其实现在std命名空间下，为了和C头文件区分，也为了正确使用命名空间， 规定C++头文件不带.h；旧编译器(vc 6.0)中还支持格式，后续编译器已不支持，因 此推荐使用+std的方式。

```c
#include <iostream>
using namespace std;
int main()
{
    int a;
    double b;
    char c;
    cin >> a;
    cin >> b >> c;
    cout << a << endl;
    cout << b << " " << c << endl;
    return 0;
}
// ps：关于cout和cin还有很多更复杂的用法，比如控制浮点数输出精度，控制整形输出进制格式等。因为C++兼容C语言的用法，这些又用得不是很多，所以建议使用scanf和printf控制格式。
```

> std命名空间的使用惯例： std是C++标准库的命名空间，如何展开std使用更合理呢？ 
>
> 1. 在日常练习中，建议直接using namespace std即可，这样就很方便。 
> 2. `using namespace std;` 展开，标准库就全部暴露出来了，如果我们定义跟库重名的类型/对象/函数，就存在冲突问题。该问题在日常练习中很少出现，但是项目开发中代码较多、规模大，就很容易出现。所以建议在项目开发中使用，像`std::cout`这样使用时指定命名空间 +  `using std::cout;`展开常用的库对象/类型等方式。

## 缺省函数

### 缺省函数概念

缺省参数是**声明或定义函数时为函数的参数指定一个缺省值**。在调用该函数时，如果没有指定实 参则采用该形参的缺省值，否则使用指定的实参。

```c
#include<iostream>
using namespace std;
void Func(int a = 0)
{
	cout << a << endl;
}
int main()
{
	Func();     //0 //没有传参时，使用参数的默认值
	Func(10);   //10 //传参时，使用指定的实参
	return 0;
}
```

### 缺省函数分类

1. **全缺省函数**

   ```c
   #include<iostream>
   using namespace std;
   void Func(int a = 10, int b = 20, int c = 30)
   {
   	cout << a << " ";
   	cout << b << " ";
   	cout << c << endl;
   }
   int main()
   {
   	Func();			//10 20 30
   	Func(1);		//1 20 30
   	Func(1, 2);		//1 2 30
   	Func(1, 2, 3);	//1 2 3
   	return 0;
   }
   ```

2. **半缺省函数**

   ```c
   #include<iostream>
   using namespace std;
   void Func(int a, int b = 20, int c = 30)
   {
   	cout << a << " ";
   	cout << b << " ";
   	cout << c << endl;
   }
   int main()
   {
   	//Func();		//error
   	Func(1);		//1 20 30
   	Func(1, 2);		//1 2 30
   	Func(1, 2, 3);	//1 2 3
   	return 0;
   }
   ```

> 注意：
>
> 1. 半缺省参数必须从右往左依次来给出，不能间隔着给
>
>    ```c
>    void Func1(int a, int b, int c = 30);		// ok
>    void Func2(int a, int b = 20, int c = 30);	// ok
>    void Func3(int a = 10, int b, int c = 30);	// error
>    void Func4(int a = 10, int b, int c);		// error
>    void Func5(int a = 10, int b = 20, int c);	// error
>    void Func6(int a, int b = 20, int c);		// error
>    ```
>
> 2. ，缺省参数不能在函数声明和定义中同时出现，建议声明时写缺省参数，定义时不写
>
>    ```c
>    //a.h
>    void Func(int a = 10);
>    // a.cpp
>    void Func(int a = 20)
>     {}
>    // 注意：如果生命与定义位置同时出现，恰巧两个位置提供的值不同，那编译器就无法确定到底该用那个缺省值。
>    ```
>
> 3. 缺省值必须是常量或者全局变量
>
> 4. C语言不支持（编译器不支持）

## 函数重载

### 函数重载的概念

函数重载：是函数的一种特殊情况，C++允许在**同一作用域**中声明几个功能类似的**同名函数**，这些同名函数的**形参列表(参数个数 或 类型 或 类型顺序)不同**，常用来处理实现功能类似数据类型不同的问题。

```c
#include<iostream>
using namespace std;
// 1. 参数类型不同
int Add(int left, int right)
{
	cout << "int Add(int left, int right)" << endl;
	return left + right;
}
double Add(double left, double right)
{
	cout << "double Add(double left, double right)" << endl;
	return left + right;
}
// 2. 参数个数不同
void f()
{
	cout << "f()" << endl;
}
void f(int a)
{
	cout << "f(int a)" << endl;
}
// 3. 参数类型顺序不同
void f(int a, char b)
{
	cout << "f(int a,char b)" << endl;
}
void f(char a, int b)
{
	cout << "f(char a, int b)" << endl;
}
int main()
{
	Add(10, 20);
	Add(10.1, 20.2);
	f();
	f(10);
	f(10, 'a');
	f('a', 10);
	return 0;
}
```

### C++支持函数重载的原理--名字修饰(name Mangling)

为什么C++支持函数重载，而C语言不支持函数重载呢？

<img src="F:/cs/note/images/image-20240522221037439.png" alt="image-20240522221037439" style="zoom: 50%;" />

编译后链接前，链接器看到Test.o调用Sum，但是没有Sum的地址，就 会到Sum.o的符号表中找Sum的地址，然后链接到一起。

采用C语言编译器编译后，在linux下，采用gcc编译完成后，函数名字的修饰没有发生改变。

采用C++编译器编译后结果在linux下，采用g++编译完成后，函数名字的修饰发生改变，编译器将函数参 数类型信息添加到修改后的名字中。

通过这里就理解了C语言没办法支持重载，因为同名函数没办法区分。而C++是通过函数修 饰规则来区分，只要参数不同，修饰出来的名字就不一样，就支持了重载。

> **如果两个函数函数名和参数是一样的，返回值不同是不构成重载的，因为调用时编译器没办法区分。**

## 引用

### 引用的概念

引用不是新定义一个变量，而是**给已存在变量取了一个别名**，编译器不会为引用变量开辟内存空间，它和它引用的变量**共用同一块内存空间**。

**类型& 引用变量名(对象名) = 引用实体；**

```c
void TestRef()
{
    int a = 10;
    int& ra = a;		//定义引用类型
    printf("%p\n", &a);
    printf("%p\n", &ra);
}
```

> **注意：引用类型必须和引用实体是同种类型的**

### 引用特性

1. 引用**在定义时必须初始化**
2. 一个变量可以有多个引用
3. 引用一旦引用一个实体，**再不能引用其他实体**

```c
void TestRef()
{
	int a = 10;
	//1. 引用在定义时必须初始化
	//int& ra;   // 编译error
	int& ra = a;

	//2. 一个变量可以有多个引用
	int& rra = a;
	int& rrra = rra;
	std::cout << &a << std::endl << &ra << std::endl << &rra << std::endl << &rrra << std::endl;

	//3. 引用一旦引用一个实体，再不能引用其他实体
	int b = 20;
	ra = b;	//这个语句并不是引用b，而是将b的值拷贝给a
	std::cout << a << std::endl << ra << std::endl;

	int* p = &b;
	int*& rp = p;
	std::cout << p << std::endl << rp << std::endl;
}
```

### 使用场景

1. **引用变量做参数**
   引用可以做函数的参数，作用相当于指针，可以改变变量本身。

   ```c
   void Swap(int& left, int& right)
   {
      int temp = left;
      left = right;
      right = temp;
   }
   ```

2. **引用变量做返回值**

   ```c
   //值返回
   int Count() {
   	static int n = 0;;
   	n++;
   	return n;
   }
   //临时变量n存放在内存中的静态区，不会随函数执行结束而销毁
   int Count() {
   	int n = 0;;
   	n++;
   	return n;
   }
   //临时变量n存放在内存中的栈区，会随函数执行结束而销毁
   int main() {
   	int ret = Count();
   	return 0;
   }
   //但是不论栈区还是静态区的变量返回都需要将返回值存放在一个临时变量（寄存器）中，然后拷贝给main函数中的变量
   ```

   有没有办法不通过临时变量返回返回值呢？那就是引用返回

   ```c
   //正确的引用返回
   int& Count() {
   	static int n = 0;;
   	n++;
   	return n;
   }
   //对于引用返回来说就不会产生这个临时变量了，返回的只是n的别名，相当于就是把n返回回去了，
   //对于函数栈帧销毁依旧存在的内容，如果不想让其拷贝到临时变量中进行返回，是可以通过引用来进行返回的，这样就可以减少拷贝，对程序做了一小部分的优化
   int main() {
   	int& ret = Count();
   	return 0;
   }
   ```

   ```c
   //错误的引用返回
   int& Count() {
   	int n = 0;;
   	n++;
   	return n;
   }
   int main() {
   	int& ret = Count();
   	return 0;
   }
   //这里打印ret的值是不确定的，ret就是n的别名，但是Count函数已经销毁
   //如果Count函数结束，栈帧销毁没有清理栈帧，那么ret的结果侥幸是正确的
   //如果Count函数结束，栈帧销毁清理栈帧，那么ret的结果是随机值
   //例如：
   #include<iostream>
   int& Add(int a, int b)
   {
       int c = a + b;
       return c;
   }
   int main()
   {
       int& ret = Add(1, 2);
       Add(3, 4);
       std::cout << "Add(1, 2) is :" << ret << std::endl;
       //Add(1, 2) is :-858993460
       return 0;
   }
   ```

   > 注意：如果函数返回时，出了函数作用域，如果返回对象还在(还没还给系统)，则可以使用引用返回，如果已经还给系统了，则必须使用传值返回

> 总结：
>
> 1. 引用做参数 ，做输出型参数，节省空间
>
> 2. 引用做参数  ，当传过来的形参是大对象/深拷贝对象时，能够极大地提高效率。
>
> 3. 引用做返回值 ，返回值不需要通过临时变量返回，减少拷贝提高效率，尤其是返回大对象/深拷贝类对象
>
> 4. 引用做返回值，可以通过引用返回修改返回值+获取返回值
>
>    ```c
>    #include<iostream>
>    #include<assert.h>
>    struct SeqList { int a[100]; };
>    int SLGet(SeqList* ps, int pos) {
>    	assert(pos < 100 && pos >= 0);
>    	return ps->a[pos];
>    }
>    void SLModify(SeqList* ps, int pos, int x) {
>    	assert(pos < 100 && pos >= 0);
>    	ps->a[pos] = x;
>    }
>    int& SLAt(SeqList* ps, int pos) {
>    	assert(pos < 100 && pos >= 0);
>    	return ps->a[pos];
>    }
>    int main() {
>    	SeqList s;
>                                                                         
>    	SLModify(&s, 0, 1);
>    	int ret = SLGet(&s, 0);
>    	std::cout << ret << std::endl;
>    	SLModify(&s, 0, ret + 5);
>                                                                         
>    	//通过引用返回就能实现读写
>    	SLAt(&s, 0) = 1;
>    	std::cout << SLAt(&s, 0) << std::endl;
>    	SLAt(&s, 0) += 5;
>                                                                         
>    	return 0;
>    }
>    ```

###  传值、传引用效率比较

以值作为参数或者返回值类型，在传参和返回期间，函数不会直接传递实参或者将变量本身直 接返回，而是传递实参或者返回变量的一份临时的拷贝，因此用值作为参数或者返回值类型，效率是非常低下的，尤其是当参数或者返回值类型非常大时，效率就更低。

1. **值和引用的作为函数参数类型的性能比较**

   ```c
   #include<iostream>
   #include <time.h>
   struct A { int a[10000]; };
   void TestFunc1(A a) {}
   void TestFunc2(A& a) {}
   void TestRefAndValue()
   {
   	A a;
   	// 以值作为函数参数
   	size_t begin1 = clock();
   	for (size_t i = 0; i < 10000; ++i)
   		TestFunc1(a);
   	size_t end1 = clock();
   	// 以引用作为函数参数
   	size_t begin2 = clock();
   	for (size_t i = 0; i < 10000; ++i)
   		TestFunc2(a);
   	size_t end2 = clock();
   	// 分别计算两个函数运行结束后的时间
   	std::cout << "TestFunc1(A)-time:" << end1 - begin1 << std::endl;
   	std::cout << "TestFunc2(A&)-time:" << end2 - begin2 << std::endl;
   }
   int main() {
   	TestRefAndValue();
   	return 0;
   }
   //TestFunc1(A)-time:8
   //TestFunc2(A&)-time:0
   ```

2. **值和引用的作为返回值类型的性能比较**

   ```c
   #include<iostream>
   #include <time.h>
   struct A { int a[10000]; };
   A a;
   // 值返回
   A TestFunc1() { return a; }
   // 引用返回
   A& TestFunc2() { return a; }
   void TestReturnByRefOrValue()
   {
   	// 以值作为函数的返回值类型
   	size_t begin1 = clock();
   	for (size_t i = 0; i < 100000; ++i)
   		TestFunc1();
   	size_t end1 = clock();
   	// 以引用作为函数的返回值类型
   	size_t begin2 = clock();
   	for (size_t i = 0; i < 100000; ++i)
   		TestFunc2();
   	size_t end2 = clock();
   	// 计算两个函数运算完成之后的时间
   	std::cout << "TestFunc1 time:" << end1 - begin1 << std::endl;
   	std::cout << "TestFunc2 time:" << end2 - begin2 << std::endl;
   }
   int main() {
   	TestReturnByRefOrValue();
   	return 0;
   }
   //TestFunc1 time : 152
   //TestFunc2 time : 0
   ```

### 常引用

```c
void TestConstRef()
{
    //1. 权限不能放大，只能缩小或平移
    const int a = 10;
    int& ra = a;        // 编译时error，a为常量，不能放大权限变为变量
    const int& ra = a;  // 权限可以平移
    int b = 20;
    const int& rb = b;  // 权限可以缩小

    //2. 可以给常量取别名
    int& c = 10;        // 编译error，c为常量
    const int& c = 10;  // 常量引用需用const

    //3. 只要发生类型转换，都会产生临时变量。而临时变量不可修改，具有常性。
    double d = 12.34;
    int& rd = d;        // 编译error，类型不同
    const int& rd = d;  // 把d的值赋给rd时并不是直接赋值的，会把d的整数部分取出来，赋值给一个int型临时变量，随后再把这个临时变量给给rd
}
```

```c
int func1()
{
	static int x = 0;
	return x;
}
int& func2()
{
	static int x = 0;
	return x;
}
int main()
{
	int& ret1 = func1();		// 权限放大，传值返回返回的是临时变量，临时变量具有常性
	const int& ret1 = func1();	// 权限平移
	int ret1 = func1();			// 拷贝

	int& ret2 = func2();		// 权限平移
	const int& rret2 = func2(); // 权限缩小

	return 0;
}
```

### 引用和指针的区别

在**语法概念**上引用就是一个别名，没有独立空间，和其引用实体共用同一块空间。

在**底层实现**上实际是有空间的，因为**引用是按照指针方式来实现的**。

<img src="F:/cs/note/images/image-20240523151214052.png" alt="image-20240523151214052" style="zoom: 50%;" />

> 引用和指针的不同点：
>
> 1. 引用概念上定义一个变量的别名，指针存储一个变量地址
> 2. 引用在定义时必须初始化，指针没有要求
> 3. 引用在初始化时引用一个实体后，就不能再引用其他实体，而指针可以在任何时候指向任何一个同类型实体
> 4. 没有NULL引用，但有NULL指针
> 5. 在sizeof中含义不同：引用结果为引用类型的大小，但指针始终是地址空间所占字节个数(32位平台下占4个字节)
> 6. 引用自加即引用的实体增加1，指针自加即指针向后偏移一个类型的大小
> 7. 有多级指针，但是没有多级引用
> 8. 访问实体方式不同，指针需要显式解引用，引用编译器自己处理
> 9. 引用比指针使用起来相对更安全

## 内联函数

### 概念

以**inline修饰的函数**叫做内联函数，**编译时C++编译器会在调用内联函数的地方展开**，没有函数调用建立栈帧的开销，内联函数提升程序运行的效率。

```c
int Add(int left, int right) {
	return left + right;
}
int main() {
	int ret = 0;
	ret = Add(2, 0);
	return 0;
}
```

<img src="F:/cs/note/images/image-20240523213101878.png" alt="image-20240523213101878" style="zoom: 50%;" />

如果在上述函数前增加inline关键字将其改成内联函数，在编译期间编译器会用函数体替换函数的调用。 

查看方式： 

1. 在release模式下，查看编译器生成的汇编代码中是否存在call Add
2. 在debug模式下，需要对编译器进行设置，否则不会展开(因为debug模式下，编译器默认不会对代码进行优化，以下给出vs2022的设置方式)

<img src="F:/cs/note/images/image-20240523213246113.png" alt="image-20240523213246113" style="zoom:50%;" />

![image-20240523213308501](F:/cs/note/images/image-20240523213308501.png)

![image-20240523213321316](F:/cs/note/images/image-20240523213321316.png)

```c
inline int Add(int left, int right) {
	return left + right;
}
int main() {
	int ret = 0;
	ret = Add(2, 0);
	return 0;
}
```

<img src="F:/cs/note/images/image-20240523213158884.png" alt="image-20240523213158884" style="zoom:50%;" />

### 特性

1. inline是一种**以空间换时间**的做法，如果编译器将函数当成内联函数处理，**在编译阶段，会用函数体替换函数调用，缺陷：可能会使目标文件变大，优势：少了调用开销，提高程序运行效率。**

2. inline对于编译器而言**只是一个建议**，不同编译器关于inline实现机制可能不同，一般建议：将**函数规模较小**(即函数不是很长，具体没有准确的说法，取决于编译器内部实现)、**不是递归、且频繁调用的函数**采用inline修饰，否则编译器会忽略inline特性。

3. inline**不建议声明和定义分离**，分离会导致链接错误。因为inline被展开，就没有函数地址了，链接就会找不到。

   ```c
   // F.h
   #include <iostream>
   using namespace std;
   inline void f(int i);
   // F.cpp
   #include "F.h"
   void f(int i)
   {
    cout << i << endl;
   }
   // main.cpp
   #include "F.h"
   int main()
   {
    f(10);
    return 0;
   }
   // 链接错误：main.obj : error LNK2019: 无法解析的外部符号 "void __cdecl f(int)" (?f@@YAXH@Z)，该符号在函数 main 中被引用
   ```

   ```c
   //建议在内联函数声明时就定义
   // F.h
   #include <iostream>
   using namespace std;
   inline void f(int i)
   {
    cout << i << endl;
   }
   // main.cpp
   #include "F.h"
   int main()
   {
    f(10);
    return 0;
   }
   ```

> `#define`定义宏与内联函数的比较
>
> 宏的优点： 1.增强代码的复用性。 2.提高性能。 
> 宏的缺点： 1.不方便调试宏。（因为预编译阶段进行了替换） 2.导致代码可读性差，可维护性差，容易误用。 3.没有类型安全的检查 。
>
> 内联函数摒弃了宏的缺点，且简单、不易出错、可被调试、可读性强，但是会增大可执行文件容量。

## `auto`关键字（C++11）

### 简介

**auto声明的变量会在编译阶段根据初始值来推出auto变量的类型。**

```c
#include<iostream>
using namespace std;
int TestAuto()
{
	return 10;
}
int main()
{
	int a = 10;
	auto b = a;
	auto c = 'a';
	auto d = TestAuto();
	auto e; //无法通过编译，使用auto定义变量时必须对其进行初始化

	cout << typeid(b).name() << endl;
	cout << typeid(c).name() << endl;
	cout << typeid(d).name() << endl;
	return 0;
}
```

> 使用auto定义变量时**必须对其进行初始化**，在编译阶段编译器需要根据初始化表达式来推导auto 的实际类型。因此auto并非是一种“类型”的声明，而是**一个类型声明时的“占位符”**，编译器在编译期会将auto替换为变量实际的类型。

### 使用细则

1.  **auto与指针和引用结合起来使用**
   用auto声明指针类型时，用auto和auto*没有任何区别，但用auto声明引用类型时则必须加&

   ```c
   #include<iostream>
   using namespace std;
   int main()
   {
       int x = 10;
       auto a = &x;
       auto* b = &x;
       auto& c = x;
       cout << typeid(a).name() << endl;   //int*
       cout << typeid(b).name() << endl;   //int*
       cout << typeid(c).name() << endl;   //int
       return 0;
   }
   ```

2. **在同一行定义多个变量**
   当在同一行声明多个变量时，这些变量必须是相同的类型，否则编译器将会报错，因为编译器实际只对第一个类型进行推导，然后用推导出来的类型定义其他变量。

   ```c
   void TestAuto()
   {
       auto a = 1, b = 2; 
       auto c = 3, d = 4.0;  // 该行代码会编译失败，因为c和d的初始化表达式类型不同
   }
   ```

3. **auto不能推导的场景**

   1. **auto不能作为函数的参数**

   2. **auto不能直接用来声明数组**

      ```c
      void TestAuto()
      {
          int a[] = {1,2,3};
          auto b[] = {4，5，6};//error
      }
      ```

   3. 为了避免与C++98中的auto发生混淆，C++11只保留了auto作为类型指示符的用法
      在早期C/C++中auto的含义是：使用auto修饰的变量，是具有自动存储器的局部变量，

   4. auto在实际中最常见的优势用法就是跟以后会讲到的C++11提供的新式for循环，还有 lambda表达式等进行配合使用。

## 基于范围的for循环(C++11)

### 范围for的语法

for循环后的括号由冒号“ ：”分为两部分：第一部分是范围内用于迭代的变量，第二部分则表示被迭代的范围。

```c
#include<iostream>
using namespace std;
void TestFor()
{
    int array[] = { 1, 2, 3, 4, 5 };
    for (auto& e : array)
        e *= 2;
    for (auto e : array)
        cout << e << " ";
}
int main() {
    TestFor();
    return 0;
}
```

> 注意：与普通循环类似，可以用continue来结束本次循环，也可以用break来跳出整个循环。

### 范围for的使用条件

1.  for循环迭代的范围必须是确定的
   对于数组而言，就是数组中第一个元素和最后一个元素的范围；对于类而言，应该提供 begin和end的方法，begin和end就是for循环迭代的范围。
   注意：以下代码就有问题，因为for的范围不确定

   ```c
   void TestFor(int array[])
   {
       for (auto e : array)//此处array并不是数组，而是指针
           cout << e << endl;
   }
   ```

2. **迭代的对象要实现++和==的操作。**(关于迭代器这个问题，以后会讲)

##  指针空值nullptr(C++11)

NULL实际是一个宏，在传统的C头文件(stddef.h)中，可以看到如下代码：

```c
#ifndef NULL
#ifdef __cplusplus
#define NULL   0
#else
#define NULL   ((void *)0)
#endif
#endif
```

可以看到，**NULL可能被定义为字面常量0，或者被定义为无类型指针(void*)的常量**。不论采取何种定义，在使用空值的指针时，都不可避免的会遇到一些麻烦，比如：

```c
void f(int)
{
	cout << "f(int)" << endl;
}
void f(int*)
{
	cout << "f(int*)" << endl;
}
int main()
{
	f(0);			//f(int)
	f(NULL);		//f(int)
	f((int*)0);		//f(int*)
    f(nullptr);		//f(int*)
	return 0;
}
```

在C++98中，字面常量0既可以是一个整形数字，也可以是无类型的指针(void*)常量，但是编译器 默认情况下将其看成是一个整形常量，如果要将其按照指针方式来使用，必须对其进行强转(void  *)0。

> **注意：**
>
> 1. **在使用nullptr表示指针空值时，不需要包含头文件，因为nullptr是C++11作为新关键字引入 的。**
> 2. **在C++11中，sizeof(nullptr) 与 sizeof((void*)0)所占的字节数相同。**
> 3. **为了提高代码的健壮性，在后续表示指针空值时建议最好使用nullptr。**

# 类和对象（上）

## 面向过程和面向对象初步认识

**C语言**是**面向过程**的，关注的是过程，分析出求解问题的步骤，通过函数调用逐步解决问题。

**C++**是基于**面向对象**的，关注的是对象，将一件事情拆分成不同的对象，靠对象之间的交互完 成。

> 举个例子：外卖系统
>
> 面向过程的思想就是上架—点餐—派单—送餐—签收。
>
> 面向对象的思想就是顾客、商家和外卖员这几个对象之间交互完成，不需要知道具体细节。

## 类的引入

C语言结构体中只能定义变量，在C++中，结构体内不仅可以定义变量，也可以定义函数。

```c
#include<stdlib.h>
#include<assert.h>
#include<iostream>
typedef int DataType;
struct Stack {
	void Init(int defaultcapacity = 4) {
		arr = (DataType*)malloc(sizeof(DataType) * defaultcapacity);
		if (!arr) {
			perror("malloc fail");
			return;
		}
		top = 0;
		capacity = defaultcapacity;
	}
	void Push(int x) {
		if (top == capacity) {
			DataType* tmp = (DataType*)realloc(arr, sizeof(DataType) * capacity * 2);
			if (!tmp) {
				perror("realloc fail");
				return;
			}
			arr = tmp;
			capacity *= 2;
		}
		arr[top++] = x;
	}
	void Pop() {
		assert(top);
		top--;
	}
	DataType Top() {
		assert(top);
		return arr[top - 1];
	}
	bool Empty() {
		if (top == 0)
			return true;
		else
			return false;
	}
	void Destory() {
		free(arr);
		arr = nullptr;
		top = capacity = 0;
	}
	DataType* arr;
	int top;
	int capacity;
};
int main() {
	Stack s;
	s.Init();
	for (int i = 0; i < 5; i++)
		s.Push(i + 1);
	while (!s.Empty()) {
		std::cout << s.Top() << std::endl;
		s.Pop();
	}
	s.Destory();
	return 0;
}
```

> 上面结构体的定义，**在C++中更喜欢用class来代替**。

## 类的定义

```c
class className
{
	// 类体：由成员函数和成员变量组成
};  // 一定要注意后面的分号
```

**class**为定义类的**关键字**，**ClassName**为**类的名字**，**{}**中为**类的主体**，注意类定义结束时后面**分号不能省略**。

类体中内容称为**类的成员**：类中的**变量**称为**类的属性或成员变量**；类中的**函数**称为**类的方法或者成员函数**。

**类的两种定义方式：**

1. 声明和定义全部放在类体中，需注意：成员函数如果**在类中定义**，**编译器可能会将其当成内联函数处理**。
2. 类声明放在.h文件中，成员函数定义放在.cpp文件中，注意：**成员函数名前需要加类名::**

> **一般情况下，更期望采用第二种方式。**

成员变量命名规则的建议：

```c
class Date
{
public:
    void Init(int year)
    {
        // 这里的year到底是成员变量，还是函数形参？
        year = year;
    }
private:
	int year;
};

//一般建议这样写
class Date
{
public:
	void Init(int year)
	{
		_year = year;
	}
private:
	int _year; // 或者year_或者myear
	int _month;
	int _day;
};
```

## 类的访问限定符及封装

### 访问限定符

类有三种访问限定符：**public**，**protected**，**private**。

**访问限定符说明：**

1. **public修饰的成员在类外可以直接被访问**

2. **protected和private修饰的成员在类外不能直接被访问**（此处protected和private是类似的）

   ```c
   class Student {
   public:
   	void Init(const char* name, const char* sex, int age) {
   		strcpy(_name, name);
   		strcpy(_sex, sex);
   		_age = age;
   	}
   	void Print() {
   		std::cout << _name << " " << _sex << " " << _age << std::endl;
   	}
   private:
   	char _name[20];
   	char _sex[5];
   protected:
   	int _age;
   };
   int main() {
   	Student s;
   	s.Init("张三", "男", 18);
   	s.Print();
   	std::cout << s._name << " " << s._sex << " " << s._age << std::endl;//error
   	//“Student::_name”: 无法访问 private 成员(在“Student”类中声明)
   	//“Student::_sex”: 无法访问 private 成员(在“Student”类中声明)
   	//“Student::_age”: 无法访问 protected 成员(在“Student”类中声明)
   	return 0;
   }
   ```

3. 访问权限**作用域从该访问限定符出现的位置开始直到下一个访问限定符出现时为止**

4. 如果后面没有访问限定符，作用域就到 } 即类结束。

5. **class的默认访问权限为private，struct为public**(因为struct要兼容C)

> **注意：访问限定符只在编译时有用，当数据映射到内存后，没有任何访问限定符上的区别**

### 封装

面向对象的三大特性：**封装**、**继承**、**多态**。

在类和对象阶段，主要是研究类的封装特性，那什么是封装呢？
**封装：将数据和操作数据的方法进行有机结合，隐藏对象的属性和实现细节，仅对外公开接口来和对象进行交互。**

以栈的取栈顶元素为例：
C语言中虽然可以通过Top()函数取得栈顶元素，但如果直接通过top访问栈顶元素，由于不知道top初值是-1还是0，就不知道访问的是栈顶元素还是栈顶元素的上下空间。
C++中，直接将top限定为private，取栈顶函数限定为public，那访问栈顶元素就只能通过取栈顶函数，具体的细节不需要知道。

> **在C++语言中实现封装，可以通过类将数据以及操作数据的方法进行有机结合，通过访问权限来隐藏对象内部实现细节，控制哪些方法可以在类外部直接被使用。**

## 类的作用域

**类定义了一个新的作用域**，类的所有成员都在类的作用域中。在类体外定义成员时，需要使用 ::  作用域操作符指明成员属于哪个类域。

```c
//student.h
class Student{
public:
    void showinfo();
private:
    char name[20];
    char sex[5];
    int age;
};
//student.cpp
#include"student.h"
void Student::showinfo(){
    cout<< name << " " << sex << " " << age << endl;
}
```

## 类的实例化

**用类类型创建对象的过程，称为类的实例化**

1. 类是**对对象进行描述的**，类只是一个模型一样的东西，限定了类有哪些成员，定义出一个类**并没有分配实际的内存空间来存储它**。
2. 一个类可以实例化出多个对象，**实例化出的对象占用实际的物理空间，存储类成员变量**
3. 做个比方。类实例化出对象就像现实中使用建筑设计图建造出房子，类就像是设计图，只设计出需要什么东西，但是并没有实体的建筑存在，同样类也只是一个设计，实例化出的对象才能实际存储数据，占用物理空间

## 类对象模型

类对象的存储方式猜测：

1. 对象中包含类的各个成员
   缺陷：每个对象中成员变量是不同的，但是调用同一份函数，如果按照此种方式存储，当一个类创建多个对象时，每个对象中都会保存一份代码，相同代码保存多次，浪费空间。
2. 代码只保存一份，在对象中保存存放代码的地址
3. 只保存成员变量，成员函数存放在公共的代码段

```c
#include<iostream>
// 类中既有成员变量，又有成员函数
class A1 {
public:
    void f1() {}
private:
    int _a;
};
// 类中仅有成员函数
class A2 {
public:
    void f2() {}
};
// 类中什么都没有---空类
class A3
{};
int main() {
    std::cout << sizeof(A1) << std::endl;   //4
    std::cout << sizeof(A2) << std::endl;   //1
    std::cout << sizeof(A3) << std::endl;   //1
    return 0;
}
```

> **结论：类对象的存储方式是第3中方式。一个类的大小，实际就是该类中”成员变量”之和，当然要注意内存对齐。**
>
> **注意空类的大小，空类比较特殊，编译器给了空类一个字节来唯一标识这个类的对象。**

## this指针

### this指针的引出

```c
#include<iostream>
class Date
{
public:
	void Init(int year, int month, int day)
	{
		_year = year;
		_month = month;
		_day = day;
	}
	void Print()
	{
		std::cout << _year << "-" << _month << "-" << _day << std::endl;
	}
private:
	int _year;     // 年
	int _month;    // 月
	int _day;      // 日
};
int main()
{
	Date d1, d2;
	d1.Init(2022, 1, 11);
	d2.Init(2022, 1, 12);
	d1.Print();
	d2.Print();
	return 0;
}
```

对于上述类，有这样的一个问题： Date类中有 Init 与 Print 两个成员函数，函数体中没有关于不同对象的区分，那当d1调用 Init 函数时，该函数是如何知道应该设置d1对象，而不是设置d2对象呢？
这就涉及到隐含的this指针，this指针是一个隐含的形参。

```c
#include<iostream>
class Date
{
public:
	//编译处理前
	void Init(int year, int month, int day)
	{
		_year = year;
		_month = month;
		_day = day;
	}
	//编译处理后
	void Init(Date* const this，int year, int month, int day)
	{
		this->_year = year;
		this->_month = month;
		this->_day = day;
	}

	//编译处理前
	void Print()
	{
		std::cout << _year << "-" << _month << "-" << _day << std::endl;
	}
	//编译处理后
	void Print(Date* const this)
	{
		std::cout << this->_year << "-" << this->_month << "-" << this->_day << std::endl;
	}
private:
	int _year;     // 年
	int _month;    // 月
	int _day;      // 日
};
int main()
{
	Date d1, d2;
	//编译处理前
	d1.Init(&d1, 2022, 1, 11);
	d2.Init(&d2, 2022, 1, 12);
	//编译处理后
	d1.Init(2022, 1, 11);
	d2.Init(2022, 1, 12);

	//编译处理前
	d1.Print();
	d2.Print();
	//编译处理后
	d1.Print(&d1);
	d2.Print(&d2);
	return 0;
}
```

- **this不能在形参和实参显示传递，但是可以在函数内部显示使用**

```c
#include<iostream>
class Date
{
public:
	void Init(int year, int month, int day)
	{
		_year = year;
		_month = month;
		_day = day;
	}
	void Print()
	{
		std::cout << this << std::endl;
		std::cout << this->_year << "-" << this->_month << "-" << this->_day << std::endl;
	}
private:
	int _year;     // 年
	int _month;    // 月
	int _day;      // 日
};
int main()
{
	Date d1, d2;
	d1.Init(2022, 1, 11);			//000000E75FF6F748
	std::cout << &d1 << std::endl;	//000000E75FF6F748
	d1.Print();						//2022-1-11
	return 0;
}
```

> **C++编译器给每个“非静态的成员函数“增加了一个隐藏的指针参数，让该指针指向当前对象(函数运行时调用该函数的对象)，在函数体中所有“成员变量” 的操作，都是通过该指针去访问。只不过所有的操作对用户是透明的，即用户不需要来传递，编译器自动完成。**

### this指针的特性

1. this指针的类型：**`类类型* const`**，即成员函数中，不能给this指针赋值。
2. 只能在“成员函数”的内部使用。
3. **this指针本质上是“成员函数”的形参**，当对象调用成员函数时，将对象地址作为实参传递给 this形参。所以**对象中不存储this指针**。
4. **this指针是“成员函数”第一个隐含的指针形参，一般情况由编译器通过ecx寄存器自动传递，不需要用户传递**。

> 1. this指针存在哪里？
>    因为this是形参，this指针与其他形参一样存储在函数调用的栈桢里面。
>
> 2. this指针可以为空吗？
>
>    ```c++
>    // 1.下面程序编译运行结果是？ C
>    //A、编译报错 B、运行崩溃 C、正常运行
>    class A
>    {
>    public:
>    	void Print()
>    	{
>    		cout << "Print()" << endl;
>    	}
>    private:
>    	int _a;
>    };
>                                                                   
>    int main()
>    {
>    	A* p = nullptr;
>    	p->Print();
>    	return 0;
>    }
>    ```
>
>    解析：p调用Print，不会发生解引用，因为Print的地址不在对象中。p会作为实参传递给this指针。this指针是空的，但是在Print函数内没有对this指针解引用。
>
>    ```c++
>    // 2.下面程序编译运行结果是？ B
>    //A、编译报错 B、运行崩溃 C、正常运行
>    class A
>    {
>    public:
>        void PrintA()
>        {
>            cout<<_a<<endl;
>        }
>    private:
>        int _a;
>    };
>                                                                   
>    int main()
>    {
>        A* p = nullptr;
>        p->PrintA();
>        return 0;
>    }
>    ```
>
>    解析：p调用Print，不会发生解引用，因为Print的地址不在对象中。p会作为实参传递给this指针。this指针是空的，但是在Print函数内访问\_a，本质是this->\_a。

# 类和对象（中）

## 类的6个默认成员函数

如果一个类中什么成员都没有，简称为空类。 

空类中真的什么都没有吗？并不是，任何类在什么都不写时，编译器会自动生成以下6个默认成员函数。 

默认成员函数：用户没有显式实现，编译器会生成的成员函数称为默认成员函数。

![image-20240526172803257](F:/cs/note/images/image-20240526172803257.png)

## 构造函数

### 概念

对于Date类，可以通过 Init 公有方法给对象设置日期，但如果每次创建对象时都调用该方法设置信息，未免有点麻烦，那能否在对象创建时，就将信息设置进去呢？ 

**构造函数**是一个特殊的成员函数，**名字与类名相同**，创建类类型对象时由**编译器自动调用**，以保证每个数据成员都有一个合适的初始值，并且**在对象整个生命周期内只调用一次**。

### 特性

1. **函数名与类名相同**。
2. **无返回值**。也不需要写void
3.  对象实例化时编译器**自动调用**对应的构造函数。
4. 构造函数**可以重载**。
5. 如果类中没有显式定义构造函数，则C++编译器会自动生成一个**无参的默认构造函数**，一旦用户显式定义编译器将不再生成。

**解析特性1-4：**

> ```c++
> #include<iostream>
> using namespace std;
> class Date{
> public:
> 	Date() {
> 		_year = 1970;
> 		_month = 1;
> 		_day = 1;
> 	}
> 	Date(int year, int month, int day) {
> 		_year = year;
> 		_month = month;
> 		_day = day;
> 	}
> 	void Print() {
> 		cout << _year << "-" << _month << "-" << _day << endl;
> 	}
> private:
> 	int _year;
> 	int _month;
> 	int _day;
> };
> int main() {
> 	Date d1;
> 	d1.Print();//1970-1-1
> 	Date d2(2024, 5, 26);
> 	d2.Print();//2024-5-26
> 	return 0;
> }
> ```

**解析特性5：**

> ```c++
> #include<iostream>
> using namespace std;
> class Date{
> public:
> 	void Print() {
> 		cout << _year << "-" << _month << "-" << _day << endl;
> 	}
> private:
> 	int _year;
> 	int _month;
> 	int _day;
> };
> int main() {
> 	Date d1;
> 	d1.Print();//-858993460--858993460--858993460
> 	return 0;
> }
> ```
>
> 为什么d1对象调用了编译器生成的默认构造函数，但是d1对象\_year/\_month/\_day，依旧是随机值？
> C++把类型分成内置类型(基本类型)和自定义类型。内置类型就是语言提供的数据类型，如：int/char...，自定义类型就是我们使用class/struct/union等自己定义的类型，💡**编译器生成默认的构造函数对内置类型成员变量不处理，对自定类型成员调用的它自己的默认成员函数。**故上述代码中d1的成员变量并未处理。
>
> 默认构造函数：**无参构造函数、全缺省构造函数、我们没写编译器默认生成的构造函数**，都可以认为是默认构造函数，并且**默认构造函数只能有一个**。
> **无参构造函数和全缺省构造函数构成重载，在不调用的情况下可以同时存在，编译也没有错误。但是在实际调用的过程中，会存在歧义。推荐写全缺省的构造函数。**
>
> ```c++
> #include<iostream>
> using namespace std;
> class Date{
> public:
> 	Date() {
> 		_year = 1970;
> 		_month = 1;
> 		_day = 1;
> 	}
> 	Date(int year = 1, int month = 1, int day = 1) {
> 		_year = year;
> 		_month = month;
> 		_day = day;
> 	}
> 	void Print() {
> 		cout << _year << "-" << _month << "-" << _day << endl;
> 	}
> private:
> 	int _year;
> 	int _month;
> 	int _day;
> };
> int main() {
> 	Date d1;	//error，类"Date"包含多个默认构造函数
> 
> 	Date d2();	
> 	d2.Print();	//error，表达式必须具有类类型，但它具有类型Date(*)()
> 	//此处编译器将d2识别为函数指针
> 	return 0;
> }
> ```
>
> **构造函数无参数时，定义对象时`Date d2();`语句有歧义，会跟函数声明有点冲突，编译器不好识别，只能`Date d1;`这样定义对象。**
>
> 注意：C++11 中针对内置类型成员不初始化的缺陷，又打了补丁，即：**内置类型成员变量在类中声明时可以给默认值。**
>
> ```c++
> #include<iostream>
> using namespace std;
> class Time {
> public:
> 	void Print() {
> 		cout << _hour << ":" << _minute << ":" << _second << endl;
> 	}
> private:
> 	int _hour = 8;
> 	int _minute = 0;
> 	int _second = 0;
> };
> class Date{
> public:
> 	void Print() {
> 		cout << _year << "-" << _month << "-" << _day << endl;
> 		_t.Print();
> 	}
> private:
> 	int _year = 1970;
> 	int _month = 1;
> 	int _day = 1;
> 	Time _t;
> };
> int main() {
> 	Date d1;
> 	d1.Print();
> 	//1970-1-1
> 	//8:0:0
> 	return 0;
> }
> ```

## 析构函数

### 概念

通过前面构造函数的学习，我们知道一个对象是怎么来的，那一个对象又是怎么没呢的？ 

**析构函数**：与构造函数功能相反，析构函数不是完成对对象本身的销毁，局部对象销毁工作是由编译器完成的。而**对象在销毁时会自动调用析构函数，完成对象中资源的清理工作。**

### 特性

1. 析构函数名是在**类名前加上字符 ~**。
2. 无参数**无返回值**类型。
3. 一个类只能有一个析构函数。若未显式定义，系统会自动生成**默认的析构函数**。注意：**析构函数不能重载**。
4. 对象生命周期结束时，C++编译系统系统**自动调用**析构函数。
5. 编译器生成的默认析构函数，对内置类型成员不做处理，对自定类型成员调用它的析构函数。
6. 如果类中没有申请资源时，析构函数可以不写，直接使用编译器生成的默认析构函数，比如 Date类；**有资源申请时，一定要写，否则会造成资源泄漏**，比如Stack类。

```c++
#include<iostream>
using namespace std;
class Time {
public:
	void Print() {
		cout << _hour << ":" << _minute << ":" << _second << endl;
	}
	~Time() {
		cout << "~Time()" << endl;
	}
private:
	int _hour = 8;
	int _minute = 0;
	int _second = 0;
};
class Date{
public:
	void Print() {
		cout << _year << "-" << _month << "-" << _day << endl;
		_t.Print();
	}
	~Date() {
		cout << "~Date()" << endl;
	}
private:
	int _year = 1970;
	int _month = 1;
	int _day = 1;
	Time _t;
};
int main() {
	Date d1;
	//~Date()
	//~Time()
	return 0;
}
```

现在我用类实例化出st1和st2两个对象，首先，st1肯定先构造，st2肯定后构造，这点毋庸置疑，那关键是谁先析构呢？

```c++
int main()
{
	Stack st1;
	Stack st2;
}
```

**st2先析构，st1后析构**，这里st1和st2的空间是开辟在栈帧上的，后进先出，st2后压栈，那么它肯定是最先析构的。所以栈里面定义对象，析构顺序和构造顺序是反的。

## 拷贝构造函数

### 概念

那在创建对象时，可否创建一个与已存在对象一某一样的新对象呢？ 

**拷贝构造函数**：**只有单个形参**，该形参是对**本类类型对象的引用(一般常用const修饰)**，**在用已存在的类类型对象创建新对象时由编译器自动调用**。

### 特性

1. 拷贝构造函数是**构造函数的一个重载形式**。
   **拷贝构造函数也是构造函数，默认构造函数只在没有定义任何构造函数的时候系统才会自动生成。**
2. 拷贝构造函数的**参数只有一个**且必须是**类类型对象的引用**，<u>使用传值方式编译器直接报错， 因为会引发无穷递归调用</u>。
3. 若未显式定义，**编译器会生成默认的拷贝构造函数**。 默认的拷贝构造函数对象按内存存储按字节序完成拷贝，这种拷贝叫做**浅拷贝**，或者值拷贝。
4. 拷贝构造函数典型调用场景： **使用已存在对象创建新对象，函数参数类型为类类型对象，函数返回值类型为类类型对象**

**解析特性1：**

> ```c++
> #include<iostream>
> using namespace std;
> class Date {
> public:
> 	Date(int year = 1970, int month = 1, int day = 1) {
> 		_year = year;
> 		_month = month;
> 		_day = day;
> 	}
> 	Date(const Date& d)
> 	{
> 		_year = d._year;
> 		_month = d._month;
> 		_day = d._day;
> 	}
> 	void Print() {
> 		cout << _year << "-" << _month << "-" << _day << endl;
> 	}
> private:
> 	int _year;
> 	int _month;
> 	int _day;
> };
> int main() {
> 	Date d1(2024, 5, 27);
> 	Date d2(d1);
> 	d2.Print();//2024-5-27
> 	return 0;
> }
> ```

**解析特性2：**

> 为什么使用传值方式编译器直接报错，会引发无穷递归调用？
>
> C++规定：内置类型值传递时直接拷贝，自定义类型值传递时必须调用拷贝构造完成拷贝，不想用拷贝构造就需要引用传递
>
> ```c++
> void Func(Date d) {
> 
> }
> int main() {
> 	Date d1(2024, 5, 27);
> 	Func(d1);//Date(const Date& d)
> 	return 0;
> }
> ```
>
> 那如果拷贝构造是值传参，那么就会无限调用拷贝构造。
>
> ![image-20240527211259472](F:/cs/note/images/image-20240527211259472.png)

**解析特性3：**

> **在编译器生成的默认拷贝构造函数中，内置类型是按照字节方式直接拷贝的，而自定义类型是调用其拷贝构造函数完成拷贝的。**
>
> ```c++
> #include<iostream>
> using namespace std;
> class Time {
> public:
> 	Time(int hour = 8, int minute = 0, int second = 0) {
> 		_hour = hour;
> 		_minute = minute;
> 		_second = second;
> 	}
> 	void Print() {
> 		cout << _hour << ":" << _minute << ":" << _second << endl;
> 	}
> private:
> 	int _hour;
> 	int _minute;
> 	int _second;
> };
> class Date {
> public:
> 	Date(int year = 1970, int month = 1, int day = 1, int hour = 8, int minute = 0, int second = 0) :_t(hour, minute, second)
> 	{
> 		_year = year;
> 		_month = month;
> 		_day = day;
> 	}
> 	void Print() {
> 		cout << _year << "-" << _month << "-" << _day << endl;
> 		_t.Print();
> 	}
> private:
> 	int _year;
> 	int _month;
> 	int _day;
> 	Time _t;
> };
> int main() {
> 	Date d1(2024, 5, 27, 1, 1, 1);
> 	Date d2(d1);
> 	d2.Print();
> 	//2024-5-27
> 	//1:1:1
> 	return 0;
> }
> ```
>
> 编译器生成的默认拷贝构造函数已经可以完成字节序的值拷贝了，还需要自己显式实现吗？
>
> ```c++
> // 这里会发现下面的程序会崩溃掉？这里就需要我们以后讲的深拷贝去解决。
> #include<iostream>
> #include<stdlib.h>
> typedef int DataType;
> class Stack
> {
> public:
> 	Stack(size_t capacity = 10)
> 	{
> 		_array = (DataType*)malloc(capacity * sizeof(DataType));
> 		if (nullptr == _array)
> 		{
> 			perror("malloc申请空间失败");
> 			return;
> 		}
> 		_size = 0;
> 		_capacity = capacity;
> 	}
> 	void Push(const DataType& data)
> 	{
> 		// CheckCapacity();
> 		_array[_size] = data;
> 		_size++;
> 	}
> 	~Stack()
> 	{
> 		if (_array)
> 		{
> 			free(_array);
> 			_array = nullptr;
> 			_capacity = 0;
> 			_size = 0;
> 		}
> 	}
> private:
> 	DataType* _array;
> 	size_t _size;
> 	size_t _capacity;
> };
> int main()
> {
> 	Stack s1;
> 	s1.Push(1);
> 	s1.Push(2);
> 	s1.Push(3);
> 	s1.Push(4);
> 	Stack s2(s1);
> 	return 0;
> }
> ```
>
> ![image-20240527214536132](F:/cs/note/images/image-20240527214536132.png)
>
> 这段程序有两个问题：
>
> 1. 关于拷贝的问题，默认拷贝构造函数是浅拷贝，将s1中的内容原原本本地拷贝给s2，因此s1和s2指向同一个内存空间。
> 2. 当程序退出时，s2和s1要销毁。s2先销毁，s2销毁时调用析构函数，已经将0x00d50c08的空间释放了，但是s1并不知道，到s1销毁时，会将0x00d50c08的空间再释放一次，一块内存空间多次释放，肯定会造成程序崩溃。
>
> **注意：类中如果没有涉及资源申请时，拷贝构造函数是否写都可以；一旦涉及到资源申请 时，则拷贝构造函数是一定要写的，否则就是浅拷贝。**

**解析特性4：**

> ```c++
> #include<iostream>
> using namespace std;
> class Date
> {
> public:
> 	Date(int year = 1, int month = 1, int day = 1) {
> 		cout << "Construct " << this << endl;
> 		_year = year;
> 		_month = month;
> 		_day = day;
> 
> 	}
> 	Date(const Date& d) {
> 		cout << "Copy Construct " << this << endl;
> 		_year = d._year;
> 		_month = d._month;
> 		_day = d._day;
> 	}
> 	~Date() {
> 		cout << "Destruct " << this << endl;
> 	}
> 	void Print() {
> 		cout << _year << "-" << _month << "-" << _day << endl;
> 	}
> private:
> 	int _year;
> 	int _month;
> 	int _day;
> };
> Date Test(Date d) {
> 	Date temp(d);
> 	return temp;
> }
> int main()
> {
> 	Date d1(2024, 5, 27);
> 	Test(d1);
> 	return 0;
> }
> //Construct 0073FC90			//构造d1
> //Copy Construct 0073FB80		//拷贝实参d1给形参d
> //Copy Construct 0073FB54		//拷贝创建temp
> //Copy Construct 0073FBB0		//拷贝创建临时变量用来返回
> //Destruct 0073FB54				//析构temp
> //Destruct 0073FB80				//析构形参d
> //Destruct 0073FBB0				//析构临时变量
> //Destruct 0073FC90				//析构d1
> //VS2022测试时会自动优化掉拷贝创建临时变量，直接返回temp
> ```
>
> 为了提高程序效率，一般对象传参时，尽量使用引用类型，返回时根据实际场景，能用引用尽量使用引用。

## 赋值运算符重载

### 运算符重载

C++为了增强代码的可读性引入了运算符重载，运算符重载是具有特殊函数名的函数，也具有其返回值类型，函数名字以及参数列表，其返回值类型与参数列表与普通的函数类似。 

函数名字为：关键字**operator后面接需要重载的运算符符号**。 

函数原型：**返回值类型 operator操作符(参数列表)** 

注意： 

1. 不能通过连接其他符号来创建新的操作符：比如operator@
2. 重载操作符必须有一个类类型参数
3. 用于内置类型的运算符，其含义不能改变，例如：内置的整型+，不 能改变其含义
4. 作为类成员函数重载时，其形参看起来比操作数数目少1，因为成员函数的第一个参数为隐藏的this
5. `.*   ::   sizeof   ?:   .` 注意以上5个运算符不能重载。这个经常在笔试选择题中出现。 

```c++
#include<iostream>
using namespace std;
class Date
{
public:
	Date(int year = 1970, int month = 1, int day = 1) {
		_year = year;
		_month = month;
		_day = day;
	}
	bool operator==(const Date& d2) {
		return _year == d2._year
			&& _month == d2._month
			&& _day == d2._day;
	}
private:
	int _year;
	int _month;
	int _day;
};
int main()
{
	Date d1(2024, 5, 28);
	Date d2(d1);
	if (d1 == d2)	//等价于 d1.operator==(d2)
		cout << "yes" << endl;
	else
		cout << "no" << endl;
	return 0;
}
```

### 赋值运算符重载

1. 赋值运算符重载格式
   **参数类型**：**const T&**，传递引用可以提高传参效率
   **返回值类型**：**T&**，返回引用可以提高返回的效率，有返回值目的是为了支持连续赋值
   **检测是否自己给自己赋值**
   **返回*this** ：要复合连续赋值的含义
2. . **赋值运算符只能重载成类的成员函数不能重载成全局函数**
   原因：赋值运算符如果不显式实现，编译器会生成一个默认的。此时用户再在类外自己实现 一个全局的赋值运算符重载，就和编译器在类中生成的默认赋值运算符重载冲突了，故赋值 运算符重载只能是类的成员函数。
3. **用户没有显式实现时，编译器会生成一个默认赋值运算符重载，以值的方式逐字节拷贝。**注意：内置类型成员变量是直接赋值的，而自定义类型成员变量需要调用对应类的赋值运算符重载完成赋值。

```c++
#include<iostream>
using namespace std;
class Date
{
public:
	Date(int year = 1970, int month = 1, int day = 1) {
		_year = year;
		_month = month;
		_day = day;
	}
	Date(const Date& d)
	{
		_year = d._year;
		_month = d._month;
		_day = d._day;
	}
	bool operator==(const Date& d2) {
		return _year == d2._year
			&& _month == d2._month
			&& _day == d2._day;
	}
	Date& operator=(const Date & d2){
		if (this == &d2)	//不建议写成*this == d2，因为可能没有==运算符重载
			return *this;
		_year = d2._year;
		_month = d2._month;
		_day = d2._day;
		return *this;
	}
private:
	int _year;
	int _month;
	int _day;
};
int main()
{
	Date d1(2024, 5, 28);
	Date d2;
	Date d3 = d1;
	d2 = d1;
	return 0;
}
```

上述代码中`Date d3 = d1;` 是拷贝构造，`d2 = d1;` 是赋值运算符重载：
拷贝构造是用已有的对象去初始化另一个对象，赋值运算符重载是已经存在的两个对象之间复制拷贝。`Date d3 = d1;`等价于`Date d3(d1);`。

### 前置++和后置++**重载**

```c++
// 前置++：返回+1之后的结果
// this指向的对象函数结束后不会销毁，故以引用方式返回提高效率
Date& Date::operator++()
{
	*this += 1;
	return *this;
}

// 后置++：返回+1之前的结果
// C++规定：后置++重载时多增加一个int类型的参数，但调用函数时该参数不用传递，编译器自动传递
// 后置++是先使用后+1，因此需要返回+1之前的旧值，故需在实现时需要先将this保存一份，然后给this+1，而temp是临时对象，因此只能以值的方式返回，不能返回引用
Date Date::operator++(int)
{
	Date tmp = *this;
	*this += 1;
	return tmp;
}
```

## const成员函数

**将const修饰的“成员函数”称之为const成员函数**，const修饰类成员函数，**实际修饰该成员函数隐含的this指针**，表明在该成员函数中**不能对类的任何成员进行修改**。

```c++
#include<iostream>
using namespace std;
class Date
{
public:
	Date(int year, int month, int day)
	{
		_year = year;
		_month = month;
		_day = day;
	}
	void Print()		//编译器处理后为void Print(Date* const this)
	{
		cout << "Print()" << endl;
		cout << _year  <<"-" << _month << "-" << _day << endl;
	}
	void Print() const	//编译器处理后为void Print(const Date* const this)
	{
		cout << "Print()const" << endl;
		cout << _year << "-" << _month << "-" << _day << endl;
	}
private:
	int _year; // 年
	int _month; // 月
	int _day; // 日
};
void Test()
{
	Date d1(2022, 1, 13);
	d1.Print(); 
	// Print()
	// 2022-1-13
	const Date d2(2022, 1, 13);
	d2.Print();
	// Print()const
	// 2022-1-13
}
```

请思考下面的几个问题：

1. const对象可以调用非const成员函数吗？
   不可以，权限放大
2. 非const对象可以调用const成员函数吗？
   可以，权限缩小
3. const成员函数内可以调用其它的非const成员函数吗？
    不可以，**const成员函数内部只能调用const成员函数**。因为const成员函数内部的this指针已经具有常属性的，万一这个非const成员函数去修改了成员变量的内容就会出问题了
4.  非const成员函数内可以调用其它的const成员函数吗？
   可以，权限缩小

```c++
class Date
{
public:
	Date(int year = 1970, int month = 1, int day = 1)
	{
		_year = year;
		_month = month;
		_day = day;
	}
	void Print1()
	{
		cout << _year << "-" << _month << "-" << _day << endl;
	}
	void Print2() const
	{
		cout << _year << "-" << _month << "-" << _day << endl;
	}
	void Func1() 
	{
		Print2();	//普通成员函数调用const成员函数		//ok，权限缩小
	}
	void Func2() const
	{
		Print1();	//const成员函数调用普通成员函数		//error，权限放大
	}
private:
	int _year; // 年
	int _month; // 月
	int _day; // 日
};
void Test()
{
	Date d1(2024, 5, 28);
	d1.Print1();	//普通成员变量调用普通成员函数		//ok，权限平移
	d1.Print2();	//普通成员变量调用const成员函数		//ok，权限缩小
	const Date d2(2024, 5, 29);
	d2.Print1();	//const成员变量调用普通成员函数		//error，权限放大
	d2.Print2();	//const成员变量调用const成员函数	//ok，权限平移
}
int main() {
	Test();
	return 0;
}
```

> 结论：只要成员函数内部不修改成员变量，都应该加const，这样const对象和普通对象都可以调用

## 取地址及const取地址操作符重载

这两个默认成员函数一般不用重新定义 ，编译器默认会生成。

```c++
#include<iostream>
using namespace std;
class Date
{
public:
	//取地址&重载
	Date* operator&()
	{
		cout << "Date* operator&()" << endl;
		return this;
	}
	//const取地址&重载
	const Date* operator&() const
	{
		cout << "const Date* operator&() const" << endl;
		return this;
	}
private:
	int _year = 1; // 年
	int _month = 1; // 月
	int _day = 1; // 日
};
int main()
{
	Date d1;
	const Date d2;
	cout << &d1 << endl;
	cout << &d2 << endl;
	return 0;
}
```

这两个运算符一般不需要重载，使用编译器生成的默认取地址的重载即可，只有特殊情况，才需要重载，比如想让别人获取到指定的内容！

## 日期类实现

Date.h

```c++
#include<iostream>
#include<assert.h>
using namespace std;

class Date {
	// 友元函数声明
    // <<流输入操作符重载
	friend ostream& operator<<(ostream& out, const Date& d);
    // >>流提取操作符重载
	friend istream& operator>>(istream& in, Date& d);
public:
	// 构造函数
	Date(int year = 1970, int month = 1, int day = 1);
	// 拷贝构造函数
	Date(const Date& x);
	// 析构函数
	~Date(){}
    
	// 赋值运算符重载
	Date& operator=(const Date& x);

	// <运算符重载
	bool operator<(const Date& x) const;
	// ==运算符重载
	bool operator==(const Date& x) const;
	// <=运算符重载
	bool operator<=(const Date& x) const;
	// >运算符重载
	bool operator>(const Date& x) const;
	// >=运算符重载
	bool operator>=(const Date& x) const;
	// !=运算符重载
	bool operator!=(const Date& x) const;
    
	// 获取某年某月的天数
	int GetMonthDay(int year, int month);
	// 日期+=天数
	Date& operator+=(int day);
	// 日期+天数
	Date operator+(int day) const;
	// 日期-=天数
	Date& operator-=(int day);
	// 日期-天数
	Date operator-(int day) const;
    
	// 前置++
	Date& operator++();
	// 后置++
	Date operator++(int);
	// 前置--
	Date& operator--();
	// 后置--
	Date operator--(int);
    
	// 日期-日期，返回天数
	int operator-(const Date& d) const;
    
	// 打印对象
	void Print() const
	{
		cout << _year << "-" << _month << "-" << _day << endl;
	}
private:
	int _year;
	int _month;
	int _day;
};
ostream& operator<<(ostream& out, const Date& d);
istream& operator>>(istream& in, Date& d);
```

Date.cpp

```c++
#include"Date.h"
// 构造函数
Date::Date(int year, int month, int day) {
	if (month <= 12 && month >= 1 && day >= 1 && day <= GetMonthDay(year, month)) {
		_year = year;
		_month = month;
		_day = day;
	}
	else {
		cout << "非法日期" << endl;
		assert(false);
	}
}
// 拷贝构造函数
Date::Date(const Date& x) {
	_year = x._year;
	_month = x._month;
	_day = x._day;
}
// 赋值运算符重载
Date& Date::operator=(const Date& x) {
	if (this == &x)
		return *this;
	_year = x._year;
	_month = x._month;
	_day = x._day;
	return *this;
}
// <运算符重载
bool Date::operator<(const Date& x) const {
	if (_year < x._year)
		return true;
	else if (_year == x._year && _month < x._month)
		return true;
	else if (_year == x._year && _month == x._month && _day < x._day)
		return true;
	return false;
}
// ==运算符重载
bool Date::operator==(const Date& x) const {
	return _year == x._year
		&& _month == x._month
		&& _day == x._day;
}
// <=运算符重载
bool Date::operator<=(const Date& x) const {
	return *this < x || *this == x;
}
// >运算符重载
bool Date::operator>(const Date& x) const {
	return !(*this <= x);
}
// >=运算符重载
bool Date::operator>=(const Date& x) const {
	return !(*this < x);
}
// !=运算符重载
bool Date::operator!=(const Date& x) const {
	return !(*this == x);
}
// 获取某年某月的天数
int Date::GetMonthDay(int year, int month) {
	int mdays[13] = { 0,31,28,31,30,31,30,31,31,30,31,30,31 };
	if (month == 2 && ((year % 400 == 0) || (year % 4 == 0 && year % 100 != 0)))
		return 29;
	else
		return mdays[month];
}
// 日期+=天数
Date& Date::operator+=(int day) {
	if (day < 0) {
		return *this -= -day;
	}
	_day += day;
	while (_day > GetMonthDay(_year, _month)) {
		_day -= GetMonthDay(_year, _month);
		++_month;
		if (_month == 13) {
			++_year;
			_month = 1;
		}
	}
	return *this;
}
// 日期+天数
Date Date::operator+(int day) const {
	Date temp = *this;
	temp += day;
	return temp;
}
// 日期-=天数
Date& Date::operator-=(int day) {
	if (day < 0) {
		return *this += -day;
	}
	_day -= day;
	while (_day <= 0) {
		--_month;
		if (_month == 0) {
			--_year;
			_month = 12;
		}
		_day += GetMonthDay(_year, _month);
	}
	return *this;
}
// 日期-天数
Date Date::operator-(int day) const {
	Date temp = *this;
	temp -= day;
	return temp;
}
// 前置++
Date& Date::operator++() {
	*this += 1;
	return *this;
}
// 后置++
Date Date::operator++(int) {
	Date temp(*this);
	*this += 1;
	return temp;
}
// 前置--
Date& Date::operator--() {
	*this -= 1;
	return *this;
}
// 后置--
Date Date::operator--(int) {
	Date temp(*this);
	*this -= 1;
	return temp;
}
// 日期-日期
int Date::operator-(const Date& d) const {
	Date max = *this;
	Date min = d;
	int flag = 1;
	if (*this < d) {
		max = d;
		min = *this;
		flag = -1;
	}
	int day = 0;
	while (min != max) {
		++min;
		++day;
	}
	return day * flag;
}
// <<流输入操作符重载
ostream& operator<<(ostream& out, const Date& d) {
	out << d._year << "年" << d._month << "月" << d._day << "日" << endl;
	return out;
}
// >>流提取操作符重载
istream& operator>>(istream& in, Date& d) {
	int year, month, day;
	in >> year >> month >> day;
	if (month <= 12 && month >= 1 && day >= 1 && day <= d.GetMonthDay(year, month)) {
		d._year = year;
		d._month = month;
		d._day = day;
	}
	else {
		cout << "非法日期" << endl;
		assert(false);
	}
	return in;
}
```



# 类和对象（下）

## 再谈构造函数

###  构造函数体赋值

在创建对象时，编译器通过调用构造函数，给对象中各个成员变量一个合适的初始值。

```c++
class Date
{
public:
	Date(int year = 2022, int month = 5, int day = 24)
	{
		_year = year;
		_year = 2023; //第二次赋值
        _year = 2024; //第三次赋值
		_month = month;
		_day = day;
	}
private:
	int _year;
	int _month;
	int _day;
};
```

虽然上述构造函数调用之后，对象中已经有了一个初始值，但是不能将其称为对对象中成员变量的初始化， 构造函数体中的语句只能将其称为**赋初值**，而不能称作初始化。**因为初始化只能初始化一次，而构造函数体内可以多次赋值。**

### 初始化列表

初始化列表：以一个**冒号开始**，接着是一个**以逗号分隔的数据成员列表**，每个"**成员变量**"后面跟一个放在**括 号中的初始值或表达式**。

```c++
class Date
{
public:
	Date(int year, int month, int day)
		: _year(year)		//对成员变量进行定义和初始化
		, _month(month)
		, _day(day)
	{}
private:
	int _year;	//类中成员变量的声明
	int _month;
	int _day;
};
```

也可以在初始化列表初始化，也可以在大括号内进行赋值：

```c++
Date(int year = 1970, int month = 1, int day = 1)
    : _year(year)
    , _month(month)
    , _day(day)
    {
        _year = 2024;
    }
//最后的_year的值为2024
```

初始化列表的注意事项：

1. 每个成员变量在初始化列表中**只能出现一次**（初始化只能初始化一次）

2. 类中包含以下成员，必须放在初始化列表位置进行初始化：
   **引用成员变量**（必须在定义时初始化）
   **const成员变量**（必须在定义时初始化）
   **自定义类型成员且该类没有默认构造函数时**

   ```c++
   class A
   {
   public:
   	A(int a) :_a(a)
   	{}
   private:
   	int _a;
   };
   class B
   {
   public:
   	B(int a, int ref) :_aobj(a), _ref(ref), _n(10)
   	{}
   private:
   	A _aobj;		// 没有默认构造函数
   	int& _ref;		// 引用
   	const int _n;	// const 
   	int _x = 1;		// 这里1是缺省值，缺省值是给初始化列表的
   };
   int main() {
   	int ref = 1;
   	B b(10, ref);
   	return 0;
   }
   ```

3. 尽量使用初始化列表初始化，因为不管你是否使用初始化列表，对于自定义类型成员变量，一定会先使用初始化列表初始化。

4. 成员变量在类中**声明次序**就是其在初始化列表中的**初始化顺序**，**与其在初始化列表中的先后次序无关**。

   ```c++
   #include<iostream>
   using namespace std;
   class A
   {
   public:
   	A(int a) :_a1(a), _a2(_a1)
   	{}
   	void Print()
   	{
   		cout << _a1 << " " << _a2 << endl;
   	}
   private:
   	int _a2;
   	int _a1;
   };
   int main()
   {
   	A aa(1);	//1 -858993460
   	aa.Print();
   }
   ```

### explicit关键字

构造函数不仅可以构造与初始化对象，**对于接收单个参数的构造函数，还具有类型转换的作用**。接收单个参数的构造函数具体表现：

1. 构造函数只有一个参数
2. 构造函数有多个参数，除第一个参数没有默认值外，其余参数都有默认值
3. 全缺省构造函数

```c++
#include<iostream>
using namespace std;
class A
{
public:
	A(int x) {
		_x = x;
	}
	A(const A& a) {
		_x = a._x;
		cout << "copy" << endl;
	}
	A& operator=(const A&a) {
		if (this != &a) {
			_x = a._x;
		}
		cout << "operator=" << endl;
		return *this;
	}
private:
	int _x;
};
int main() {
	A a1 = 1;//隐式类型转换，整形转换成自定义类型
	//1构造一个A的临时对象，临时对象再拷贝构造a1
	//但是这里为什么没有进入拷贝构造呢？因为编译器自动优化了，直接用1去构造a1

	A a2(1);
	a2 = 2;//隐式类型转换，整形转换成自定义类型
	//2构造一个A的临时对象，临时对象再赋值给a2

	//A& a3 = 3;//error:“初始化”: 无法从“int”转换为“A &”
	const A& a3 = 3;	//临时变量具有常性

	return 0;
}
```

**用explicit修饰构造函数，将会禁止构造函数的隐式转换。**

```c++
#include<iostream>
using namespace std;
class A
{
public:
	explicit A(int x, int y = 0, int z = 0) :_x(x), _y(y), _z(z)
	{}
private:
	int _x;
	int _y;
	int _z;
};
int main() {
	A a1 = 1;//error:不存在从"int"转换到"A"的适当构造函数
	return 0;
}
```

## static成员

### 概念

声明为static的类成员称为**类的静态成员**，用static修饰的成员变量，称之为**静态成员变量**；用static修饰的 成员函数，称之为**静态成员函**数。**静态成员变量一定要在类外进行初始化**。

```c++
//面试题
#include<iostream>
using namespace std;
class A
{
public:
	A() { ++_scount; }
	A(const A& t) { ++_scount; }
	~A() { --_scount; }
	static int GetACount() { return _scount; }
private:
	static int _scount;
};
int A::_scount = 0;
void TestA()
{
	static A a2;
	cout << __LINE__ << " " << A::GetACount() << endl;

}
int main() {
	A a1;
	cout << __LINE__ << " " << A::GetACount() << endl;//1	
	TestA();//2
	TestA();//2
	return 0;
}
```

### 特性

1. **静态成员为所有类对象所共享**，不属于某个具体的对象，存放在静态区
2. **静态成员变量必须在类外定义**，定义时不添加static关键字，类中只是声明
3. 类静态成员即可用 **类名::静态成员** 、**对象.静态成员** 或者 **类名(构造函数参数).静态成员** 来访问
4. 静态成员函数**没有**隐藏的**this指针**，不能访问任何非静态成员
5. 静态成员也是类的成员，受public、protected、private 访问限定符的限制

> **【问题】**
>
> 1. 静态成员函数可以调用非静态成员函数吗？
>    不可以，因为静态成员函数是没有this指针的，无法调用非静态成员函数。
> 2. 非静态成员函数可以调用类的静态成员函数吗？
>    可以，因为静态成员为所有类对象所共享，不受访问限制

**OJ练习：**

求1+2+3+...+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。

```c++
class A{
public:
    A(){
        ++_k;
        _ret += _k;
    }
    static int Sum(){
        return _ret;
    }
private:
    static int _k;
    static int _ret;
};
int A::_k = 0;
int A::_ret = 0;
class Solution {
public:
    int Sum_Solution(int n) {
        A a[n];
        return A::Sum();
    }
};
```

## 友元

友元提供了一种突破封装的方式，有时提供了便利。但是友元会增加耦合度，破坏了封装，所以友元不宜多用。 

友元分为：**友元函数**和**友元类**

### 友元函数

问题：如果尝试去重载operator<<，会发现operator<<函数第一个参数是隐含的this指针而不是cout的输出流对象，会导致没法正常使用cout（d<<cout，即d.operator<<(&d, cout)），如果将operator<<定义为全局函数又会使得函数无法访问类中的私有成员，这时候就需要友元函数。

友元函数可以**直接访问类的私有成员**，它是**定义在类外部的普通函数**，不属于任何类，但需要**在类的内部声明**，声明时需要加**friend**关键字。

```c++
class Date
{
     friend ostream& operator<<(ostream& _cout, const Date& d);
     friend istream& operator>>(istream& _cin, Date& d);
public:
    Date(int year = 1900, int month = 1, int day = 1)
        : _year(year), _month(month), _day(day)
        {}
private:
    int _year;
    int _month;
    int _day;
};
ostream& operator<<(ostream& _cout, const Date& d)
{
     _cout << d._year << "-" << d._month << "-" << d._day;
     return _cout;
}
istream& operator>>(istream& _cin, Date& d)
{
     _cin >> d._year;
     _cin >> d._month;
     _cin >> d._day;
     return _cin;
}
int main()
{
     Date d;
     cin >> d;
     cout << d << endl;
     return 0;
}
```

> **说明:** 
>
> 1. 友元函数**可访问类的私有和保护成员**，但**不是类的成员函数**
> 2. 友元函数**不能用const修饰**
> 3. 友元函数可以**在类定义的任何地方声明**，**不受类访问限定符限制**
> 4. 一个函数可以是多个类的友元函数
> 5. 友元函数的调用与普通函数的调用原理相同

### 友元类

友元类的所有成员函数都可以是另一个类的友元函数，都可以访问另一个类中的非公有成员。

1. 友元关系是单向的，不具有交换性。
   比如Time类和Date类，在Time类中声明Date类为其友元类，那么可以在Date类中直接访问Time 类的私有成员变量，但想在Time类中访问Date类中私有的成员变量则不行。
2. 友元关系不能传递
   如果B是A的友元，C是B的友元，则不能说明C时A的友元。
3. 友元关系不能继承，在继承位置再详细介绍。

```c++
class Time
{
	friend class Date; // 声明日期类为时间类的友元类，则在日期类中就直接访问Time类中的私有成员变量
public:
	Time(int hour = 0, int minute = 0, int second = 0)
		: _hour(hour)
		, _minute(minute)
		, _second(second)
	{}
private:
	int _hour;
	int _minute;
	int _second;
};
class Date
{
public:
	Date(int year = 1900, int month = 1, int day = 1)
		: _year(year)
		, _month(month)
		, _day(day)
	{}
	void SetTimeOfDate(int hour, int minute, int second)
	{
		// 直接访问时间类私有的成员变量
		_t._hour = hour;
		_t._minute = minute;
		_t._second = second;
	}
private:
	int _year;
	int _month;
	int _day;
	Time _t;
};
```

## 内部类

概念：**如果一个类定义在另一个类的内部**，这个内部类就叫做内部类。内部类是一个独立的类，它不属于外部类，更不能通过外部类的对象去访问内部类的成员。外部类对内部类没有任何优越的访问权限。

注意：内部类就是外部类的友元类，参见友元类的定义，**内部类可以通过外部类的对象参数来访问外部类中的所有成员**，**但是外部类不是内部类的友元**。

> 特性：
>
> 1. 内部类可以定义在外部类的public、protected、private都是可以的。内部类受外部类访问限定符的限制。
> 2. 注意内部类可以直接访问外部类中的static成员，不需要外部类的对象/类名。
> 3. sizeof(外部类) = 外部类，和内部类没有任何关系。

```c++
#include<iostream>
using namespace std;
class A
{
public:
    class B
    {
    public:
        void func(const A& a)
        {
            cout << _k << endl;//OK
            cout << a._h << endl;//OK
        }
    private:
        int _b;
    };
private:
    static int _k;
    int _h;
    class C
    {
    public:
        void func() 
        {}
    private:
        int _c;
    };
};
int A::_k = 1;
int main()
{
    cout << sizeof(A) << endl;  //4
    //外部类的大小与内部类和静态成员变量无关

    A::B b;
    A::C c; //无法访问私有C类
    return 0;
}
```

## 匿名对象

```c++
class A
{
public:
	A(int a = 0) :_a(a)
	{
		cout << "construct" << endl;
	}
	~A()
	{
		cout << "destruct" << endl;
	}
private:
	int _a;
};
class B 
{
public:
	B(int x) :_x(x)
	{}
	static int Func(int n) {
		cout << "Func" << endl;
		return n;
	}
private:
	int _x;
};
int main()
{
	A aa(1);  // 有名对象 -- 生命周期在当前函数局部域
	A(2);     // 匿名对象 -- 生命周期在当前行

	//A& ra = A(1);		// error:匿名对象具有常性，这样定义权限放大
	const A& ra = A(1); // const引用延长匿名对象的生命周期，生命周期在当前函数局部域

	//访问成员函数的方式
	B b1(1);
	b1.Func(10);
	B(1).Func(20);	//使用匿名对象调用成员函数
	B::Func(30);	//仅限static成员函数
	return 0;
}
```

## 拷贝对象时编译器的一些优化

- **编译器对返回值的优化**

```c++
A Func1() {
	A temp(1);
	return temp;
}
void Test1(){
    A a1 = Func1();
	// 优化前：构造temp + 拷贝构造临时变量用来返回 + 拷贝构造a1
	// 优化后：构造a1
	A a2;
	a2 = Func1();
	// 优化前：构造a2 + 构造temp + 拷贝构造临时变量用来返回 + 赋值a2
	// 优化后：构造a2 + 构造temp + 赋值a2
}
```

- **匿名对象传参时的优化写法**

```c++
void Func2(A a) {

}
void Test2(){
    //普通传参：构造a3 + 拷贝构造形参a
	A a3(10);
	Func2(a3);

	// 使用匿名对象传参
	Func2(A(10));
	Func2(10);
	// 优化前：构造匿名对象 + 拷贝构造形参a
	// 优化后：构造形参a
}
```

# C/C++内存管理

## C/C++内存分布

1. 栈又叫堆栈：**非静态局部变量/函数参数/返回值**等等，栈是向下增长的。
2. 内存映射段是高效的I/O映射方式，用于装载一个共享的动态内存库。用户可使用系统接口创建共享共 享内存，做进程间通信。
3. 堆用于程序运行时**动态内存分配**，堆是可以上增长的。
4. 数据段（静态区）：存储**全局数据**和**静态数据**。
5. 代码段（常量区）：存储**可执行代码**和**只读常量**。

```c++
int globalVar = 1;					//全局变量，存放在静态区
static int staticGlobalVar = 1;		//静态全局变量，存放在静态区
void Test()
{
	static int staticVar = 1;		//静态局部变量，存放在静态区
	int localVar = 1;				//非静态局部变量，存放在栈区
	int num1[10] = { 1, 2, 3, 4 };	//非静态局部变量，存放在栈区
	char char2[] = "abcd";
	//char2为数组，存放在栈区，char2中存放的是只读常量"abcd\0"的拷贝
	//只读常量"abcd\0"存放在代码段
	const char* pChar3 = "abcd";
	//pChar为指针，存放在栈区，pChar中存放的是只读常量"abcd\0"的地址
	//只读常量"abcd\0"存放在代码段
	int* ptr1 = (int*)malloc(sizeof(int) * 4);
	//ptr1为指针，存放在栈区，ptr1中存放的是数组的地址
	//*ptr1是有4个int型的数组，内存空间在堆区
	int* ptr2 = (int*)calloc(4, sizeof(int));
	//同ptr1
	int* ptr3 = (int*)realloc(ptr2, sizeof(int) * 4);
	//与ptr1类似
	free(ptr1);
	//没有free(ptr2)的原因是realloc开辟空间的方式
	//	1. 会在原空间后追加新空间
	//	2. 开辟新空间，并将原空间的数据拷贝到新空间，销毁掉原空间
	free(ptr3);
}
sizeof(num1) = 40;
sizeof(char2) = 5; strlen(char2) = 4;
sizeof(pChar3) = 4/8; strlen(pChar3) = 5;
sizeof(ptr1) = 4/8;
sizeof与strlen的区别：
    sizeof()是操作符，是用来计算对象或类型所占内存空间的大小
    strlen()是函数，是用来计算字符串长度的
```

![image-20240531161526741](F:/cs/note/images/image-20240531161526741.png)

## C++内存管理方式

C语言内存管理方式在C++中可以继续使用，但有些地方就无能为力，而且使用起来比较麻烦，因此C++又提出了自己的内存管理方式：通过**new**和**delet**e操作符进行动态内存管理。

### new/delete操作内置类型

```c++
int main() {
	// 动态申请一个int型的空间
	int* ptr1 = new int;
	// 动态申请一个int型的空间，并初始化为10
	int* ptr2 = new int(10);
	// 动态申请10个int型的空间
	int* ptr3 = new int[10];
	// 动态申请10个int型的空间，并非完全初始化
	int* ptr4 = new int[10] {1, 2, 3};
	
	delete ptr1;
	delete ptr2;
	delete[] ptr3;
	delete[] ptr4;
	return 0;
}
```

> 注意：申请和释放单个元素的空间，使用new和delete操作符，申请和释放连续的空间，使用new[]和 delete[]，注意：匹配起来使用。

### new和delete操作自定义类型

对于内置类型而言，用malloc和new，除了用法不同，没有什么区别。它们的区别在于自定义类型。

```c++
class A
{
public:
	A(int a = 0, int b = 0)
		: _a(a), _b(b)
	{
		cout << "A():" << this << endl;
	}
	A(const A& aa)
		: _a(aa._a)
	{
		cout << "A(const A& aa):" << this << endl;
	}
	~A()
	{
		cout << "~A():" << this << endl;
	}
private:
	int _a;
	int _b;
};
int main()
{
	A* p1 = (A*)malloc(sizeof(A));
	A* p2 = new A(1, 1);
	free(p1);
	delete p2;

	A* p3 = (A*)malloc(sizeof(A) * 4);
	A* p4 = new A[4]{ A(1,1),A(2,2),A(3,3) };
	free(p3);
	delete[] p4;

	return 0;
}
```

**在申请自定义类型的空间时，new会先开辟自定义类型空间然后调用构造函数初始化对象，delete会先调用析构函数释放对象中成员变量的空间然后释放自定义类型空间。**

## operator new与operator delete函数（重要）

new和delete是用户进行**动态内存申请和释放的操作符**，**operator new** 和**operator delete**是系统提供的**全局函数**，**new在底层调用operator new全局函数来申请空间**，d**elete在底层通过operator delete全局 函数来释放空间**。

operator new：该函数实际**通过malloc来申请空间**，当malloc申请空间成功时直接返回；申请空间失败， 尝试执行空间不足应对措施，如果应对措施用户设置了，则继续申请，否则抛异常。
operator delete: 该函数最终是通过free来释放空间的。

operator new和operator delete的意义体现在new和delete的底层原理：
	**new的底层原理：转换成调用operator new开辟空间，然后构造函数初始化对象。**
	**delete的底层原理：先通过析构函数释放对象中的成员变量，转换成调用operator delete释放对象空间。**

## new和delete的实现原理

### 内置类型

如果申请的是内置类型的空间，new和malloc，delete和free基本类似，不同的地方是：new/delete申请和释放的是单个元素的空间，new[]和delete[]申请的是连续空间，而且**new在申请空间失败时会抛异常， malloc会返回NULL**。

### 自定义类型

- new的原理
  1. 调用operator new函数申请空间
  2. 在申请的空间上执行构造函数，完成对象的构造
- delete的原理
  1. 在空间上执行析构函数，完成对象中资源的清理工作
  2. 调用operator delete函数释放对象的空间
- new T[N]的原理
  1. 调用operator new[]函数，在operator new[]中实际调用operator new函数完成N个对象空间的申请
  2. 在申请的空间上执行N次构造函数
- delete[ ]的原理
  1. 在释放的对象空间上执行N次析构函数，完成N个对象中资源的清理
  2. 调用operator delete[]释放空间，实际在operator delete[]中调用operator delete来释放空间

举例：

```c++
class Stack
{
public:
	Stack(int capacity = 4) :_arr(new int[capacity] {0}), _top(0), _capacity(capacity)
	{}
	~Stack() {
		delete[] _arr;
		_top = _capacity = 0;
	}
private:
	int* _arr;
	int _top;
	int _capacity;
};
int main() {
	Stack* s = new Stack(8);

	delete s;
	return 0;
}
```

<img src="F:/cs/note/images/image-20240531221204597.png" alt="image-20240531221204597" style="zoom: 33%;" />

## 定位new表达式（replacement new）（了解）

定位new表达式是在**已分配的原始内存空间中调用构造函数初始化一个对象。** 

使用格式： **new (place_address) type**或者**new (place_address) type(initializer-list)** 
place_address必须是一个指针，initializer-list是类型的初始化列表

使用场景： 定位new表达式在实际中一般是配合**内存池**使用。因为内存池分配出的内存没有初始化，所以如果是自定 类型的对象，需要使用new的定义表达式进行显示调构造函数进行初始化。

```c++
class A
{
public:
	A(int a = 0)
		: _a(a)
	{
		cout << "A():" << this << endl;
	}
	~A()
	{
		cout << "~A():" << this << endl;
	}
private:
	int _a;
};
// 定位new/replacement new
int main()
{
	// p1现在指向的只不过是与A对象相同大小的一段空间，还不能算是一个对象，因为构造函数没有执行
	A* p1 = (A*)malloc(sizeof(A));
	new(p1)A; // 注意：如果A类的构造函数有参数时，此处需要传参
	p1->~A();
	free(p1);

	A* p2 = (A*)operator new(sizeof(A));
	new(p2)A(10);
	p2->~A();
	operator delete(p2);
	return 0;
}
```

## 常见面试题

### malloc/free和new/delete的区别

共同点是：都是从堆上申请空间，并且需要用户手动释放。

不同点是：

1. malloc和free是函数，new和delete是操作符
2. malloc申请的空间不会初始化，new可以初始化
3. malloc申请空间时，需要手动计算空间大小并传递，new只需在其后跟上空间的类型即可， 如果是多个对象，[]中指定对象个数即可
4. malloc的返回值为void*, 在使用时必须强转，new不需要，因为new后跟的是空间的类型
5. malloc申请空间失败时，返回的是NULL，因此使用时必须判空，new不需要，但是new需要捕获异常
6. **申请自定义类型对象时，malloc/free只会开辟空间，不会调用构造函数与析构函数，而new在申请空间后会调用构造函数完成对象的初始化，delete在释放空间前会调用析构函数完成空间中资源的清理**

###  内存泄漏

1.  什么是内存泄漏，内存泄漏的危害？
   什么是内存泄漏：内存泄漏指因为疏忽或错误造成程序未能释放已经不再使用的内存的情况。内存泄漏并不 是指内存在物理上的消失，而是应用程序分配某段内存后，因为设计错误，失去了对该段内存的控制，因而造成了内存的浪费。 
   内存泄漏的危害：长期运行的程序出现内存泄漏，影响很大，如操作系统、后台服务等等，出现内存泄漏会导致响应越来越慢，最终卡死。

   ```c++
   void MemoryLeaks()
   {
   	// 1.内存申请了忘记释放
   	int* p1 = (int*)malloc(sizeof(int));
   	int* p2 = new int;
   	// 2.异常安全问题
   	int* p3 = new int[10];
   	Func(); // 这里Func函数抛异常导致 delete[] p3未执行，p3没被释放.
   	delete[] p3;
   }
   ```

2.  内存泄漏分类（了解）

   - **堆内存泄漏(Heap leak)**
     堆内存指的是程序执行中依据须要分配通过malloc / calloc / realloc / new等从堆中分配的一块内存， 用完后必须通过调用相应的 free或者delete 删掉。假设程序的设计错误导致这部分内存没有被释放，那 么以后这部分空间将无法再被使用，就会产生Heap Leak。
   - **系统资源泄漏**
     指程序使用系统分配的资源，比方套接字、文件描述符、管道等没有使用对应的函数释放掉，导致系统 资源的浪费，严重可导致系统效能减少，系统执行不稳定。

3.  如何检测内存泄漏（了解）
   在vs下，可以使用windows操作系统提供的**_CrtDumpMemoryLeaks()** 函数进行简单检测，该函数只报出 了大概泄漏了多少个字节，没有其他更准确的位置信息。

   ```c++
   int main()
   {
       int* p = new int[10];
       // 将该函数放在main函数之后，每次程序退出的时候就会检测是否存在内存泄漏
       _CrtDumpMemoryLeaks();
       return 0;
   }
   ////////////////////////////////////////////////////////
   // 程序退出后，在输出窗口中可以检测到泄漏了多少字节，但是没有具体的位置
   Detected memory leaks!
   Dumping objects ->
   {79} normal block at 0x00EC5FB8, 40 bytes long.
   Data: < > CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD
   Object dump complete.
   ```

4. 如何避免内存泄漏
   内存泄漏非常常见，解决方案分为两种：1、事前预防型。如智能指针等。2、事后查错型。如泄漏检测工具。

# 模板初阶

## 泛型编程

```c++
void Swap(int& left, int& right)
{
 int temp = left;
 left = right;
 right = temp;
}
void Swap(double& left, double& right)
{
 double temp = left;
 left = right;
 right = temp;
}
void Swap(char& left, char& right)
{
 char temp = left;
 left = right;
 right = temp;
}
......
```

使用函数重载虽然可以实现，但是有一下几个不好的地方： 

1. 重载的函数仅仅是类型不同，代码复用率比较低，只要有新类型出现时，就需要用户自己增加对应的函 数
2. 代码的可维护性比较低，一个出错可能所有的重载均出错

那能否告诉编译器一个模子，让编译器根据不同的类型利用该模子来生成代码呢？
这就是**泛型编程**，泛型编程是编写与类型无关的通用代码，是代码复用的一种手段。**模板是泛型编程的基础**。

## 函数模板

### 概念

函数模板代表了一个函数家族，该函数模板与类型无关，在使用时被参数化，根据实参类型产生函数的特定 类型版本。

### 函数模板格式

```c++
template<typename T1, typename T2,......,typename Tn>
返回值类型 函数名(参数列表){}
```

```c++
template<typename T>
void Swap(T& keft, T& right) {
	T temp = left;
	left = right;
	right = left;
}
```

> **注意：typename是用来定义模板参数关键字，也可以使用class(切记：不能使用struct代替class)**

### 函数模板的原理

函数模板是一个蓝图，它本身并不是函数，是编译器用使用方式产生特定具体类型函数的模具。所以其实模板就是将本来应该我们做的重复的事情交给了编译器

![image-20240601203649306](F:/cs/note/images/image-20240601203649306.png)

在编译器**编译阶段**，对于模板函数的使用，**编译器需要根据传入的实参类型来推演生成对应类型的函数**以供调用。比如：**当用double类型使用函数模板时，编译器通过对实参类型的推演，将T确定为double类型，然后产生一份专门处理double类型的代码**，对于字符类型也是如此。

### 函数模板的实例化

**用不同类型的参数使用函数模板时，称为函数模板的实例化**。模板参数实例化分为：**隐式实例化**和**显式实例化**。

1. **隐式实例化：让编译器根据实参推演模板参数的实际类型**

   ```c++
   template<class T>
   T Add(const T& left, const T& right) {
   	return left + right;
   }
   int main(){
   	int a = 1;
   	double b = 3.14;
   	Add(a, b);	//error:没有与参数列表匹配的 函数模板"Add"实例
   	//该语句不能通过编译，因为在编译期间，当编译器看到该实例化时，需要推演其实参类型
   	//通过实参a1将T推演为int，通过实参d1将T推演为double类型，但模板参数列表中只有一个T，
   	//编译器无法确定此处到底该将T确定为int 或者 double类型而报错
   	//注意：在模板中，编译器一般不会进行类型转换操作，因为一旦转化出问题，编译器就需要背黑锅
   
   	// 此时有两种处理方式：1. 用户自己来强制转化 2. 使用显式实例化
   	Add(a, (int)b);//ok
   	return 0;
   }
   ```

2. **显式实例化：在函数名后的<>中指定模板参数的实际类型**

   ```c++
   int main()
   {
        int a = 10;
        double b = 20.0;
   
        // 显式实例化
        Add<int>(a, b);
        return 0;
   }
   ```

   如果类型不匹配，编译器会尝试进行隐式类型转换，如果无法转换成功编译器将会报错。

### 模板参数的匹配原则

1. **一个非模板函数可以和一个同名的函数模板同时存在，而且该函数模板还可以被实例化为这个非模板函 数**

   ```c++
   // 专门处理int的加法函数
   int Add(int left, int right)
   {
   	 return left + right;
   }
   // 通用加法函数
   template<class T>
   T Add(T left, T right)
   {
   	return left + right;
   }
   void Test()
   {
       Add(1, 2); 	 // 与非模板函数匹配，编译器不需要特化
       Add<int>(1, 2); // 调用编译器特化的Add版本
   }
   ```

2. **对于非模板函数和同名函数模板，如果其他条件都相同，在调动时会优先调用非模板函数而不会从该模板产生出一个实例。如果模板可以产生一个具有更好匹配的函数， 那么将选择模板**

   ```c++
   // 专门处理int的加法函数
   int Add(int left, int right)
   {
   	return left + right;
   }
   // 通用加法函数
   template<class T1, class T2>
   T1 Add(T1 left, T2 right)
   {
   	return left + right;
   }
   void Test()
   {
       Add(1, 2); 	 // 与非函数模板类型完全匹配，不需要函数模板实例化
       Add(1, 2.0); // 模板函数可以生成更加匹配的版本，编译器根据实参生成更加匹配的Add函数
   }
   ```

3. **模板函数不允许自动类型转换，但普通函数可以进行自动类型转换**

## 类模板

### 类模板的定义格式

```c++
template<class T1, class T2, ..., class Tn>
class 类模板名
{
	// 类内成员定义
}; 
```

```c++
template<class T>
class Stack
{
public:
	Stack(size_t capacity = 4) 
		:_arr(new T[capacity])
		,_size(0)
		,_capacity(capacity)
	{}

	// 使用入栈和析构演示：在类中声明，在类外定义。
	void Push(const T& data);
	~Stack();
private:
	T* _arr;
	size_t _size;
	size_t _capacity;
};

// 注意：类模板中函数放在类外进行定义时，需要加模板参数列表
template<class T>
void Stack<T>::Push(const T& data) {
	_arr[_size++] = data;
}

template<class T>
Stack<T>::~Stack() {
	if (_arr) {
		free(_arr);
		_arr = nullptr;
		_size = 0;
		_capacity = 0;
	}
}


```

### 类模板的实例化

类模板实例化与函数模板实例化不同，**类模板实例化需要在类模板名字后跟<>，然后将实例化的类型放在<> 中即可，类模板名字不是真正的类，而实例化的结果才是真正的类**。

```c++
// Stack类名，Stack<int>才是类型
int main() {
	Stack<int> s1;
	Stack<double> s2;
	Stack<char> s3;
	return 0;
}
```

# string

## 标准库中的string类

### string类介绍

![image-20240604194500247](F:/cs/note/images/image-20240604194500247.png)

1. string是表示字符串的字符串类。
2. 该类的接口与常规容器的接口基本相同，再添加了一些专门用来操作string的常规操作。
3. string在底层实际是：basic_string类模板的实例化的别名，`typedef basic_string<char> string;` 。
4. 不能操作多字节或者变长字符的序列。
5. 在使用string类时，必须包含`#include<string>`以及访问std命名空间。

### string类的常见接口使用

1. **string类的构造函数和赋值重载**
   ![image-20240610140601999](F:/cs/note/images/image-20240610140601999.png)
   ![image-20240610140630850](F:/cs/note/images/image-20240610140630850.png)

   ```c++
   void test1() {
   	//构造函数	
   	string s1;					//构造一个空字符串对象
   	string s2("hello world");	//用"hello world"构造
   	string s3("hello world", 5);//用"hello world"的前5个字符构造
   	string s4(5, 'x');			//用5个'x'字符的字符串构造
   	string s5(s2);				//拷贝构造
   	string s6(s2, 6, 5);		//用s2的第6个字符后的5个字符构造
       string s7(s2, 6);			//用s2的第6个字符后的全部字符构造
   	//赋值重载
   	s1 = s2;
   	s3 = "hello world";
   	s4 = 'c';
   
   	cout << s1 << endl;	//hello world
   	cout << s2 << endl;	//hello world
   	cout << s3 << endl;	//hello world
   	cout << s4 << endl;	//c
   	cout << s5 << endl;	//hello world
   	cout << s6 << endl;	//world
   	cout << s7 << endl;	//world
   }
   ```

2. string类对象的访问及遍历操作

   | 函数名称       | 功能说明                                   |
   | -------------- | ------------------------------------------ |
   | **operator[]** | 返回pos位置的字符，const string类对象调用  |
   | at()           | 返回pos位置的字符，const string类对象调用  |
   | **迭代器**     | **begin() + end() 或者 rbegin() + rend()** |
   | 范围for        | C++11支持更简洁的范围for的新遍历方式       |

   **operator[]和at()的对比**

   > ```c++
   > void test2() {
   > 	string s("abcdef");
   > 	//operator[]
   > 	for (int i = 0; i < s.size(); i++) {
   > 		s[i]++;
   > 		cout << s[i] << " ";
   > 	}
   > 	cout << endl;
   > 	//at
   > 	for (int i = 0; i < s.size(); i++) {
   > 		s.at(i)++;
   > 		cout << s.at(i) << " ";
   > 	}
   > 	cout << endl;
   > }
   > ```
   >
   > 不论是operator[]还是at()都修改字符串的内容，二者的区别在与越界访问的行为，**at()越界访问会抛出异常，operator[]越界访问会导致未定义行为，在VS2022中会导致断言**。

   **迭代器**

   > <img src="F:/cs/note/images/image-20240605145219160.png" alt="image-20240605145219160" style="zoom: 33%;" />
   >
   > ```c++
   > void test2() {
   > 	string s("abcdef");
   > 	//迭代器
   > 	string::iterator it = s.begin();
   > 	while (it != s.end()) {
   > 		(*it)++;
   > 		cout << *it << " ";
   > 		it++;
   > 	}
   > 	cout << endl;
   > 	auto rit = s.rbegin();
   > 	while (rit != s.rend()) {
   > 		(*rit)++;
   > 		cout << *rit << " ";
   > 		rit++;
   > 	}
   > 	cout << endl;
   > }
   > ```
   >
   > 迭代器跟指针很类似，有可能是指针也有可能不是指针。一些算法库函数可以通过迭代器来操作容器中的数据，如reverse和sort函数。

   范围for

   > ```c++
   > void test2() {
   > 	string s("abcdef");
   > 	//范围for
   > 	for (auto& ch : s) {
   > 		ch++;
   > 	}
   > 	for (auto ch : s) {
   > 		cout << ch << " ";
   > 	}
   > 	cout << endl;
   > }
   > ```
   >
   > 范围for的底层实现还是【迭代器】，所以我们可以说在它在遍历的时候相当于是将*it的数据拷贝到当前的ch，和迭代器的本质还是类似的。如果需要修改数据，需要用到引用。

3. string类对象的常见容量操作

   | 函数名称    | 功能说明                                        |
   | ----------- | ----------------------------------------------- |
   | **size**    | 返回字符串有效字符长度                          |
   | length      | 返回字符串有效字符长度                          |
   | capacity    | 返回空间总大小                                  |
   | **clear**   | 清空有效字符                                    |
   | **empty**   | 检测字符串释放为空串，是返回true，否则返回false |
   | **reserve** | 为字符串预留空间                                |
   | **resize**  | 将有效字符的个数改成n个，多出的空间用字符填充   |

   ```c++
   void test3() {
   	string s1("hello world");
   	cout << s1.size() << endl;		//11
   	cout << s1.length() << endl;	//11
   	cout << s1.capacity() << endl;	//15，VS2022默认预留16个字节空间，最后一个字节为'\0'不计入
   	size_t oldcapacity = s1.capacity();
   	for (size_t i = 0; i < 100; i++) {
   		s1 += 'x';
   		if (oldcapacity != s1.capacity()) {
   			cout << "扩容：" << s1.capacity() << endl;
   			oldcapacity = s1.capacity();
   		}
   	}
   	//扩容：31
   	//扩容：47
   	//扩容：70
   	//扩容：105
   	//扩容：157
   	//VS2022以1.5倍的大小自动扩容，不同编译器扩容规则不一样，g++下使用的STL基本是按照2倍方式扩容
   	cout << "-----------------" << endl;
   	cout << s1.size() << endl;		//111
   	cout << s1.capacity() << endl;	//157
   	s1.clear();	//clear只会清除字符串中的内容，不会销毁空间
   	cout << s1.size() << endl;		//0
   	cout << s1.capacity() << endl;	//157
   	if (s1.empty())
   		cout << "empty" << endl;
   
   	cout << "-----------------" << endl;
   	string s2("hi world");
   	s2.reserve(100);
   	cout << s2.size() << endl;		//8，reserve无法修改字符串长度和内容
   	cout << s2.capacity() << endl;	//111，并没有扩容到200，因为需要考虑到内存对齐
   	s2.reserve(20);
   	cout << s2.capacity() << endl;	//111，reserve无法收缩空间
   
   	cout << "-----------------" << endl;
   	string s3("hello");
   	s3.resize(100);
   	cout << s3.size() << endl;		//100，在末尾插入'\0'字符以达到100的大小
   	cout << s3.capacity() << endl;	//111
   	s3.resize(200, 'x');
   	cout << s3.size() << endl;		//200，在末尾插入'x'字符以达到200的大小
   	cout << s3.capacity() << endl;	//207
   	s3.resize(20);
   	cout << s3.size() << endl;		//20，删除第20个字符之后的字符
   	cout << s3.capacity() << endl;	//207，resize无法收缩空间
   }
   ```

   > 注意：
   >
   > 1. size()与length()方法底层实现原理完全相同，引入size()的原因是为了与其他容器的接口保持一 致，一般情况下基本都是用size()。
   > 2. clear()只是将string中有效字符清空，不改变底层空间大小。
   > 3. `resize(size_t n)` 与`resize(size_t n, char c)`都是将字符串中有效字符个数改变到n个，不同的是当字符个数增多时：resize(n)用`‘\0’`来填充多出的元素空间，resize(size_t n, char c)用字符c来填充多出的元素空间。注意：resize在改变元素个数时，如果是将元素个数增多，可能会改变底层容量的大小，如果是将元素个数减少，底层空间总大小不变。
   > 4. `reserve(size_t n = 0)`：为string预留空间，不改变有效元素个数，当reserve的参数小于 string的底层空间总大小时，reserver不会改变容量大小。
   > 5. 对string操作时，如果能够大概预估到放多少字符，可以先通过reserve/reszie把空间预留好。

4. string类对象的修改操作

   | 函数名称       | 功能说明                     |
   | -------------- | ---------------------------- |
   | push_back      | 在字符串后尾插字符           |
   | append         | 在字符串后面追加字符串       |
   | **operator+=** | 在字符串后面追加字符串       |
   | insert         | 在指定位置插入字符或字符串   |
   | assign         | 使用指定的字符串替换原字符串 |
   | erase          | 删除字符串中的一部分         |
   | replace        | 替换指定区间的字符串         |
   | pop_back       | 删除最后一个字符             |
   | swap           | 交换字符串值                 |

   > 注意：在string尾部追加字符时，s.push_back(c) / s.append(1, c) / s += 'c'三种的实现方式差不多，一般情况下string类的+=操作用的比较多，+=操作不仅可以连接单个字符，还可以连接字符串。 

5. string类对象的其他字符串操作

   | 函数名称          | 功能说明                                                   |
   | ----------------- | ---------------------------------------------------------- |
   | c_str             | 返回 C语言格式字符串                                       |
   | **substr**        | 在str中从pos位置开始往，截取n个字符，然后将其返回          |
   | **find+npos**     | 从字符串pos位置开始往后找字符c，返回该字符在字符串中的位置 |
   | rfind+npos        | 从字符串pos位置开始往前找字符c，返回该字符在字符串中的位置 |
   | find_first_of     | 从前往后找第一个匹配的字符                                 |
   | find_last_of      | 从后往前找第一个匹配的字符                                 |
   | find_first_not_of | 从前往后找第一个不匹配的字符                               |
   | find_last_not_of  | 从后往前找第一个不匹配的字符                               |

   ```c++
   //分离网站的协议、域名和资源名
   void test4() {
   	string url("https://legacy.cplusplus.com/reference/string/string/?kw=string");
   	string protocol;
   	string domain;
   	string uri;
   	size_t pos1 = url.find("://");
   	if (pos1 != string::npos) {
   		protocol = url.substr(0, pos1);
   	}
   	size_t pos2 = url.find('/', pos1 + 3);
   	if (pos2 != string::npos) {
   		domain = url.substr(pos1 + 3, pos2 - (pos1 + 3));
   		uri = url.substr(pos2 + 1);
   	}
   	cout << protocol << endl;
   	cout << domain << endl;
   	cout << uri << endl;
   }
   ```

   ```c++
   //测试find_first_of
   void test5() {
   	string str("Please, replace the vowels in this sentence by asterisks.");
   	size_t pos = str.find_first_of("aeiou");
   	while (pos != string::npos)
   	{
   		str[pos] = '*';
   		pos = str.find_first_of("aeiou", pos + 1);
   	}
   	std::cout << str << endl;
   	//Pl**s*, r*pl*c* th* v*w*ls *n th*s s*nt*nc* by *st*r*sks.
   }
   ```

6. string类对象的非成员函数重载

   | 函数名称                 | 功能说明                                 |
   | ------------------------ | ---------------------------------------- |
   | operator+                | 尽量少用，因为传值返回，导致深拷贝效率低 |
   | **relational operators** | 大小比较                                 |
   | **operator>>**           | 输入运算符重载                           |
   | **operator<<**           | 输出运算符重载                           |
   | **getline**              | 获取一行字符串                           |

7. string类与其他内置类型的转换
   **string转换为内置类型：stoi、stol、stoul、stoll、stoull、stof、stod、stold**
   **内置类型转换为string：to_string、to_wstring**

8. vs和g++下string结构的说明
   注意：下述结构是在32位平台下进行验证，32位平台下指针占4个字节。

   - vs下string的结构
     **string总共占28个字节**，内部结构稍微复杂一点，先是有一个联合体，联合体用来定义string中字 符串的存储空间：
     ![微信图片_20240610134348](F:/cs/note/images/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240610134348.png)
     ![微信图片_20240610134929](F:/cs/note/images/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240610134929.png)
     **当字符串长度小于16时，使用内部固定的字符数组 _Buf 来存放**
     **当字符串长度大于等于16时，从堆上开辟空间，用 _Ptr 指向堆上开辟的空间**
     **string对象大小为 _Buf + _Ptr + _Mysize + _Myres = 16 + 4 + 4 + 4 = 28**
   - g++下string的结构
     g++下，string是通过写时拷贝实现的，string对象总共占4个字节，内部只包含了一个指针，该指 针将来指向一块堆空间，内部包含了如下字段：空间总大小、字符串有效长度、引用计数和指向堆空间的指针，用来存储字符串。

### OJ练习

```c++
// 仅仅反转字母：所有非英文字母保留在原有位置，所有英文字母（小写或大写）位置反转。
// 双指针左右交换
string reverseOnlyLetters(string s) {
	int left = 0, right = s.size() - 1;
	while (left < right) {
		while (left < right && !isalpha(s[left]))
			left++;
		while (left < right && !isalpha(s[right]))
			right--;
		swap(s[left], s[right]);
		left++;
		right--;
	}
	return s;
}
// 找字符串中第一个只出现一次的字符：给定一个字符串s，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回-1。
// 利用辅助数组
int firstUniqChar(string s) {
	int count[27] = { 0 };
	for (size_t i = 0; i < s.size(); i++)
		count[s[i] - 'a']++;
	for (size_t i = 0; i < s.size(); i++)
		if (1 == count[s[i] - 'a'])
			return i;
	return -1;
}

// 字符串里面最后一个单词的长度
// 反向查找‘ ’
int LastWordLength(string& s) {
	if (s.empty())
		return 0;
	int pos = s.rfind(' ');
	return s.size() - (pos + 1);

}
// 验证一个字符串是否是回文：如果在将所有大写字符转换为小写字符、并移除所有非字母数字字符之后，短语正着读和反着读都一样。则可以认为该短语是一个回文串 。
// 双指针左右对比
bool isPalindrome(string s) {
	for (auto& ch : s) {
		if (isupper(ch))
			ch += 32;
	}
	int left = 0, right = s.size() - 1;
	while (left < right) {
		while (left < right && !isalnum(s[left]))
			left++;
		while (left < right && !isalnum(s[right]))
			right--;
		if (s[left] != s[right])
			return false;
		left++;
		right--;
	}
	return true;
}
// 字符串相加
string addStrings(string num1, string num2) {
	string ret;
	int end1 = num1.size() - 1;
	int end2 = num2.size() - 1;
	int flag = 0;
	int value1 = 0, value2 = 0, valueret = 0;
	while (end1 >= 0 || end2 >= 0) {
		if (end1 >= 0)
			value1 = (num1[end1--] - '0');
		else
			value1 = 0;
		if (end2 >= 0)
			value2 = (num2[end2--] - '0');
		else
			value2 = 0;
		valueret = value1 + value2 + flag;
		if (valueret > 9) {
			flag = 1;
			valueret -= 10;
		}
		else
			flag = 0;
		ret += (valueret + '0');
	}
	if (flag == 1)
		ret += '1';
	reverse(ret.begin(), ret.end());
	return ret;
}
// 翻转字符串2: 区间部分翻转：给定一个字符串s和一个整数k，从字符串开头算起，每计数至2k个字符，就反转这2k字符中的前k个字符。如果剩余字符少于 k 个，则将剩余字符全部反转。如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。
string reverseStr(string s, int k) {
	int pos = 0, end = 0;
	while (end != s.size()) {
		if (end - pos == 2 * k) {
			reverse(s.begin() + pos, s.begin() + pos + k);
			pos = end;
		}
		end++;
	}
	if (end - pos == 2 * k || end - pos >= k) {
		reverse(s.begin() + pos, s.begin() + pos + k);
	}
	else if (end - pos < k)
		reverse(s.begin() + pos, s.end());
	return s;
}
// 翻转字符串2: 翻转字符串中的单词
string reverseWords(string s) {
	int start = 0, pos = s.find(' ');
	while (pos != string::npos) {
		reverse(s.begin() + start, s.begin() + pos);
		start = pos + 1;
		pos = s.find(' ', start);
	}
	reverse(s.begin() + start, s.end());
	return s;
}
// 字符串相乘
// 从右往左遍历乘数，将乘数的每一位与被乘数相乘得到对应的结果，结果存入数组，再将每次得到的结果累加，整个过程中涉及到较多字符串相加的操作。然后从后往前处理进位。
string multiply(string num1, string num2) {
	if (num1 == "0" || num2 == "0")
		return "0";
	int len1 = num1.size(), len2 = num2.size();
	vector<int> ret(len1 + len2);
	int value1, value2;
	for (int i = len2 - 1; i >= 0; i--) {
		value2 = num2[i] - '0';
		for (int j = len1 - 1; j >= 0; j--) {
			value1 = num1[j] - '0';
			ret[i + j + 1] += value1 * value2;
		}
	}
	string ans;
	for (int i = len1 + len2 - 1; i > 0; i--) {
		ret[i - 1] += ret[i] / 10;
		ret[i] %= 10;
		ans += (ret[i] + '0');
	}
	if (ret[0] != 0) {
		ans += (ret[0] + '0');
	}
	reverse(ans.begin(), ans.end());
	return ans;
}
```

## string类的模拟实现

**浅拷贝**：也称位拷贝，编译器只是将对象中的值拷贝过来。如果对象中管理资源，最后就会导致**多个对象共享同一份资源**，当一个对象销毁时就会将该资源释放掉，而此时另一些对象不知道该资源已经被释放，以为还有效，所以当继续对资源进项操作时，就会发生发生了访问违规。

**深拷贝**：如果一个类中涉及到资源的管理，其拷贝构造函数、赋值运算符重载以及析构函数必须要显式给出。一般情况都是按照深拷贝方式提供。

String类没有显式定义其拷贝构造函数与赋值运算符重载，此时编译器会合成默认的，当用s1构造s2时，编译器会调用默认的拷贝构造。**最终导致的问题是，s1、s2共用同一块内存空间，在释放时同一块空间被释放多次而引起程序崩溃**，故string类必须显式定义拷贝构造函数和赋值运算符重载。

对于解决浅拷贝问题的方式不止有深拷贝还有**写时拷贝**，浅拷贝的两个主要问题是**同一空间析构两次**和**一个对象的修改会影响另一个对象**。
**写时拷贝**就是在浅拷贝的基础上增加了**引用计数**。在构造时，将资源的计数给成1，每增加一个对象使用该资源，就给计数增加1，当某个对象被销毁时，先给该计数减1，然后再检查是否需要释放资源，如果计数为1，说明该 对象时资源的最后一个使用者，将该资源释放；否则就不能释放，因为还有其他对象在使用该资源。如果一个对象要对资源进行修改，若计数不是1，则进行深拷贝再修改，若计数是1，则直接修改。g++编译器采用的就是写时拷贝。

`string.h`

```c++
#pragma once
#include<string.h>
#include<assert.h>
#include<iostream>
using std::cout;
using std::cin;
using std::endl;
using std::ostream;
using std::istream;

namespace mystring {
	class string {
	public:
		// 默认成员函数
		// string(const char* str = '\0') 错误，类型不匹配，字符不能赋值给指针
		// string(const char* str = "\0") 错误，"\0"字符串是\0\0，不是一个\0
		// string(const char* str = nullptr) 错误，nullptr在strlen里会报错
		string(const char* str = "");			// 构造函数
		string(const string& s);				// 拷贝函数（传统写法）
		string(const string& s);				// 拷贝函数（现代写法）
		~string();								// 析构函数
		string& operator=(const string& s);		// 赋值运算符重载（传统写法）
		string& operator=(string tmp);		// 赋值运算符重载（现代写法）

		// 迭代器
		typedef char* iterator;
		typedef const char* const_iterator;
		iterator begin();
		iterator end();
		const_iterator begin()const;
		const_iterator end()const;

		// 容量操作函数
		size_t size()const;						// 字符串长度			
		void reserve(size_t n);					// 扩容
		void resize(size_t n, char c = '\0');	// 扩容并初始化空间
		void clear();							// 清空

		// 修改字符串函数
		void push_back(char c);					// 尾插字符
		void append(const char* str);			// 尾插字符串
		string& operator+=(char ch);			// +=运算符重载
		string& operator+=(const char* str);	// +=运算符重载
		void insert(size_t pos, size_t n, char c);// 插入多个字符
		void insert(size_t pos, const char* str); // 插入字符串
		void erase(size_t pos, size_t len = npos);// 清除部分空间
		void swap(string& s);					// 交换字符串

		// 访问字符串函数
		const char* c_str()const;				// 输出C语言字符串
		char& operator[](size_t pos);			// []操作符重载
		const char& operator[](size_t pos)const;// []操作符重载
		size_t find(char ch, size_t pos = 0);	// 找到字符
		size_t find(const char* str, size_t pos = 0);// 找到字符串
		string substr(size_t pos = 0, size_t len = npos);// 截取子串

		// 关系操作符重载
		bool operator<(const string& s) const;
		bool operator==(const string& s) const;
		bool operator<=(const string& s) const;
		bool operator>(const string& s) const;
		bool operator>=(const string& s) const;
		bool operator!=(const string& s) const;

		// npos
		static const size_t npos;
	private:
		size_t _size;
		size_t _capacity;
		char* _str;
	};
	// 流插入和流提取
	ostream& operator<<(ostream& out, const string& s);
	istream& operator>>(istream& in, string& s);
}
```

`string.cpp`

```c++
#include"string.h"
// 默认成员函数
mystring::string::string(const char* str) {
	_size = strlen(str);
	_capacity = _size;
	_str = new char[_capacity + 1];
	memcpy(_str, str, _size + 1);
}
mystring::string::string(const string& s) {
	_size = s._size;
	_capacity = s._capacity;
	_str = new char[_capacity + 1];
	memcpy(_str, s._str, _size + 1);
}
// 这里_str一定要初始化为nullptr，因为不初始化内置类型，内置类型会赋随机值，有些编译器会置空是编译器的自定义行为，
// 如果是_str是随机值，交换给temp后，temp出作用域调用析构函数，会释放随机空间，故报错。
mystring::string::string(const string& s)
	:_str(nullptr)
	, _size(0)
	, _capacity(0)
{
	string tmp(s._str);
	swap(tmp);
}
mystring::string::~string() {
	if (_str) {
		delete[] _str;
		_str = nullptr;
		_size = _capacity = 0;
	}
}
mystring::string& mystring::string::operator=(const string& s) {
	if (this != &s) {
		_size = s._size;
		_capacity = s._capacity;
		char* temp = new char[_capacity + 1];
		memcpy(temp, s._str, _size + 1);
		delete[] _str;
		_str = temp;
	}
	return *this;
}
mystring::string& mystring::string::operator=(mystring::string tmp)
{
	swap(tmp);
	return *this;
}

// 迭代器
mystring::string::iterator mystring::string::begin() {
	return _str;
}
mystring::string::iterator mystring::string::end() {
	return _str + _size;
}
mystring::string::const_iterator mystring::string::begin()const {
	return _str;
}
mystring::string::const_iterator mystring::string::end()const {
	return _str + _size;
}

// 容量操作函数
size_t mystring::string::size()const {
	return _size;
}
void mystring::string::reserve(size_t n) {
	if (n > _capacity) {
		char* temp = new char[n + 1];
		memcpy(temp, _str, _size + 1);
		delete[] _str;
		_str = temp;
		_capacity = n;
	}
}
void mystring::string::resize(size_t n, char c) {
	if (n <= _size) {
		_size = n;
		_str[_size] = '\0';
	}
	else {
		reserve(n);
		for (size_t i = _size; i < n; i++)
			_str[i] = c;
		_size = n;
		_str[_size] = '\0';
	}
}
void mystring::string::clear() {
	_str[0] = '\0';
	_size = 0;
}

// 修改字符串函数
void mystring::string::push_back(char c) {
	if (_size == _capacity) {
		reserve(_capacity == 0 ? 4 : 2 * _capacity);
	}
	_str[_size] = c;
	++_size;
	_str[_size] = '\0';
}
void mystring::string::append(const char* str) {
	size_t len = strlen(str);
	if (_size + len > _capacity) {
		reserve(_size + len);
	}
	memcpy(_str + _size, str, len + 1);
	_size += len;
}
mystring::string& mystring::string::operator+=(char ch) {
	push_back(ch);
	return *this;
}
mystring::string& mystring::string::operator+=(const char* str) {
	append(str);
	return *this;
}
void mystring::string::insert(size_t pos, size_t n, char c) {
	assert(pos <= _size);
	if (_size + n > _capacity) {
		reserve(_size + n);
	}
	size_t end = _size;
	while (end != npos && end >= pos) {
		_str[end + n] = _str[end];
		end--;
	}
	for (size_t i = pos; i < pos + n; i++)
		_str[i] = c;
	_size += n;
}
void mystring::string::insert(size_t pos, const char* str) {
	assert(pos <= _size);
	size_t len = strlen(str);
	if (_size + len > _capacity) {
		reserve(_size + len);
	}
	size_t end = _size;
	while (end != npos && end >= pos) {
		_str[end + len] = _str[end];
		end--;
	}
	for (size_t i = pos; i < pos + len; i++)
		_str[i] = str[i - pos];
	_size += len;
}
void mystring::string::erase(size_t pos, size_t len) {
	assert(pos < _size);
	if (len == npos || pos + len >= _size) {
		_size = pos;
		_str[_size] = '\0';
	}
	else {
		for (size_t i = pos; i < len + pos; i++) {
			_str[i] = _str[i + len];
		}
		_size -= len;
		_str[_size] = '\0';
	}
}
void mystring::string::swap(mystring::string& s)
{
	std::swap(_str, s._str);
	std::swap(_size, s._size);
	std::swap(_capacity, s._capacity);
}

// 访问字符串函数
const char* mystring::string::c_str()const {
	return _str;
}
char& mystring::string::operator[](size_t pos) {
	assert(pos < _size);
	return _str[pos];
}
const char& mystring::string::operator[](size_t pos)const {
	assert(pos < _size);
	return _str[pos];
}
size_t mystring::string::find(char ch, size_t pos) {
	assert(pos < _size);
	for (size_t i = pos; i < _size; i++)
		if (_str[i] == ch)
			return i;
	return npos;
}
size_t mystring::string::find(const char* str, size_t pos) {
	assert(pos < _size);
	const char* ptr = strstr(_str + pos, str);
	if (ptr == NULL)
		return npos;
	else
		return ptr - _str;
}
mystring::string mystring::string::substr(size_t pos, size_t len) {
	assert(pos < _size);
	size_t n = len;
	string temp;
	if (len == npos || len + pos > _size)
		n = _size - pos;
	temp.reserve(n);
	for (size_t i = pos; i < pos + n; i++)
		temp += _str[i];
	return temp;
}

// 关系操作符重载
bool mystring::string::operator<(const string& s) const {
	int ret = memcmp(_str, s._str, _size < s._size ? _size : s._size);
	return ret == 0 ? _size < s._size : ret < 0;
}
bool mystring::string::operator==(const string& s) const {
	return _size == s._size && memcmp(_str, s._str, _size) == 0;
}
bool mystring::string::operator<=(const string& s) const {
	return *this < s || *this == s;
}
bool mystring::string::operator>(const string& s) const {
	return !(*this <= s);
}
bool mystring::string::operator>=(const string& s) const {
	return !(*this < s);
}
bool mystring::string::operator!=(const string& s) const {
	return !(*this == s);
}

// npos
const size_t mystring::string::npos = -1;
// 不能在头文件定义，因为如果在头文件定义，string.cpp和main.cpp都展开string.h的话会造成重定义

// 流插入和流提取
ostream& mystring::operator<<(ostream& out, const mystring::string& s) {
	for (auto ch : s)
		cout << ch;
	return out;
}
istream& mystring::operator>>(istream& in, mystring::string& s) {
	s.clear();
	char ch = in.get();
	while (ch == ' ' || ch == '\n')
		ch = in.get();
	char buf[128];
	int i = 0;
	while (ch != ' ' && ch != '\n') {
		buf[i++] = ch;
		if (i == 127) {
			buf[i] = '\0';
			s += buf;
			i = 0;
		}
		ch = in.get();
	}
	if (i != 0) {
		buf[i] = '\0';
		s += buf;
	}
	return in;
}
```

# vector

## 标准库中的vector类

### vector类介绍

![image-20240610141123555](F:/cs/note/images/image-20240610141123555.png)

1. vector是表示可变大小数组的序列容器。
2. 就像数组一样，vector也采用的连续存储空间来存储元素。也就是意味着可以采用下标对vector的元素 进行访问，和数组一样高效。但是又不像数组，它的大小是可以动态改变的，而且它的大小会被容器自动处理。
3. 本质讲，vector使用动态分配数组来存储它的元素。当新元素插入时候，这个数组需要被重新分配大小为了增加存储空间。其做法是，分配一个新的数组，然后将全部元素移到这个数组。就时间而言，这是 一个相对代价高的任务，因为每当一个新的元素加入到容器的时候，vector并不会每次都重新分配大 小。
4. vector分配空间策略：vector会分配一些额外的空间以适应可能的增长，因为存储空间比实际需要的存储空间更大。不同的库采用不同的策略权衡空间的使用和重新分配。但是无论如何，重新分配都应该是对数增长的间隔大小，以至于在末尾插入一个元素的时候是在常数时间的复杂度完成的。
5. 因此，vector占用了更多的存储空间，为了获得管理存储空间的能力，并且以一种有效的方式动态增长。
6. 与其它动态序列容器相比（deque, list and forward_list），vector在访问元素的时候更加高效，在末尾添加和删除元素相对高效。对于其它不在末尾的删除和插入操作，效率更低。比起list和forward_list 统一的迭代器和引用更好。

### vector类的常见接口使用

1. 构造函数
   ![image-20240610142230246](F:/cs/note/images/image-20240610142230246.png)

   ```c++
   void test_vector1() {
   	vector<int> v1;
   	vector<int> v2(10, 1);
   	vector<int> v3(v2);
   	//迭代器构造的多种用法
   	vector<int> v4(v2.begin(), v2.end());
   	string s("abcdef");
   	vector<int> v5(s.begin(), s.end());
   	int arr[10] = { 1,2,3,4,5,6,7,8,9,0 };
   	vector<int> v6(arr, arr + sizeof(arr) / sizeof(arr[0]));
   }
   ```

2. 访问及遍历操作

   | 函数名称       | 功能说明                                   |
   | -------------- | ------------------------------------------ |
   | **operator[]** | 返回pos位置的字符，const string类对象调用  |
   | at()           | 返回pos位置的字符，const string类对象调用  |
   | **迭代器**     | **begin() + end() 或者 rbegin() + rend()** |
   | 范围for        | C++11支持更简洁的范围for的新遍历方式       |

3. 容量操作

   | 函数名称    | 接口说明               |
   | ----------- | ---------------------- |
   | size        | 获取数据个数           |
   | capacity    | 获取容量大小           |
   | **resize**  | 调整容器的有效元素大小 |
   | **reserve** | 调整容器的容量大小     |
   | empty       | 判断容器是否为空       |

   ```c++
   void test_vector2() {
   	// reserve扩容易错点：reserve只扩容不修改内容，扩容后_size依然为0，此时通过[]访问会断言
   	vector<int> v1;
   	v1.reserve(10);
   	for (size_t i = 0; i < 10; i++) {
   		v1[i] = i + 1;
   	}
   
   	//正确的写法
   	vector<int> v2;
   	v2.resize(10);
   	for (size_t i = 0; i < 10; i++) {
   		v2[i] = i + 1;
   	}
   	vector<int> v3;
   	v3.reserve(10);
   	for (size_t i = 0; i < 10; i++) {
   		v3.push_back(i + 1);
   	}
   }
   ```

4. 修改操作

   | 函数名称      | 接口说明                                             |
   | ------------- | ---------------------------------------------------- |
   | **push_back** | 尾插                                                 |
   | **pop_back**  | 尾删                                                 |
   | find          | 查找（注意这个是算法模块实现，不是vector的成员接口） |
   | insert        | 在pos之前插入val                                     |
   | erase         | 删除position位置的数据                               |
   | swap          | 交换两个vector的数据空间                             |

   ```c++
   void test_vector3() {
   	vector<int> v;
   	v.reserve(10);
   	for (size_t i = 0; i < 10; i++) {
   		v.push_back(i + 1);
   	}
   	vector<int>::iterator pos = find(v.begin(), v.end(), 5);
   	v.insert(pos, -1);
   	for (auto p : v)
   		cout << p << " ";
   	cout << endl;
   	pos = find(v.begin(), v.end(), 8);
   	v.erase(pos);
   	for (auto p : v)
   		cout << p << " ";
   	cout << endl;
   }
   ```

5. **迭代器失效问题（重点）**
   迭代器的主要作用就是让算法能够不用关心底层数据结构，其底层实际就是一个指针，或者是对指针进行了 封装，比如：**vector的迭代器就是原生态指针T*** 。因此**迭代器失效，实际就是迭代器底层对应指针所指向的空间被销毁了，而使用一块已经被释放的空间**，造成的后果是程序崩溃(即如果继续使用已经失效的迭代器， 程序可能会崩溃)。
   对于vector可能会导致其迭代器失效的操作有：

   1. **会引起其底层空间改变的操作，都有可能是迭代器失效**，比如：resize、reserve、insert、assign、 push_back等。

      ```c++
      void test1()
      {
      	// 将有效元素个数增加到100个，多出的位置使用8填充，操作期间底层会扩容
      	vector<int> v1{ 1,2,3,4,5,6 };
      	auto it1 = v1.begin();
      	v1.resize(100);
      
      	// reserve的作用就是改变扩容大小但不改变有效元素个数，操作期间可能会引起底层容量改变
      	vector<int> v2{ 1,2,3,4,5,6 };
      	auto it2 = v2.begin();
      	v2.reserve(100);
      
      	// 插入元素期间，可能会引起扩容，而导致原空间被释放
      	vector<int> v3{ 1,2,3,4 };
      	auto it3 = v3.begin();
      	v3.insert(v3.begin(), 0);
      	v3.push_back(8);
      
      	// 给vector重新赋值，可能会引起底层容量改变
      	vector<int> v4{ 1,2,3,4 };
      	auto it4 = v4.begin();
      	v4.assign(100, 8);
      }
      ```

      出错原因：**以上操作，都有可能会导致vector扩容，也就是说vector底层原理旧空间被释放掉，而在打印时，it还使用的是释放之间的旧空间，在对it迭代器操作时，实际操作的是一块已经被释放的空间，而引起代码运行时崩溃。**
      解决方式：在以上操作完成之后，如果想要继续通过迭代器操作vector中的元素，只需给it重新赋值即可。

   2. **指定位置元素的删除操作**，erase

      ```c++
      void test2()
      {
      	vector<int> v{ 1,2,3,4 };
      	// 使用find查找3所在位置的iterator
      	vector<int>::iterator pos = find(v.begin(), v.end(), 3);
      	// 删除pos位置的数据，导致pos迭代器失效。
      	v.erase(pos);
      	cout << *pos << endl; // 此处会导致非法访问
      }
      ```

      erase删除pos位置元素后，pos位置之后的元素会往前搬移，没有导致底层空间的改变，理论上讲迭代 器不应该会失效，但是：**如果pos刚好是最后一个元素，删完之后pos刚好是end的位置，而end位置是没有元素的，那么pos就失效了。**因此删除vector中任意位置上元素时，vs就认为该位置迭代器失效了。

      ```c++
      void test_erase1()
      {
      	vector<int> v{ 1, 2, 2, 3, 4 };
      	auto it = v.begin();
      	while (it != v.end())
      	{
      		if (*it % 2 == 0)
      			v.erase(it);
      		++it;
      	}
      }
      //无法删除相连的偶数
      
      void test_erase2()
      {
      	vector<int> v{ 1, 2, 2, 3, 4 };
      	auto it = v.begin();
      	while (it != v.end())
      	{
      		if (*it % 2 == 0)
      			v.erase(it);
      		else
      			++it;
      	}
      }
      // 代码在g++平台能跑，在VS平台不能跑，在VS编译器下，erase后迭代器失效不能再访问
      
      void test_erase3()
      {
      	vector<int> v{ 1, 2, 3, 4 };
      	auto it = v.begin();
      	while (it != v.end())
      	{
      		if (*it % 2 == 0)
      			it = v.erase(it);
      		else
      			++it;
      	}
      }
      // 重新给迭代器赋值erase调用后的返回值，可避免erase迭代器失效问题
      ```

   3. 注意：Linux下，g++编译器对迭代器失效的检测并不是非常严格，处理也没有vs下极端。

      ```c++
      // 1. 扩容之后，迭代器已经失效了，程序虽然可以运行，但是运行结果已经不对了
      int main()
      {
           vector<int> v{1,2,3,4,5};
           for(size_t i = 0; i < v.size(); ++i)
           	cout << v[i] << " ";
           cout << endl;
           auto it = v.begin();
           cout << "扩容之前，vector的容量为: " << v.capacity() << endl;
           // 通过reserve将底层空间设置为100，目的是为了让vector的迭代器失效 
           v.reserve(100);
           cout << "扩容之后，vector的容量为: " << v.capacity() << endl;
      
           // 经过上述reserve之后，it迭代器肯定会失效，在vs下程序就直接崩溃了，但是linux下不会
           // 虽然可能运行，但是输出的结果是不对的
           while(it != v.end())
           {
               cout << *it << " ";
               ++it;
           }
           cout << endl;
           return 0;
      }
      程序输出：
      1 2 3 4 5
      扩容之前，vector的容量为: 5
      扩容之后，vector的容量为: 100
      0 2 3 4 5 409 1 2 3 4 5
      
      // 2. erase删除任意位置代码后，linux下迭代器并没有失效
      // 因为空间还是原来的空间，后序元素往前搬移了，it的位置还是有效的
      #include <vector>
      #include <algorithm>
      int main()
      {
           vector<int> v{1,2,3,4,5};
           vector<int>::iterator it = find(v.begin(), v.end(), 3);
           v.erase(it);
          cout << *it << endl;
           while(it != v.end())
           {
           	cout << *it << " ";
               ++it;
           }
           cout << endl;
           return 0;
      }
      程序可以正常运行，并打印：
      4
      4 5
      
      // 3: erase删除的迭代器如果是最后一个元素，删除之后it已经超过end
      // 此时迭代器是无效的，++it导致程序崩溃
      int main()
      {
           vector<int> v{1,2,3,4,5};
           // vector<int> v{1,2,3,4,5,6};
           auto it = v.begin();
           while(it != v.end())
           {
               if(*it % 2 == 0)
               v.erase(it);
               ++it;
           }
           for(auto e : v)
           	cout << e << " ";
           cout << endl;
           return 0;
      }
      ========================================================
      // 使用第一组数据时，程序可以运行
      [sly@VM-0-3-centos 20220114]$ g++ testVector.cpp -std=c++11
      [sly@VM-0-3-centos 20220114]$ ./a.out
      1 3 5
      =========================================================
      // 使用第二组数据时，程序最终会崩溃
      [sly@VM-0-3-centos 20220114]$ vim testVector.cpp
      [sly@VM-0-3-centos 20220114]$ g++ testVector.cpp -std=c++11
      [sly@VM-0-3-centos 20220114]$ ./a.out
      Segmentation fault
      ```

      从上述三个例子中可以看到：SGI STL中，迭代器失效后，代码并不一定会崩溃，但是运行结果肯定不对，如果it不在begin和end范围内，肯定会崩溃的。

   4. 与vector类似，string在插入+扩容操作+erase之后，迭代器也会失效

      ```c++
      #include <string>
      void TestString()
      {
           string s("hello");
           auto it = s.begin();
           // 放开之后代码会崩溃，因为resize到20会string会进行扩容
           // 扩容之后，it指向之前旧空间已经被释放了，该迭代器就失效了
           // 后序打印时，再访问it指向的空间程序就会崩溃
           s.resize(20, '!');
           while (it != s.end())
           {
               cout << *it;
               ++it;
           }
           cout << endl;
           it = s.begin();
           while (it != s.end())
           {
               it = s.erase(it);
               // 按照下面方式写，运行时程序会崩溃，因为erase(it)之后
               // it位置的迭代器就失效了
               // s.erase(it); 
               ++it;
           }
      }
      ```

### OJ练习



## 模拟实现vector

类模板声明与定义不能分离，详见模板进阶。

```c++
#pragma once
#include<vector>
#include<string>
#include<iostream>
#include<algorithm>
#include<assert.h>
using namespace std;
namespace myvector
{
	template<class T>
	class vector 
	{
	public:
		// 默认成员函数
		vector() {}
		vector(size_t n, const T& val) {
			resize(n, val);
		}
		template<class InputIterator>
		vector(InputIterator first, InputIterator last) {
			while (first != last) {
				push_back(*first);
				++first;
			}
		}
		vector(const vector<T>& x) {
			vector<T> _start = new T[x.capacity()];
			for (size_t i = 0; i < x.size(); i++)
				_start[i] = x._start[i];
			_finish = _start + x.size();
			_endofstorage = _start + x.capacity();
		}
		vector<T>& operator= (vector<T> x) {
			swap(x);
			return *this;
		}
		~vector() {
			if (_start) {
				delete[] _start;
				_start = _finish = _endofstorage = nullptr;
			}
		}

		// 迭代器
		typedef T* iterator;
		typedef const T* const_iterator;
		iterator begin() {
			return _start;
		}
		iterator end() {
			return _finish;
		}
		const_iterator begin() const {
			return _start;
		}
		const_iterator end() const {
			return _finish;
		}

		//容量和大小函数
		size_t size() const {
			return _finish - _start;
		}
		size_t capacity() const {
			return _endofstorage - _start;
		}
		void reserve(size_t n) {
			if (n > capacity()) {
				size_t sz = size();
				T* temp = new T[n];
				if (_start) {
					//memcpy(temp, _start, sz); //如果这里用memcpy那遇到string类就是浅拷贝
					for (size_t i = 0; i < sz; i++) {
						temp[i] = *(_start + i);
					}
					delete[] _start;
				}
				_start = temp;
				_finish = temp + sz;
				_endofstorage = _start + n;
			}
		}
		void resize(size_t n, const T& val) {
			if (n < size()) {
				_finish = _start + n;
			}
			else {
				reserve(n);
				while (_finish != _endofstorage) {
					*_finish = val;
					++_finish;
				}
			}
		}
		// 对T()的解释：
		// T 如果是string类，就可能调用string类的默认构造
		// T 如果是内置类型也是有默认构造的，C++对其进行了升级

		//修改函数
		void push_back(const T& x) {
			if (_finish == _endofstorage) {
				size_t newcapacity = capacity() == 0 ? 4 : capacity() * 2;
				reserve(newcapacity);
			}
			*_finish = x;
			++_finish;
		}
		void pop_back() {
			if (_finish != _start)
				--_finish;
		}
		typename iterator insert(iterator pos, const T& x) {
			assert(pos >= _start && pos <= _finish);
			if (_finish == _endofstorage) {
				size_t len = pos - _start;// 解决pos迭代器失效问题
				size_t newcapacity = capacity() == 0 ? 4 : capacity() * 2;
				reserve(newcapacity);
				pos = _start + len;
			}
			iterator temp = _finish;
			while (temp != pos) {
				*(temp + 1) = *temp;
				temp--;
			}
			*pos = x;
			++_finish;
			return pos;
		}
		iterator erase(iterator pos) {
			assert(pos >= _start && pos < _finish);
			iterator temp = pos + 1;
			while (temp != _finish) {
				*(temp - 1) = *temp;
				temp++;
			}
			--_finish;
			return pos;
		}
		void swap(vector<T>& v) {
			std::swap(_start, v._start);
			std::swap(_finish, v._finish);
			std::swap(_endofstorage, v._endofstorage);
		}

		//访问函数
		T& operator[](size_t pos) {
			assert(pos < size());
			return _start[pos];
		}
		const T& operator[](size_t pos)const {
			assert(pos < size());
			return _start[pos];
		}
	private:
		iterator _start = nullptr;
		iterator _finish = nullptr;
		iterator _endofstorage = nullptr;
	};
}
```

假设模拟实现的vector中的reserve接口中，使用memcpy进行的拷贝，会发生什么问题？

1. memcpy是内存的二进制格式拷贝，将一段内存空间中内容原封不动的拷贝到另外一段内存空间中
2. 如果拷贝的是内置类型的元素，memcpy既高效又不会出错，但**如果拷贝的是自定义类型元素，并且自定义类型元素中涉及到资源管理时，就会出错，因为memcpy的拷贝实际是浅拷贝**。

<img src="F:/cs/note/images/image-20240611210615664.png" alt="image-20240611210615664" style="zoom: 40%;" />

<img src="F:/cs/note/images/image-20240611210643555.png" alt="image-20240611210643555" style="zoom: 33%;" />

<img src="F:/cs/note/images/image-20240611210708512.png" alt="image-20240611210708512" style="zoom: 33%;" />

# list

