# C++入门

## C++关键字

<img src="C:\Users\q9384\AppData\Roaming\Typora\typora-user-images\image-20240522195341552.png" alt="image-20240522195341552" style="zoom:50%;" />

## 命名空间

在C/C++中，变量、函数和后面要学到的类都是大量存在的，这些变量、函数和类的名称将都存在于全局作用域中，可能会导致很多冲突。使用命名空间的目的是**对标识符的名称进行本地化， 以避免命名冲突或名字污染**，namespace关键字的出现就是针对这种问题的。

```c
#include <stdio.h>
#include <stdlib.h>
int rand = 10;
//stdlib.h中存在rand()函数
// C语言没办法解决类似这样的命名冲突问题，所以C++提出了namespace来解决
int main()
{
	printf("%d\n", rand);
	return 0;
}
// 编译后后报错：error C2365: “rand”: 重定义；以前的定义是“函数”
```

### 命名空间定义

```c
//1.正常的命名空间定义
namespace bit	//bit为命名空间的名字
{
	// 命名空间中可以定义变量/函数/类型
	int rand = 10;
	int Add(int left, int right)
	{
		return left + right;
	}
	struct Node
	{
		struct Node* next;
		int val;
	};
}

//2.命名空间可以嵌套
// test.cpp
namespace N1
{
	int a;
	int b;
	int Add(int left, int right)
	{
		return left + right;
	}
	namespace N2
	{
		int c;
		int d;
		int Sub(int left, int right)
		{
			return left - right;
		}
	}
}

//3.同一个工程中允许存在多个相同名称的命名空间，编译器最后会合成同一个命名空间中。
// ps：一个工程中的test.h和上面test.cpp中两个N1会被合并成一个
// test.h
namespace N1
{
	int Mul(int left, int right)
	{
		return left * right;
	}
}
```

> 注意：**一个命名空间就定义了一个新的作用域**，命名空间中的所有内容都局限于该命名空间中

### 命名空间使用

访问不同作用域中的重名变量的优先级：局部变量 -> 全局变量 -> 命名空间

```c
//局部变量 -> 全局变量 -> 命名空间
#include<iostream>
using std::endl;
using std::cout;
namespace zt {
	int a = 3;
}
int a = 2;
int main() {
	int a = 1;
	cout << a << endl;		//1 //访问局部变量a
	cout << ::a << endl;	//2 //访问全局变量a
	cout << zt::a << endl;	//3 //指定访问命名空间中的a
	//命名空间中的变量需要展开或者指定访问，否则也不会使用
	return 0;
}
```

命名空间的使用有三种方式：

1. **加命名空间名称及作用域限定符**

   ```c
   int main()
   {
       printf("%d\n", N::a);
       return 0;    
   }
   ```

2. **使用using将命名空间中某个成员引入**

   ```c
   using N::b;
   int main()
   {
       printf("%d\n", N::a);
       printf("%d\n", b);
       return 0;    
   }
   ```

3. **使用using namespace 命名空间名称，引入命名空间中的全部变量/函数/类型**

   ```c
   using namespce N;
   int main()
   {
       printf("%d\n", N::a);
       printf("%d\n", b);
       Add(10, 20);
       return 0;    
   }
   ```

## C++输入&输出

1. 使用**`cout`标准输出对象(控制台)**和**`cin`标准输入对象(键盘)**时，必须包含`<iostream>`头文件以及按命名空间使用方法使用std。
2. `cout`和`cin`是全局的流对象，`endl`是特殊的C++符号，表示换行输出，他们都包含在包含`<iostream>`头文件中。
3. **<<是流插入运算符，>>是流提取运算符**。
4. 使用C++输入输出更方便，不需要像`printf/scanf`输入输出时那样，需要手动控制格式。 **C++的输入输出可以自动识别变量类型**。
5. 实际上`cout`和`cin`分别是`ostream`和`istream`类型的对象，`>>`和`<<`也涉及运算符重载等知识，这里只是简单学习他们的使用。

> 注意：早期标准库将所有功能在全局域中实现，声明在.h后缀的头文件中，使用时只需包含对应头文件即可，后来将其实现在std命名空间下，为了和C头文件区分，也为了正确使用命名空间， 规定C++头文件不带.h；旧编译器(vc 6.0)中还支持格式，后续编译器已不支持，因 此推荐使用+std的方式。

```c
#include <iostream>
using namespace std;
int main()
{
    int a;
    double b;
    char c;
    cin >> a;
    cin >> b >> c;
    cout << a << endl;
    cout << b << " " << c << endl;
    return 0;
}
// ps：关于cout和cin还有很多更复杂的用法，比如控制浮点数输出精度，控制整形输出进制格式等。因为C++兼容C语言的用法，这些又用得不是很多，所以建议使用scanf和printf控制格式。
```

> std命名空间的使用惯例： std是C++标准库的命名空间，如何展开std使用更合理呢？ 
>
> 1. 在日常练习中，建议直接using namespace std即可，这样就很方便。 
> 2. `using namespace std;` 展开，标准库就全部暴露出来了，如果我们定义跟库重名的类型/对象/函数，就存在冲突问题。该问题在日常练习中很少出现，但是项目开发中代码较多、规模大，就很容易出现。所以建议在项目开发中使用，像`std::cout`这样使用时指定命名空间 +  `using std::cout;`展开常用的库对象/类型等方式。

## 缺省函数

### 缺省函数概念

缺省参数是**声明或定义函数时为函数的参数指定一个缺省值**。在调用该函数时，如果没有指定实 参则采用该形参的缺省值，否则使用指定的实参。

```c
#include<iostream>
using namespace std;
void Func(int a = 0)
{
	cout << a << endl;
}
int main()
{
	Func();     //0 //没有传参时，使用参数的默认值
	Func(10);   //10 //传参时，使用指定的实参
	return 0;
}
```

### 缺省函数分类

1. **全缺省函数**

   ```c
   #include<iostream>
   using namespace std;
   void Func(int a = 10, int b = 20, int c = 30)
   {
   	cout << a << " ";
   	cout << b << " ";
   	cout << c << endl;
   }
   int main()
   {
   	Func();			//10 20 30
   	Func(1);		//1 20 30
   	Func(1, 2);		//1 2 30
   	Func(1, 2, 3);	//1 2 3
   	return 0;
   }
   ```

2. **半缺省函数**

   ```c
   #include<iostream>
   using namespace std;
   void Func(int a, int b = 20, int c = 30)
   {
   	cout << a << " ";
   	cout << b << " ";
   	cout << c << endl;
   }
   int main()
   {
   	//Func();		//error
   	Func(1);		//1 20 30
   	Func(1, 2);		//1 2 30
   	Func(1, 2, 3);	//1 2 3
   	return 0;
   }
   ```

> 注意：
>
> 1. 半缺省参数必须从右往左依次来给出，不能间隔着给
>
>    ```c
>    void Func1(int a, int b, int c = 30);		// ok
>    void Func2(int a, int b = 20, int c = 30);	// ok
>    void Func3(int a = 10, int b, int c = 30);	// error
>    void Func4(int a = 10, int b, int c);		// error
>    void Func5(int a = 10, int b = 20, int c);	// error
>    void Func6(int a, int b = 20, int c);		// error
>    ```
>
> 2. 缺省参数不能在函数声明和定义中同时出现
>
>    ```c
>    //a.h
>    void Func(int a = 10);
>    // a.cpp
>    void Func(int a = 20)
>     {}
>    // 注意：如果生命与定义位置同时出现，恰巧两个位置提供的值不同，那编译器就无法确定到底该用那个缺省值。
>    ```
>
> 3. 缺省值必须是常量或者全局变量
>
> 4. C语言不支持（编译器不支持）

## 函数重载

### 函数重载的概念

函数重载：是函数的一种特殊情况，C++允许在**同一作用域**中声明几个功能类似的**同名函数**，这些同名函数的**形参列表(参数个数 或 类型 或 类型顺序)不同**，常用来处理实现功能类似数据类型不同的问题。

```c
#include<iostream>
using namespace std;
// 1. 参数类型不同
int Add(int left, int right)
{
	cout << "int Add(int left, int right)" << endl;
	return left + right;
}
double Add(double left, double right)
{
	cout << "double Add(double left, double right)" << endl;
	return left + right;
}
// 2. 参数个数不同
void f()
{
	cout << "f()" << endl;
}
void f(int a)
{
	cout << "f(int a)" << endl;
}
// 3. 参数类型顺序不同
void f(int a, char b)
{
	cout << "f(int a,char b)" << endl;
}
void f(char a, int b)
{
	cout << "f(char a, int b)" << endl;
}
int main()
{
	Add(10, 20);
	Add(10.1, 20.2);
	f();
	f(10);
	f(10, 'a');
	f('a', 10);
	return 0;
}
```

### C++支持函数重载的原理--名字修饰(name Mangling)

为什么C++支持函数重载，而C语言不支持函数重载呢？

<img src="C:\Users\q9384\AppData\Roaming\Typora\typora-user-images\image-20240522221037439.png" alt="image-20240522221037439" style="zoom: 50%;" />

编译后链接前，链接器看到Test.o调用Sum，但是没有Sum的地址，就 会到Sum.o的符号表中找Sum的地址，然后链接到一起。

采用C语言编译器编译后，在linux下，采用gcc编译完成后，函数名字的修饰没有发生改变。

采用C++编译器编译后结果在linux下，采用g++编译完成后，函数名字的修饰发生改变，编译器将函数参 数类型信息添加到修改后的名字中。

通过这里就理解了C语言没办法支持重载，因为同名函数没办法区分。而C++是通过函数修 饰规则来区分，只要参数不同，修饰出来的名字就不一样，就支持了重载。

> **如果两个函数函数名和参数是一样的，返回值不同是不构成重载的，因为调用时编译器没办法区分。**

## 引用

### 引用的概念

引用不是新定义一个变量，而是**给已存在变量取了一个别名**，编译器不会为引用变量开辟内存空间，它和它引用的变量**共用同一块内存空间**。

**类型& 引用变量名(对象名) = 引用实体；**

```c
void TestRef()
{
    int a = 10;
    int& ra = a;		//定义引用类型
    printf("%p\n", &a);
    printf("%p\n", &ra);
}
```

> **注意：引用类型必须和引用实体是同种类型的**

### 引用特性

1. 引用**在定义时必须初始化**
2. 一个变量可以有多个引用
3. 引用一旦引用一个实体，**再不能引用其他实体**

```c
void TestRef()
{
	int a = 10;
	//1. 引用在定义时必须初始化
	//int& ra;   // 编译error
	int& ra = a;

	//2. 一个变量可以有多个引用
	int& rra = a;
	int& rrra = rra;
	std::cout << &a << std::endl << &ra << std::endl << &rra << std::endl << &rrra << std::endl;

	//3. 引用一旦引用一个实体，再不能引用其他实体
	int b = 20;
	ra = b;	//这个语句并不是引用b，而是将b的值拷贝给a
	std::cout << a << std::endl << ra << std::endl;

	int* p = &b;
	int*& rp = p;
	std::cout << p << std::endl << rp << std::endl;
}
```

### 使用场景

1. **引用变量做参数**
   引用可以做函数的参数，作用相当于指针，可以改变变量本身。

   ```c
   void Swap(int& left, int& right)
   {
      int temp = left;
      left = right;
      right = temp;
   }
   ```

2. **引用变量做返回值**

   ```c
   //值返回
   int Count() {
   	static int n = 0;;
   	n++;
   	return n;
   }
   //临时变量n存放在内存中的静态区，不会随函数执行结束而销毁
   int Count() {
   	int n = 0;;
   	n++;
   	return n;
   }
   //临时变量n存放在内存中的栈区，会随函数执行结束而销毁
   int main() {
   	int ret = Count();
   	return 0;
   }
   //但是不论栈区还是静态区的变量返回都需要将返回值存放在一个临时变量（寄存器）中，然后拷贝给main函数中的变量
   ```

   有没有办法不通过临时变量返回返回值呢？那就是引用返回

   ```c
   //正确的引用返回
   int& Count() {
   	static int n = 0;;
   	n++;
   	return n;
   }
   //对于引用返回来说就不会产生这个临时变量了，返回的只是n的别名，相当于就是把n返回回去了，
   //对于函数栈帧销毁依旧存在的内容，如果不想让其拷贝到临时变量中进行返回，是可以通过引用来进行返回的，这样就可以减少拷贝，对程序做了一小部分的优化
   int main() {
   	int& ret = Count();
   	return 0;
   }
   ```

   ```c
   //错误的引用返回
   int& Count() {
   	int n = 0;;
   	n++;
   	return n;
   }
   int main() {
   	int& ret = Count();
   	return 0;
   }
   //这里打印ret的值是不确定的，ret就是n的别名，但是Count函数已经销毁
   //如果Count函数结束，栈帧销毁没有清理栈帧，那么ret的结果侥幸是正确的
   //如果Count函数结束，栈帧销毁清理栈帧，那么ret的结果是随机值
   //例如：
   #include<iostream>
   int& Add(int a, int b)
   {
       int c = a + b;
       return c;
   }
   int main()
   {
       int& ret = Add(1, 2);
       Add(3, 4);
       std::cout << "Add(1, 2) is :" << ret << std::endl;
       //Add(1, 2) is :-858993460
       return 0;
   }
   ```

   > 注意：如果函数返回时，出了函数作用域，如果返回对象还在(还没还给系统)，则可以使用 引用返回，如果已经还给系统了，则必须使用传值返回

> 总结：
>
> 1. 引用做参数 ，做输出型参数，节省空间
>
> 2. 引用做参数  ，当传过来的形参是大对象/深拷贝对象时，能够极大地提高效率。
>
> 3. 引用做返回值 ，返回值不需要通过临时变量返回，减少拷贝提高效率，尤其是返回大对象/深拷贝类对象
>
> 4. 引用做返回值，可以通过引用返回修改返回值+获取返回值
>
>    ```c
>    #include<iostream>
>    #include<assert.h>
>    struct SeqList { int a[100]; };
>    int SLGet(SeqList* ps, int pos) {
>    	assert(pos < 100 && pos >= 0);
>    	return ps->a[pos];
>    }
>    void SLModify(SeqList* ps, int pos, int x) {
>    	assert(pos < 100 && pos >= 0);
>    	ps->a[pos] = x;
>    }
>    int& SLAt(SeqList* ps, int pos) {
>    	assert(pos < 100 && pos >= 0);
>    	return ps->a[pos];
>    }
>    int main() {
>    	SeqList s;
>       
>    	SLModify(&s, 0, 1);
>    	int ret = SLGet(&s, 0);
>    	std::cout << ret << std::endl;
>    	SLModify(&s, 0, ret + 5);
>       
>    	//通过引用返回就能实现读写
>    	SLAt(&s, 0) = 1;
>    	std::cout << SLAt(&s, 0) << std::endl;
>    	SLAt(&s, 0) += 5;
>       
>    	return 0;
>    }
>    ```

###  传值、传引用效率比较

以值作为参数或者返回值类型，在传参和返回期间，函数不会直接传递实参或者将变量本身直 接返回，而是传递实参或者返回变量的一份临时的拷贝，因此用值作为参数或者返回值类型，效 率是非常低下的，尤其是当参数或者返回值类型非常大时，效率就更低。

1. **值和引用的作为函数参数类型的性能比较**

   ```c
   #include<iostream>
   #include <time.h>
   struct A { int a[10000]; };
   void TestFunc1(A a) {}
   void TestFunc2(A& a) {}
   void TestRefAndValue()
   {
   	A a;
   	// 以值作为函数参数
   	size_t begin1 = clock();
   	for (size_t i = 0; i < 10000; ++i)
   		TestFunc1(a);
   	size_t end1 = clock();
   	// 以引用作为函数参数
   	size_t begin2 = clock();
   	for (size_t i = 0; i < 10000; ++i)
   		TestFunc2(a);
   	size_t end2 = clock();
   	// 分别计算两个函数运行结束后的时间
   	std::cout << "TestFunc1(A)-time:" << end1 - begin1 << std::endl;
   	std::cout << "TestFunc2(A&)-time:" << end2 - begin2 << std::endl;
   }
   int main() {
   	TestRefAndValue();
   	return 0;
   }
   //TestFunc1(A)-time:8
   //TestFunc2(A&)-time:0
   ```

2. **值和引用的作为返回值类型的性能比较**

   ```c
   #include<iostream>
   #include <time.h>
   struct A { int a[10000]; };
   A a;
   // 值返回
   A TestFunc1() { return a; }
   // 引用返回
   A& TestFunc2() { return a; }
   void TestReturnByRefOrValue()
   {
   	// 以值作为函数的返回值类型
   	size_t begin1 = clock();
   	for (size_t i = 0; i < 100000; ++i)
   		TestFunc1();
   	size_t end1 = clock();
   	// 以引用作为函数的返回值类型
   	size_t begin2 = clock();
   	for (size_t i = 0; i < 100000; ++i)
   		TestFunc2();
   	size_t end2 = clock();
   	// 计算两个函数运算完成之后的时间
   	std::cout << "TestFunc1 time:" << end1 - begin1 << std::endl;
   	std::cout << "TestFunc2 time:" << end2 - begin2 << std::endl;
   }
   int main() {
   	TestReturnByRefOrValue();
   	return 0;
   }
   //TestFunc1 time : 152
   //TestFunc2 time : 0
   ```

### 常引用

```c
void TestConstRef()
{
    //1. 权限不能放大，只能缩小或平移
    const int a = 10;
    int& ra = a;        // 编译时error，a为常量，不能放大权限变为变量
    const int& ra = a;  // 权限可以平移
    int b = 20;
    const int& rb = b;  // 权限可以缩小

    //2. 可以给常量取别名
    int& c = 10;        // 编译error，c为常量
    const int& c = 10;  // 常量引用需用const

    //3. 只要发生类型转换，都会产生临时变量。而临时变量不可修改，具有常性。
    double d = 12.34;
    int& rd = d;        // 编译error，类型不同
    const int& rd = d;  // 把d的值赋给rd时并不是直接赋值的，会把d的整数部分取出来，赋值给一个int型临时变量，随后再把这个临时变量给给rd
}
```

```c
int func1()
{
	static int x = 0;
	return x;
}
int& func2()
{
	static int x = 0;
	return x;
}
int main()
{
	int& ret1 = func1();		// 权限放大，传值返回返回的是临时变量，临时变量具有常性
	const int& ret1 = func1();	// 权限平移
	int ret1 = func1();			// 拷贝

	int& ret2 = func2();		// 权限平移
	const int& rret2 = func2(); // 权限缩小

	return 0;
}
```

### 引用和指针的区别

在**语法概念**上引用就是一个别名，没有独立空间，和其引用实体共用同一块空间。

在**底层实现**上实际是有空间的，因为**引用是按照指针方式来实现的**。

<img src="C:\Users\q9384\AppData\Roaming\Typora\typora-user-images\image-20240523151214052.png" alt="image-20240523151214052" style="zoom: 50%;" />

> 引用和指针的不同点：
>
> 1. 引用概念上定义一个变量的别名，指针存储一个变量地址
> 2. 引用在定义时必须初始化，指针没有要求
> 3. 引用在初始化时引用一个实体后，就不能再引用其他实体，而指针可以在任何时候指向任何一个同类型实体
> 4. 没有NULL引用，但有NULL指针
> 5. 在sizeof中含义不同：引用结果为引用类型的大小，但指针始终是地址空间所占字节个数(32位平台下占4个字节)
> 6. 引用自加即引用的实体增加1，指针自加即指针向后偏移一个类型的大小
> 7. 有多级指针，但是没有多级引用
> 8. 访问实体方式不同，指针需要显式解引用，引用编译器自己处理
> 9. 引用比指针使用起来相对更安全

## 内联函数

### 概念

以**inline修饰的函数**叫做内联函数，**编译时C++编译器会在调用内联函数的地方展开**，没有函数调用建立栈帧的开销，内联函数提升程序运行的效率。

```c
int Add(int left, int right) {
	return left + right;
}
int main() {
	int ret = 0;
	ret = Add(2, 0);
	return 0;
}
```

<img src="C:\Users\q9384\AppData\Roaming\Typora\typora-user-images\image-20240523213101878.png" alt="image-20240523213101878" style="zoom: 50%;" />

如果在上述函数前增加inline关键字将其改成内联函数，在编译期间编译器会用函数体替换函数的调用。 

查看方式： 

1. 在release模式下，查看编译器生成的汇编代码中是否存在call Add
2. 在debug模式下，需要对编译器进行设置，否则不会展开(因为debug模式下，编译器默认不会对代码进行优化，以下给出vs2022的设置方式)

<img src="C:\Users\q9384\AppData\Roaming\Typora\typora-user-images\image-20240523213246113.png" alt="image-20240523213246113" style="zoom:50%;" />

![image-20240523213308501](C:\Users\q9384\AppData\Roaming\Typora\typora-user-images\image-20240523213308501.png)

![image-20240523213321316](C:\Users\q9384\AppData\Roaming\Typora\typora-user-images\image-20240523213321316.png)

```c
inline int Add(int left, int right) {
	return left + right;
}
int main() {
	int ret = 0;
	ret = Add(2, 0);
	return 0;
}
```

<img src="C:\Users\q9384\AppData\Roaming\Typora\typora-user-images\image-20240523213158884.png" alt="image-20240523213158884" style="zoom:50%;" />

### 特性

1. inline是一种**以空间换时间**的做法，如果编译器将函数当成内联函数处理，**在编译阶段，会用函数体替换函数调用，缺陷：可能会使目标文件变大，优势：少了调用开销，提高程序运行效率。**

2. inline对于编译器而言**只是一个建议**，不同编译器关于inline实现机制可能不同，一般建议：将**函数规模较小**(即函数不是很长，具体没有准确的说法，取决于编译器内部实现)、**不是递归、且频繁调用的函数**采用inline修饰，否则编译器会忽略inline特性。

3. inline**不建议声明和定义分离**，分离会导致链接错误。因为inline被展开，就没有函数地址了，链接就会找不到。

   ```c
   // F.h
   #include <iostream>
   using namespace std;
   inline void f(int i);
   // F.cpp
   #include "F.h"
   void f(int i)
   {
    cout << i << endl;
   }
   // main.cpp
   #include "F.h"
   int main()
   {
    f(10);
    return 0;
   }
   // 链接错误：main.obj : error LNK2019: 无法解析的外部符号 "void __cdecl f(int)" (?f@@YAXH@Z)，该符号在函数 main 中被引用
   ```

   ```c
   //建议在内联函数声明时就定义
   // F.h
   #include <iostream>
   using namespace std;
   inline void f(int i)
   {
    cout << i << endl;
   }
   // main.cpp
   #include "F.h"
   int main()
   {
    f(10);
    return 0;
   }
   ```

> `#define`定义宏与内联函数的比较
>
> 宏的优点： 1.增强代码的复用性。 2.提高性能。 
> 宏的缺点： 1.不方便调试宏。（因为预编译阶段进行了替换） 2.导致代码可读性差，可维护性差，容易误用。 3.没有类型安全的检查 。
>
> 内联函数摒弃了宏的缺点，且简单、不易出错、可被调试、可读性强，但是会增大可执行文件容量。

## `auto`关键字（C++11）

### 简介

**auto声明的变量会在编译阶段根据初始值来推出auto变量的类型。**

```c
#include<iostream>
using namespace std;
int TestAuto()
{
	return 10;
}
int main()
{
	int a = 10;
	auto b = a;
	auto c = 'a';
	auto d = TestAuto();
	auto e; //无法通过编译，使用auto定义变量时必须对其进行初始化

	cout << typeid(b).name() << endl;
	cout << typeid(c).name() << endl;
	cout << typeid(d).name() << endl;
	return 0;
}
```

> 使用auto定义变量时**必须对其进行初始化**，在编译阶段编译器需要根据初始化表达式来推导auto 的实际类型。因此auto并非是一种“类型”的声明，而是**一个类型声明时的“占位符”**，编译器在编译期会将auto替换为变量实际的类型。

### 使用细则

1.  **auto与指针和引用结合起来使用**
   用auto声明指针类型时，用auto和auto*没有任何区别，但用auto声明引用类型时则必须加&

   ```c
   #include<iostream>
   using namespace std;
   int main()
   {
       int x = 10;
       auto a = &x;
       auto* b = &x;
       auto& c = x;
       cout << typeid(a).name() << endl;   //int*
       cout << typeid(b).name() << endl;   //int*
       cout << typeid(c).name() << endl;   //int
       return 0;
   }
   ```

2. **在同一行定义多个变量**
   当在同一行声明多个变量时，这些变量必须是相同的类型，否则编译器将会报错，因为编译器实际只对第一个类型进行推导，然后用推导出来的类型定义其他变量。

   ```c
   void TestAuto()
   {
       auto a = 1, b = 2; 
       auto c = 3, d = 4.0;  // 该行代码会编译失败，因为c和d的初始化表达式类型不同
   }
   ```

3. **auto不能推导的场景**

   1. **auto不能作为函数的参数**

   2. **auto不能直接用来声明数组**

      ```c
      void TestAuto()
      {
          int a[] = {1,2,3};
          auto b[] = {4，5，6};//error
      }
      ```

   3. 为了避免与C++98中的auto发生混淆，C++11只保留了auto作为类型指示符的用法
      在早期C/C++中auto的含义是：使用auto修饰的变量，是具有自动存储器的局部变量，

   4. auto在实际中最常见的优势用法就是跟以后会讲到的C++11提供的新式for循环，还有 lambda表达式等进行配合使用。

## 基于范围的for循环(C++11)

### 范围for的语法

for循环后的括号由冒号“ ：”分为两部分：第一部分是范围内用于迭代的变量，第二部分则表示被迭代的范围。

```c
#include<iostream>
using namespace std;
void TestFor()
{
    int array[] = { 1, 2, 3, 4, 5 };
    for (auto& e : array)
        e *= 2;
    for (auto e : array)
        cout << e << " ";
}
int main() {
    TestFor();
    return 0;
}
```

> 注意：与普通循环类似，可以用continue来结束本次循环，也可以用break来跳出整个循环。

### 范围for的使用条件

1.  for循环迭代的范围必须是确定的
   对于数组而言，就是数组中第一个元素和最后一个元素的范围；对于类而言，应该提供 begin和end的方法，begin和end就是for循环迭代的范围。
   注意：以下代码就有问题，因为for的范围不确定

   ```c
   void TestFor(int array[])
   {
       for (auto e : array)//此处array并不是数组，而是指针
           cout << e << endl;
   }
   ```

2. **迭代的对象要实现++和==的操作。**(关于迭代器这个问题，以后会讲)

##  指针空值nullptr(C++11)

NULL实际是一个宏，在传统的C头文件(stddef.h)中，可以看到如下代码：

```c
#ifndef NULL
#ifdef __cplusplus
#define NULL   0
#else
#define NULL   ((void *)0)
#endif
#endif
```

可以看到，**NULL可能被定义为字面常量0，或者被定义为无类型指针(void*)的常量**。不论采取何种定义，在使用空值的指针时，都不可避免的会遇到一些麻烦，比如：

```c
void f(int)
{
	cout << "f(int)" << endl;
}
void f(int*)
{
	cout << "f(int*)" << endl;
}
int main()
{
	f(0);			//f(int)
	f(NULL);		//f(int)
	f((int*)0);		//f(int*)
    f(nullptr);		//f(int*)
	return 0;
}
```

在C++98中，字面常量0既可以是一个整形数字，也可以是无类型的指针(void*)常量，但是编译器 默认情况下将其看成是一个整形常量，如果要将其按照指针方式来使用，必须对其进行强转(void  *)0。

> **注意：**
>
> 1. **在使用nullptr表示指针空值时，不需要包含头文件，因为nullptr是C++11作为新关键字引入 的。**
> 2. **在C++11中，sizeof(nullptr) 与 sizeof((void*)0)所占的字节数相同。**
> 3. **为了提高代码的健壮性，在后续表示指针空值时建议最好使用nullptr。**

# 类和对象

