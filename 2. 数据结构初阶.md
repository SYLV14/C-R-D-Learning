

# 时间复杂度和空间复杂度

时间复杂度主要衡量一个算法的运行快慢，而空间复杂度主要衡量一个算法运行所需要的额外空间。

## 时间复杂度

一个算法所花费的时间与其中语句的执行次数成正比例，算法中的**基本操作的执行次数**，为算法的时间复杂度。

**时间复杂度的度量：**

1. 加法规则 ：`T(n) = T1(n) + T2(n) = O(f(n)) + O(g(n)) = O(max(f(n), g(n)))`
2. 乘法规则 ：`T(n) = T1(n) × T2(n) = O(f(n)) × O(g(n)) = O(f(n) × g(n))`
3. **常见的渐进时间复杂度**

​	O(1) < O(logn) < O(n) < O(nlogn) < O(n^2^ ) < O(n^3^ ) < O(2^n^) < O(n!) < O(n^n^)

> 最坏情况：任意输入规模的最大运行次数(上界) ，在实际中一般情况关注的是算法的最坏运行情况
>
> 平均情况：任意输入规模的期望运行次数
>
> 最好情况：任意输入规模的最小运行次数(下界)

**实例：**

```c
// 计算BinarySearch的时间复杂度？
int BinarySearch(int* a, int n, int x)
{
     assert(a);
     int begin = 0;
     int end = n-1;
     while (begin < end)
     {
         int mid = begin + ((end-begin)>>1);
         if (a[mid] < x)
         	begin = mid+1;
         else if (a[mid] > x)
         	end = mid;
         else
         	return mid;
     }
     return -1;
}
//假设N是数组元素个数，x为最坏查找次数，N/2/2/.../2=1，2^x=N，x=logN，时间复杂度为logN
```

```c
// 计算斐波那契递归Fib的时间复杂度？
long long Fib(size_t N)
{
 if(N < 3)
 	return 1;
 return Fib(N-1) + Fib(N-2);
}
//递归次数：1+2+2^2+2^4...2^(N-1)=2^N-1，时间复杂度为2^N
```

## 空间复杂度

函数运行时所需要的栈空间（存储参数、局部变量、一些寄存器信息等）在编译期间已经确定好了，因此空间复杂度主要通过函数在运行时候显式**申请的额外空间**来确定。

**实例：**

```c
// 计算阶乘递归Fac的空间复杂度？
long long Fac(size_t N)
{
 if(N == 0)
	return 1;
 return Fac(N-1)*N;
}
//递归调用了N次，开辟了N个栈帧，每个栈帧使用了常数个空间。空间复杂度为O(N)
```

```c
// 计算斐波那契递归Fib的时间复杂度？
long long Fib(size_t N)
{
 if(N < 3)
 	return 1;
 return Fib(N-1) + Fib(N-2);
}
//每次递归至最底层便返回上次一层再调用，最深层递归层数为N，空间复杂度为O(N)
```

## OJ练习

```c
//数组nums包含从0到n的所有整数，但其中缺了一个。请编写代码找出那个缺失的整数。你有办法在O(n)时间内完成吗？
#include<stdio.h>
//方法一：异或，参考找单身狗
int missingNumber(int* nums, int numsSize) {
	int ret = 0;
	int i = 0;
	for (i = 0; i < numsSize; ++i)
		ret ^= nums[i];
	for (i = 0; i < numsSize + 1; ++i)
		ret ^= i;
	return ret;
}
//方法二：公式计算
int missingNumber(int* nums, int numsSize) {
	int sum = numsSize * (numsSize + 1) / 2;;
	int i = 0;
	for (i = 0; i < numsSize; ++i)
		sum -= nums[i];
	return sum;
}
int main() {
	int nums[] = { 9, 6, 4, 2, 3, 5, 7, 0, 1 };
	int numsSize = sizeof(nums) / sizeof(nums[0]);
	int ret = missingNumber(nums, numsSize);
	printf("%d\n", ret);
	return 0;
}
```

```c
//给定一个整数数组 nums，将数组中的元素向右轮转 k 个位置，其中 k 是非负数。
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
//方法一：三次逆置
void swap(int* a, int* b) {
	int temp = *a;
	*a = *b;
	*b = temp;
}
void reverse(int* nums, int left, int right) {
	while (left < right) {
		swap(nums + left, nums + right);
		left++;
		right--;
	}
}
void rotate(int* nums, int numsSize, int k) {
	if (k > numsSize - 1)
		k %= numsSize;
	reverse(nums, 0, numsSize - k - 1);
	reverse(nums, numsSize - k, numsSize - 1);
	reverse(nums, 0, numsSize - 1);
}
//方法二：辅助数组
void rotate(int* nums, int numsSize, int k) {
	int* arr = (int*)calloc(numsSize, sizeof(int));
	if (k > numsSize - 1)
		k %= numsSize;
	memcpy(arr, nums + numsSize - k, k * sizeof(int));
	memcpy(arr + k, nums, (numsSize - k) * sizeof(int));
	memcpy(nums, arr, numsSize * sizeof(int));
	free(arr);
	arr = NULL;
}
int main() {
	int nums[] = {1, 2, 3, 4, 5, 6, 7};
	int numsSize = sizeof(nums) / sizeof(nums[0]);
	int k = 3;
	rotate(nums, numsSize, k);
	for (int i = 0; i < numsSize; ++i)
		printf("%d ", nums[i]);
	return 0;
}
```

# 线性表

## 顺序表

### 概念、结构及接口实现

顺序表是一种**逻辑上连续，物理上连续**的存储结构，一般采用数组实现。

```c
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<assert.h>
//静态数组
typedef int SLDataType;
#define N 100
typedef struct SeqList {
	SLDataType arr[N];
	size_t sz;
}SeqList;
//动态数组
typedef int SLDataType;
#define INIT_CAPACITY 4
typedef struct SeqList {
	SLDataType* data;
	size_t sz;
	size_t capacity;
}SeqList;
// 顺序表初始化
void SLInit(SeqList* ps) {
	assert(ps);
	ps->data = (SLDataType*)malloc(sizeof(SLDataType) * INIT_CAPACITY);
	if (!ps->data) {
		perror("malloc fail");
		return;
	}
	ps->sz = 0;
	ps->capacity = INIT_CAPACITY;
}
// 顺序表销毁
void SLDestory(SeqList* ps) {
	assert(ps);
	free(ps->data);
	ps->data = NULL;
	ps->sz = ps->capacity = 0;
}
//顺序表打印
void SLPrint(SeqList* ps) {
	assert(ps);
	int i = 0;
	for (i = 0; i < ps->sz; i++)
		printf("%d ", ps->data[i]);
	printf("\n");
}
//顺序表扩容
void CheckCapacity(SeqList* ps) {
	assert(ps);
	if (ps->sz == ps->capacity) {
		SLDataType* tmp = (SLDataType*)realloc(ps->data, sizeof(SLDataType) * ps->capacity * 2);
		if (!tmp) {
			perror("realloc fail");
			return;
		}
		ps->data = tmp;
		ps->capacity *= 2;
	}
}
// 顺序表尾插
void SLPushBack(SeqList* ps, SLDataType x) {
	assert(ps);
	CheckCapacity(ps);
	ps->data[ps->sz++] = x;
}
// 顺序表尾删
void SLPopBack(SeqList* ps) {
	assert(ps);
	assert(ps->sz > 0);
	ps->sz--;
}
// 顺序表头插
void SLPushFront(SeqList* ps, SLDataType x) {
	assert(ps);
	CheckCapacity(ps);
	//int end = ps->sz - 1;
	//while (end >= 0) {
	//	ps->data[end + 1] = ps->data[end];
	//	--end;
	//}
	memmove(ps->data+1,ps->data,sizeof(SLDataType)*ps->sz);
	ps->data[0] = x;
	ps->sz++;
}
// 顺序表头删
void SLPopFront(SeqList* ps) {
	assert(ps);
	assert(ps->sz > 0);
	//int begin = 0;
	//while (begin < ps->sz - 1) {
	//	ps->data[begin] = ps->data[begin + 1];
	//	++begin;
	//}
	memmove(ps->data, ps->data + 1, (ps->sz - 1) * sizeof(SLDataType));
	ps->sz--;
}
// 顺序表查找
int SLFind(SeqList* ps, SLDataType x) {
	assert(ps);
	int i = 0;
	for (i = 0; i < ps->sz; i++)
		if (ps->data[i] == x)
			return i;
	return -1;
}
// 顺序表在pos位置插入x
void SLInsert(SeqList* ps, size_t pos, SLDataType x) {
	assert(ps);
	assert(0 <= pos && pos <= ps->sz);
	CheckCapacity(ps);
	//int end = ps->sz - 1;
	//while (pos <= end) {
	//	ps->data[end + 1] = ps->data[end];
	//	--end;
	//}
	memmove(ps->data + pos + 1, ps->data + pos, (ps->sz - pos) * sizeof(SLDataType));
	ps->data[pos] = x;
	ps->sz++;
}
// 顺序表删除pos位置的值
void SLErase(SeqList* ps, size_t pos) {
	assert(ps);
	assert(0 <= pos && pos < ps->sz);
	//int begin = pos;
	//while (begin < ps->sz - 1) {
	//	ps->data[begin] = ps->data[begin + 1];
	//	++begin;
	//}
	memmove(ps->data + pos, ps->data + pos + 1, (ps->sz - pos - 1) * sizeof(SLDataType));
	ps->sz--;
}
//顺序表修改
void SLModify(SeqList* ps, int pos, SLDataType x){
	assert(ps);
	assert(0 <= pos && pos < ps->sz);
	ps->data[pos] = x;
}
void test() {
	SeqList s;
	SLInit(&s);
	int i = 0;
	for (i = 0; i < 10; i++)
		SLPushBack(&s, i + 1);
	SLPrint(&s);
	SLPushFront(&s, 11);
	SLInsert(&s, 4, 12);
	SLPrint(&s);
	SLPopBack(&s);
	SLPopFront(&s);
	SLErase(&s, 4);
	SLPrint(&s);
	SLModify(&s, 3, 4);
	SLPrint(&s);
	SLDestory(&s);
}
int main() {
	test();
	return 0;
}
```

### OJ练习

```c
//给你一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，并返回移除后数组的新长度。元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。
#include<stdio.h>
int removeElement(int* nums, int numsSize, int val) {
	int src = 0, dst = 0;
	while (src < numsSize) {
		if (nums[src] != val)
			nums[dst++] = nums[src];
		src++;
	}
	return dst;
}
int main() {
	int nums[] = { 0,1,2,2,3,0,4,2 };
	int sz = sizeof(nums) / sizeof(nums[0]);
	int val = 2;
	int ret = removeElement(nums, sz, val);
	printf("%d\n", ret);
	return 0;
}

//给你一个非严格递增排列的数组 nums ，请你原地删除重复出现的元素，使每个元素只出现一次 ，返回删除后数组的新长度。元素的相对顺序应该保持一致。然后返回 nums 中唯一元素的个数。
#include<stdio.h>
int removeDuplicates(int* nums, int numsSize) {
	int src = 1, dst = 0;
	while (src < numsSize) {
		if (nums[dst] != nums[src])
			nums[++dst] = nums[src];
		src++;
	}
	return dst + 1;
}
int main() {
	int nums[] = { 0,0,1,1,1,2,2,3,3,4 };
	int sz = sizeof(nums) / sizeof(nums[0]);
	int ret = removeDuplicates(nums, sz);

	return 0;
}

//给你两个按非递减顺序排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。请你合并 nums2 到 nums1 中，使合并后的数组同样按非递减顺序排列。
//方法：从两数组的尾元素遍历数组元素，将较大的元素插入nums1中，直至其中一个数组遍历完，若nums1先遍历完，则再将nums2数组未全部插入nums1中。
#include<stdio.h>
#include<string.h>
void merge(int* nums1, int nums1Size, int m, int* nums2, int nums2Size, int n) {
	int end1 = m - 1, end2 = n - 1;
	int end = m + n - 1;
	while (end1 >= 0 && end2 >= 0) {
		if (nums1[end1] < nums2[end2])
			nums1[end--] = nums2[end2--];
		else
			nums1[end--] = nums1[end1--];
	}
	while(end2>=0)
		nums1[end--] = nums2[end2--];
}
int main() {
	int nums1[6] = { 1,2,3 };
	int nums2[3] = { 2,5,6 };
	int m = 3, n = 3;
	merge(nums1, 6, 3, nums2, 3, 3);

	return 0;
}
```

## 链表

链表是一种**逻辑上连续、物理上不一定连续**的存储结构，一般使用指针链接实现。

链表以**有无头结点、单向或双向、是否循环**分类。

### 单链表

```c
//无头+单向+非循环链表增删查改实现
#include<stdio.h>
#include<stdlib.h>
#include<assert.h>
//单链表结点
typedef int SLDataType;
typedef struct SLNode {
	SLDataType data;
	struct SLNode* next;
}SLNode;
//打印
void SLPrint(SLNode* plist) {
	SLNode* cur = plist;
	while (cur) {
		printf("%d -> ", cur->data);
		cur = cur->next;
	}
	printf("NULL\n");
}
//创建新结点
SLNode* BuySLNode(SLDataType x) {
	SLNode* newnode = (SLNode*)malloc(sizeof(SLNode));
	if (newnode == NULL) {
		perror("malloc fail");
		return NULL;
	}
	newnode->data = x;
	newnode->next = NULL;
	return newnode;
}
//尾插
void SLPushBack(SLNode** pplist, SLDataType x) {
	assert(pplist);
	SLNode* newnode = BuySLNode(x);
	if (*pplist == NULL) {
		*pplist = newnode;
	}
	else {
		SLNode* tail = *pplist;
		while (tail->next)
			tail = tail->next;
		tail->next = newnode;
	}
}
//头插
void SLPushFront(SLNode** pplist, SLDataType x) {
	assert(pplist);
	SLNode* newnode = BuySLNode(x);
	newnode->next = *pplist;
	*pplist = newnode;
}
//尾删
void SLPopBack(SLNode** pplist) {
	assert(pplist);
	assert(*pplist);

	if ((*pplist)->next == NULL) {
		free(*pplist);
		*pplist = NULL;
	}
	else {
		//SLNode* prev = NULL;
		//SLNode* tail = *pplist;
		//while (tail->next) {
		//	prev = tail;
		//	tail = tail->next;
		//}
		//prev->next = NULL;
		//free(tail);
		//tail = NULL;
		SLNode* tail = *pplist;
		while (tail->next->next) {
			tail = tail->next;
		}
		free(tail->next);
		tail->next = NULL;
	}
}
//头删
void SLPopFront(SLNode** pplist) {
	assert(pplist);
	assert(*pplist);
	SLNode* firstnode = *pplist;
	*pplist = firstnode->next;
	free(firstnode);
	firstnode = NULL;

}
//查找
SLNode* SLFind(SLNode* plist, SLDataType x) {
	SLNode* cur = plist;
	while (cur && cur->data != x)
		cur = cur->next;
	return cur;
}
//pos之前插入
void SLInsert(SLNode** pplist, SLNode* pos, SLDataType x) {
	assert(pplist);
	assert(pos);
	if (pos == *pplist)
		SLPushFront(pplist, x);
	else {
		//方法一：找先驱结点
		//SLNode* prev = *pplist;
		//while (prev->next != pos)
		//	prev = prev->next;
		//SLNode* newnode = BuySLNode(x);
		//newnode->next = pos;
		//prev->next = newnode;
		//方法二：结点交换
		SLNode* newnode = BuySLNode(x);
		newnode->next = pos->next;
		pos->next = newnode;
		SLDataType tmp = pos->data;
		pos->data = newnode->data;
		newnode->data = tmp;
	}
}
//pos位置删除
void SLErase(SLNode** pplist, SLNode* pos) {
	assert(pplist);
	assert(pos);
	if (pos == *pplist)
		SLPopFront(pplist);
	else {
		SLNode* prev = *pplist;
		while (prev->next != pos)
			prev = prev->next;
		prev->next = pos->next;
		free(pos);
		pos = NULL;
	}
}
//pos后面插入
void SLInsertAfter(SLNode*pos, SLDataType x) {
	assert(pos);
	SLNode* newnode = BuySLNode(x);
	newnode->next = pos->next;
	pos->next = newnode;
}
//pos位置后面删除
void SLEraseAfter(SLNode* pos) {
	assert(pos);
	assert(pos->next);
	SLNode* del = pos->next;
	pos->next = del->next;
	free(del);
	del = NULL;
}
//销毁
void SLDestroy(SLNode* plist) {
	SLNode* cur = plist, * tmp = NULL;
	while (cur) {
		tmp = cur->next;
		free(cur);
		cur = tmp;
	}
}
void test() {
	SLNode* plist = NULL;
	int i = 0;
	for (i = 0; i < 10; i++)
		SLPushBack(&plist, i + 1);
	SLPrint(plist);
	SLPopBack(&plist);
	SLPrint(plist);
	SLPushFront(&plist, 10);
	SLPushFront(&plist, 11);
	SLPrint(plist);
	SLPopFront(&plist);
	SLPrint(plist);
	SLNode* pos = SLFind(plist, 5);
	SLInsert(&plist, pos, 20);
	SLPrint(plist);
	pos = SLFind(plist, 20);
	SLErase(&plist, pos);
	SLPrint(plist);
	pos = SLFind(plist, 5);
	SLInsertAfter(pos, 30);
	SLPrint(plist);
	SLEraseAfter(pos);
	SLPrint(plist);
	SLDestroy(plist);
}
int main() {
	test();
	return 0;
}
```

### 单链表OJ练习

```c
//1.给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回新的头节点。
//方法一：通过前驱节点删除
struct ListNode* removeElements(struct ListNode* head, int val) {
	struct ListNode* prev = NULL;
	struct ListNode* cur = head;
	while (cur) {
		if (cur->val != val) {
			prev = cur;
			cur = cur->next;
		}
		else {
			if (prev == NULL) {
				head = head->next;
				free(cur);
				cur = head;
			}
			else {
				prev->next = cur->next;
				free(cur);
				cur = prev->next;
			}
		}
	}
	return head;
}
//方法二：遍历链表。将非val值的结点尾插加入新链表，val值的结点释放。
struct ListNode* removeElements(struct ListNode* head, int val) {
	struct ListNode* cur = head;
	struct ListNode* delnode = NULL;
	struct ListNode* tail = NULL;
	head = NULL;
	while (cur) {
		if (cur->val != val) {
			if (head == NULL) {
				head = cur;
				tail = head;
			}
			else {
				tail->next = cur;
				tail = cur;
			}
			cur = cur->next;
		}
		else {
			delnode = cur;
			cur = cur->next;
			free(delnode);
			delnode = NULL;
		}
	}
	if(tail)
		tail->next = NULL;
	return head;
}


//2.给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。
//方法一：三指针
struct ListNode* reverseList(struct ListNode* head) {
	if (head == NULL)
		return NULL;
	struct ListNode* prev = NULL, * cur = head, * next = head->next;
	while (cur) {
		cur->next = prev;
		cur = next;
		if(next)
			next = next->next;
	}
	return cur;
}
//方法二：头插法
struct ListNode* reverseList(struct ListNode* head) {
	struct ListNode* cur = head;
	struct ListNode* next = NULL;
	head = NULL;
	while (cur) {
		next = cur->next;
		cur->next = head;
		head = cur;
		cur = next;
	}
	return head;
}
//方法三：递归
struct ListNode* reverseList(struct ListNode* head) {
	if(head -> next == NULL)   
        return head;
    struct ListNode* newhead = reverseList(head -> next);
    head -> next ->next = head;
    head -> next = NULL;
    return newhead;
}

//3.给你单链表的头结点 head ，请你找出并返回链表的中间结点。如果有两个中间结点，则返回第二个中间结点。
//方法：快慢指针法，快慢指针初试时均指向第一个结点，慢指针每走一步，快指针走两步
struct ListNode* middleNode(struct ListNode* head) {
	struct ListNode* slow = head;
	struct ListNode* fast = head;
	while (fast&&fast->next) {
		slow = slow->next;
		fast = fast->next->next;
	}
	return slow;
}

//4.输入一个链表，输出该链表中倒数第k个结点。
//方法：双指针法，第一个指针先走k-1步，若第一指针走到NULL，则表示该链表长度小于k，返回NULL，若第一个指针没有走到NULL，则两个指针同时向后移动，直至第一个指针走到尾结点，此时第二个指针指向的结点则为倒数第k个结点，
struct ListNode* FindKthNode(struct ListNode* head, int k) {
	struct ListNode* tail = head;
	struct ListNode* cur = head;
	while (tail && k - 1 > 0) {
		tail = tail->next;
		k--;
	}
	if (tail == NULL)
		return NULL;
	while (tail->next) {
		tail = tail->next;
		cur = cur->next;
	}
	return cur;
}

//5.将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 
struct ListNode* mergeTwoLists(struct ListNode* list1, struct ListNode* list2) {
	struct ListNode* guard = NULL, * tail = NULL;
	struct ListNode* cur1 = list1, * cur2 = list2;
	guard = tail = (struct ListNode*)malloc(sizeof(struct ListNode));
	tail->next = NULL;
	while (cur1 && cur2) {
		if (cur1->val < cur2->val) {
			tail->next = cur1;
			tail = cur1;
			cur1 = cur1->next;
		}
		else {
			tail->next = cur2;
			tail = cur2;
			cur2 = cur2->next;
		}
	}
	if (cur1)
		tail->next = cur1;
	if (cur2)
		tail->next = cur2;
	struct ListNode* head = guard->next;
	free(guard);
	return head;
}

//6.现有一链表的头指针 ListNode* pHead，给一定值x，编写一段代码将所有小于x的结点排在其余结点之前，且不能改变原来的数据顺序，返回重新排列后的链表的头指针。
//方法一：将小于x的结点依次尾插加入链表1，将大于等于x的结点依次尾插加入链表2，再将链表2尾插加入链表1，返回链表1的头结点。注意链表1为空或链表2为空或两个链表都为空的三种情况
struct ListNode* Partition(struct ListNode* pHead,int x) {
	struct ListNode* head1 = NULL , * head2 = NULL;
	struct ListNode* tail1 = NULL, * tail2 = NULL;
	struct ListNode* cur = pHead;
	while (cur) {
		if (cur->val < x) {
			if (head1 == NULL) {
				head1 = tail1 = cur;
			}
			else {
				tail1->next = cur;
				tail1 = cur;
			}
		}
		else {
			if (head2 == NULL) {
				head2 = tail2 = cur;
			}
			else {
				tail2->next = cur;
				tail2 = cur;
			}
		}
		cur = cur->next;
	}
	if (tail1 && tail2) {
		tail1->next = head2;
		tail2->next = NULL;
	}
	else if (!tail1 && tail2) {
		tail2->next = NULL;
		head1 = head2;
	}
	else if (tail1 && !tail2) {
		tail1->next = NULL;
	}
	return head1;
}
//方法二：哨兵位头结点法，与方法一一样，区别在于方法二不需要考虑链表1为空或链表2为空或两个链表都为空的三种情况
struct ListNode* Partition(struct ListNode* pHead, int x) {
	struct ListNode* guard1, * tail1, * guard2, * tail2, * cur = pHead;
	guard1 = tail1 = (struct ListNode*)malloc(sizeof(struct ListNode));
	guard2 = tail2 = (struct ListNode*)malloc(sizeof(struct ListNode));
	tail1->next = NULL;
	tail2->next = NULL;
	while (cur) {
		if (cur->val < x) {
			tail1->next = cur;
			tail1 = cur;
		}
		else {
			tail2->next = cur;
			tail2 = cur;
		}
		cur = cur->next;
	}
	tail2->next = NULL;
	tail1->next = guard2->next;
	struct ListNode* head = guard1->next;
	free(guard1);
	free(guard2);
	return head;
}

//7.对于一个链表，请设计一个时间复杂度为O(n),额外空间复杂度为O(1)的算法，判断其是否为回文结构。
//给定一个链表的头指针A，请返回一个bool值，代表其是否为回文结构。保证链表长度小于等于900。
//找中间结点
struct ListNode* middleNode(struct ListNode* head) {
	struct ListNode* slownode = head, * fastnode = head;
	while (fastnode && fastnode->next) {
		slownode = slownode->next;
		fastnode = fastnode->next->next;
	}
	return slownode;
}
//逆置链表
struct ListNode* reverseList(struct ListNode* head) {
	struct ListNode* cur = head, * newhead = NULL, * tmp = NULL;
	while (cur) {
		tmp = cur->next;
		cur->next = newhead;
		newhead = cur;
		cur = tmp;
	}
	return newhead;
}
//方法：先找到中间结点，将以中间节点为头结点的链表逆置，即逆置后半部分链表，再从头结点与中间结点同时遍历链表的前后两部分，若有不相同的结点值则返回false，遍历完成后返回true。
bool chkPalindrome(struct ListNode* head) {
	struct ListNode* mid = middleNode(head);
	struct ListNode* rhead = reverseList(mid);
	while (head && rhead) {
		if (head->val != rhead->val)
			return false;
		head = head->next;
		rhead = rhead->next;
	}
	return true;
}

//8.给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null。
struct ListNode* getIntersectionNode(struct ListNode* headA, struct ListNode* headB) {
	struct ListNode* tailA = headA, * tailB = headB;
	int lenA = 0, lenB = 0;
	while (tailA) {
		tailA = tailA->next;
		++lenA;
	}
	while (tailB) {
		tailB = tailB->next;
		++lenB;
	}
	if (tailA != tailB)
		return NULL;
	struct ListNode* longlist = headA, *shortlist = headB;
	if (lenA < lenB) {
		longlist = headB;
		shortlist = headA;
	}
	int gap = abs(lenA - lenB);
	while (gap--)
		longlist = longlist->next;
	while (longlist != shortlist) {
		longlist = longlist->next;
		shortlist = shortlist->next;
	}
	return longlist;
}
```

```c
//9.给定一个链表，判断链表中是否有环。
bool hasCycle(struct ListNode* head) {
    struct ListNode* slow, * fast;
    slow = fast = head;
    while (fast && fast->next) {
        slow = slow->next;
        fast = fast->next->next;
        if (slow == fast) {
            return slow;
        }
    }
    return NULL;
}
```

> **为什么快指针每次走两步，慢指针走一步，它们会相遇？**
>
> 假设slow进环时，fast与slow之间的距离是N，slow进环以后，fast开始追击slow，slow每走一步，fast走两步，它们之间的距离缩小1，直至相遇。
>
> **快指针每次走x步（x>2），慢指针走一步，它们会相遇吗？**
>
> 假设slow进环时，fast与slow之间的距离是N，slow进环以后，fast开始追击slow，slow每走一步，fast走x步，它们之间的距离缩小x-1，若距离N是x-1的倍数，则会相遇，否则不会相遇。

```c
//10.给定一个链表的头节点  head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。
struct ListNode* detectCycle(struct ListNode* head) {
    struct ListNode* slow, * fast;
    slow = fast = head;
    while (fast && fast->next) {
        slow = slow->next;
        fast = fast->next->next;
        if (slow == fast) {
            struct ListNode* meet = slow;
            struct ListNode* start = head;
            while (meet != start) {
                meet = meet->next;
                start = start->next;
            }
            return meet;
        }
    }
    return NULL;
}
```

> 说明：H为链表的起始点，E为环入口点，M与判环时候相遇点
>
> 设：环的长度为R，H到E的距离为L，E到M的距离为X，则：M到E的距离为R-X
> 在判环时，快慢指针相遇时所走的路径长度fast：L +X + nR，slow：L + X
>
> 注意：
> 1.当慢指针进入环时，快指针可能已经在环中绕了n圈了，n至少为1。因为：快指针先进环走到M的位置，最后又在M的位置与慢指针相遇
> 2.慢指针进环之后，快指针肯定会在慢指针走一圈之内追上慢指针。因为：慢指针进环后，快慢指针之间的距离最多就是环的长度，而两个指针在移动时，每次它们至今的距离都缩减一步，因此在慢指针移动一圈之前快指针肯定是可以追上慢指针的
>
> 而快指针速度是满指针的两倍因此有如下关系是：
> 2*(L+X)=L+X+ nR
> L+X=nR
> L=nR-X （n为1,2,3,4...，n的大小取决于环的大小，环越小n越大)
>
> 结论：一个指针从链表起始位置运行，一个指针从相遇点位置绕环，每次都走一步，两个指针最终会在入口点的位置相遇。

```c
//11.给你一个长度为 n 的链表，每个节点包含一个额外增加的随机指针 random ，该指针可以指向链表中的任何节点或空节点。
struct Node* copyRandomList(struct Node* head) {
	struct Node* cur = head;
	struct Node* copy = NULL, * next = NULL;
	//1.创建拷贝结点，并将拷贝结点插入至原结点后
	while (cur) {
		next = cur->next;
		copy = (struct Node*)malloc(sizeof(struct Node));
		copy->val = cur->val;
		copy->next = next;
		cur->next = copy;
		cur = next;
	}
	//2.根据原结点的random指针，将拷贝结点链接
	cur = head;
	while (cur) {
		copy = cur->next;
		if (cur->random == NULL)
			copy->random = NULL;
		else
			copy->random = cur->random->next;
		cur = copy->next;
	}
	//3.将所有拷贝结点从原链表中剥离，形成新的链表
	struct Node* copyhead = NULL, * copytail = NULL;
	cur = head;
	while (cur) {
		copy = cur->next;
		next = copy->next;
		if (copyhead == NULL)
			copyhead =copytail= copy;
		else {
			copytail->next = copy;
			copytail = copy;
		}
		//恢复原链表
		cur->next = next;
		cur = next;
	}
	return copyhead;
}
```

### 双向链表

```c
//带头+双向+循环链表增删查改实现
#include<stdio.h>
#include<stdbool.h>
#include<assert.h>
#include<stdlib.h>
typedef int LTDataType;
typedef struct ListNode {
	LTDataType data;
	struct ListNode* prev;
	struct ListNode* next;
}LTNode;
//创建新结点
LTNode* BuyListNode(LTDataType x) {
	LTNode* newnode = (LTNode*)malloc(sizeof(LTNode));
	if (newnode == NULL) {
		perror("malloc fail");
		return NULL;
	}
	newnode->data = x;
	newnode->prev = newnode->next = NULL;
	return newnode;
}
//初始化
LTNode* LTInit() {
	LTNode* phead = BuyListNode(-1);
	phead->next = phead->prev = phead;
	return phead;
}
//销毁
void LTDestroy(LTNode* phead) {
	assert(phead);
	LTNode* cur = phead->next, * tmp = NULL;
	while (cur != phead) {
		tmp = cur->next;
		free(cur);
		cur = tmp;
	}
	free(phead);
}
//判空
bool LTEmpty(LTNode* phead) {
	return phead->next == phead;
}
//打印
void LTPrint(LTNode* phead) {
	assert(phead);
	printf("head <=> ");
	LTNode* cur = phead->next;
	while (cur != phead) {
		printf("%d <=> ", cur->data);
		cur = cur->next;
	}
	printf("\n");
}
//尾插
void LTPushBack(LTNode* phead, LTDataType x) {
	assert(phead);
	LTNode* newnode = BuyListNode(x);
	LTNode* tail = phead->prev;
	tail->next = newnode;
	newnode->prev = tail;
	newnode->next = phead;
	phead->prev = newnode;
}
//尾删
void LTPopBack(LTNode* phead) {
	assert(phead);
	assert(!LTEmpty(phead));
	LTNode* tail = phead->prev;
	LTNode* tailprev = tail->prev;
	tailprev->next = phead;
	phead->prev = tailprev;
	free(tail);
	tail = NULL;
}
//头插
void LTPushFront(LTNode* phead, LTDataType x) {
	assert(phead);
	LTNode* newnode = BuyListNode(x);
	newnode->next = phead->next;
	phead->next->prev = newnode;
	phead->next = newnode;
	newnode->prev = phead;
}
//头删
void LTPopFront(LTNode* phead) {
	assert(phead);
	assert(!LTEmpty(phead));
	LTNode* firstnode = phead->next;
	phead->next = firstnode->next;
	firstnode->next->prev = phead;
	free(firstnode);
	firstnode = NULL;
}
//寻找
LTNode* LTFind(LTNode* phead, LTDataType x) {
	assert(phead);
	LTNode* cur = phead->next;
	while (cur != phead) {
		if (cur->data == x)
			return cur;
		cur = cur->next;
	}
	return NULL;
}
//插入
void LTInsert(LTNode* pos, LTDataType x) {
	assert(pos);
	LTNode* prev = pos->prev;
	LTNode* newnode = BuyListNode(x);
	newnode->next = pos;
	pos->prev = newnode;
	prev->next = newnode;
	newnode->prev = prev;
}
//删除
void LTErase(LTNode* pos) {
	assert(pos);
	LTNode* prev = pos->prev;
	LTNode* next = pos->next;
	prev->next = next;
	next->prev = prev;
	free(pos);
}

void test() {
	LTNode* plist = LTInit();
	int i = 0;
	for (i = 0; i < 10; i++)
		LTPushBack(plist, i + 1);
	LTPrint(plist);
	LTPopBack(plist);
	LTPrint(plist);
	LTPushFront(plist, 10);
	LTPushFront(plist, 11);
	LTPrint(plist);
	LTPopFront(plist);
	LTPrint(plist);
	LTNode* pos = LTFind(plist, 5);
	LTInsert(pos, 20);
	LTPrint(plist);
	pos = LTFind(plist, 20);
	LTErase(pos);
	LTPrint(plist);
	LTDestroy(plist);
	plist = NULL;
}
int main() {
	test();
	return 0;
}
```

# 栈和队列

## 栈

栈：一种特殊的线性表，其只允许**在固定的一端进行插入和删除元素操作**。进行数据插入和删除操作的一端称为**栈顶**，另一端称为**栈底**。栈中的数据元素遵守**后进先出**LIFO（Last In First Out）的原则。 
压栈：栈的插入操作叫做进栈/压栈/入栈，入数据在栈顶。 
出栈：栈的删除操作叫做出栈。出数据也在栈顶。

<img src="C:\Users\q9384\AppData\Roaming\Typora\typora-user-images\image-20240509095345237.png" alt="image-20240509095345237" style="zoom:50%;" />

栈的实现一般可以使用数组或者链表实现，相对而言**数组**的结构实现更优一些。因为数组在尾上插入数据的代价比较小。

```c
#include<stdio.h>
#include<stdlib.h>
#include<assert.h>
typedef int STDataType;
typedef struct Stack
{
	STDataType* a;
	int top; // 栈顶
	int capacity; // 容量
}Stack;
// 初始化栈
void StackInit(Stack* ps) {
	assert(ps);
	ps->a = (STDataType*)malloc(sizeof(STDataType) * 4);
	if (ps->a == NULL) {
		perror("malloc fail");
		return;
	}
	ps->top = 0;
	ps->capacity = 4;
}
// 检测栈是否为空，如果为空返回非零结果，如果不为空返回0 
int StackEmpty(Stack* ps) {
	assert(ps);
	return ps->top == 0;
}
// 入栈
void StackPush(Stack* ps, STDataType data) {
	assert(ps);
	if (ps->top == ps->capacity) {
		STDataType* tmp = (STDataType*)realloc(ps->a, sizeof(STDataType) * ps->capacity * 2);
		if (tmp == NULL) {
			perror("realloc fail");
			return;
		}
		ps->a = tmp;
		ps->capacity *= 2;
	}
	ps->a[ps->top++] = data;
}
// 出栈
void StackPop(Stack* ps) {
	assert(ps);
	assert(!StackEmpty(ps));
	ps->top--;
}
// 获取栈顶元素
STDataType StackTop(Stack* ps) {
	assert(ps);
	assert(!StackEmpty(ps));
	return ps->a[ps->top - 1];
}
// 获取栈中有效元素个数
int StackSize(Stack* ps) {
	assert(ps);
	return ps->top;
}
// 销毁栈
void StackDestroy(Stack* ps) {
	assert(ps);
	free(ps->a);
	ps->a = NULL;
	ps->top = ps->capacity = 0;
}
void test() {
	Stack s;
	StackInit(&s);
	int i = 0;
	for (i = 0; i < 10; i++)
		StackPush(&s, i + 1);
	while(!StackEmpty(&s)) {
		printf("%d ", StackTop(&s));
		StackPop(&s);
	}
	StackDestroy(&s);
}
int main() {
	test();
	return 0;
}
```

## 队列

队列：**只允许在一端进行插入数据，在另一端进行删除数据**的特殊线性表，队列具有先进先出 **FIFO**(First In First Out) 
入队：进行插入操作的一端称为队尾
出队：进行删除操作的一端称为队头

<img src="C:\Users\q9384\AppData\Roaming\Typora\typora-user-images\image-20240509100405416.png" alt="image-20240509100405416" style="zoom:50%;" />

队列也可以数组和链表的结构实现，使用**链表**的结构实现更优一些，因为如果使用数组的结构，出队列在数组头上出数据，效率会比较低。

```c
#include<stdio.h>
#include<assert.h>
#include<stdlib.h>
typedef int QDataType;
typedef struct QListNode
{
	QDataType data;
	struct QListNode* next;
}QNode;
typedef struct Queue {
	QNode* front;
	QNode* rear;
}Queue;

// 初始化队列
void QueueInit(Queue* pq) {
	assert(pq);
	pq->front = pq->rear = NULL;
}
// 检测队列是否为空，如果为空返回非零结果，如果非空返回0 
int QueueEmpty(Queue* pq) {
	assert(pq);
	return pq->front == NULL;
}
// 入队
void QueuePush(Queue* pq, QDataType data) {
	assert(pq);
	QNode* newnode = (QNode*)malloc(sizeof(QNode));
	if (newnode == NULL) {
		perror("malloc fail");
		return;
	}
	newnode->data = data;
	newnode->next = NULL;
	if (pq->rear == NULL)
		pq->front = pq->rear = newnode;
	else {
		pq->rear->next = newnode;
		pq->rear = newnode;
	}
}
// 出队
void QueuePop(Queue* pq) {
	assert(pq);
	assert(!QueueEmpty(pq));
	QNode* next = pq->front->next;
	if (next == NULL) {
		free(pq->front);
		pq->front = pq->rear = NULL;
	}
	else {
		free(pq->front);
		pq->front = next;
	}
}
// 获取队列头部元素
QDataType QueueFront(Queue* pq) {
	assert(pq);
	assert(!QueueEmpty(pq));
	return pq->front->data;
}
// 获取队列队尾元素
QDataType QueueBack(Queue* pq) {
	assert(pq);
	assert(!QueueEmpty(pq));
	return pq->rear->data;
}
// 获取队列中有效元素个数
int QueueSize(Queue* pq) {
	assert(pq);
	QNode* cur = pq->front;
	int count = 0;
	while (cur) {
		count++;
		cur = cur->next;
	}
	return count;
}
// 销毁队列
void QueueDestroy(Queue* pq) {
	assert(pq);
	QNode* cur = pq->front;
	QNode* next = NULL;
	while (cur) {
		next = cur->next;
		free(cur);
		cur = next;
	}
	pq->front = pq->rear = NULL;
}
void test() {
	Queue q;
	QueueInit(&q);
	int i = 0;
	for (i = 0; i < 10; i++)
		QueuePush(&q, i + 1);
	printf("%d\n", QueueBack(&q));
	printf("%d\n", QueueSize(&q));
	while (!QueueEmpty(&q)) {
		printf("%d ", QueueFront(&q));
		QueuePop(&q);
	}
	printf("\n%d\n", QueueSize(&q));
	QueueDestroy(&q);
}
int main() {
	test();
	return 0;
}
```

**循环队列**

> 为什么不用链表？
> 链表实现循环队列的致命缺陷在于取队尾元素时需要从队头遍历才能取得，数组在这方面更有优势。
>
> 如何解决循环队列判空判满问题？
> 方法一：结构体中添加记录当前数组元素个数的变量
> **方法二**：假如元素个数是K，则创建K+1大小的数组
>
> 判空：`front == rear;`
> 判满：`(rear + 1) % size == front;`
> 元素个数：`(rear + size - front) % size`
> 入队、出队：`rear = (rear + 1) % size;  front = (front + 1) % size;`

```c
//循环队列
#include<stdio.h>
#include<stdlib.h>
#include<stdbool.h>
typedef struct {
	int* data;
	int front;
	int rear;
	int size;
} MyCircularQueue;
//创建循环队列
MyCircularQueue* myCircularQueueCreate(int k) {
	MyCircularQueue* obj = (MyCircularQueue*)malloc(sizeof(MyCircularQueue));
	if (obj == NULL) {
		perror("malloc fail");
		return NULL;
	}
	obj->data = (int*)malloc(sizeof(int) * (k + 1));
	obj->front = obj->rear = 0;
	obj->size = k + 1;
	return obj;
}
//判空
bool myCircularQueueIsEmpty(MyCircularQueue* obj) {
	return obj->front == obj->rear;
}
//判满
bool myCircularQueueIsFull(MyCircularQueue* obj) {
	return (obj->rear + 1) % obj->size == obj->front;
}
//入队
bool myCircularQueueEnQueue(MyCircularQueue* obj, int value) {
	if (myCircularQueueIsFull(obj))
		return false;
	obj->data[obj->rear] = value;
	obj->rear = (obj->rear + 1) % obj->size;
	return true;
}
//出队
bool myCircularQueueDeQueue(MyCircularQueue* obj) {
	if (myCircularQueueIsEmpty(obj))
		return false;
	obj->front = (obj->front + 1) % obj->size;
	return true;
}
//取对头
int myCircularQueueFront(MyCircularQueue* obj) {
	if (myCircularQueueIsEmpty(obj))
		return -1;
	return obj->data[obj->front];
}
//取队尾
int myCircularQueueRear(MyCircularQueue* obj) {
	if (myCircularQueueIsEmpty(obj))
		return -1;
	return obj->data[(obj->rear - 1 + obj->size) % obj->size];
}
//队列元素个数
int myCircularQueueCount(MyCircularQueue* obj) {
	return (obj->rear + obj->size - obj->front) % obj->size;
}
//销毁
void myCircularQueueFree(MyCircularQueue* obj) {
	free(obj->data);
	obj->data = NULL;
	free(obj);
}
```

## OJ练习

```c
//括号匹配
#include<stdio.h>
#include<stdbool.h>
bool isValid(char* s) {
	char Stack[10001] = { 0 };
	int top = 0;
	char* p = s;
	while (*p) {
		if (*p == '(' || *p == '[' || *p == '{') {
			Stack[top++] = *p;
		}
		else {
			if (top == 0)
				return false;
			char stacktop = Stack[--top];
			if (*p == ')' && stacktop != '('
				||*p == ']' && stacktop != '['
				||*p == '}' && stacktop != '{')
				return false;
		}
		p++;
	}
	if (top == 0)
		return true;
	else
		return false;
}
```

```c
//用队列实现栈
//创建两个队列，将元素插入其中一个队列，若要出栈则将非空栈的元素转移至空栈，非空栈仅留一个元素，将此元素出栈，若要进栈，则将元素放入非空队列。
typedef struct {
	Queue q1;
	Queue q2;
} MyStack;
//创建栈
MyStack* myStackCreate() {
	MyStack* ps = (MyStack*)malloc(sizeof(MyStack));
	if (ps == NULL) {
		perror("malloc fail");
		return NULL;
	}
	QueueInit(&ps->q1);
	QueueInit(&ps->q2);
	return ps;
}
//入栈
void myStackPush(MyStack* obj, int x) {
	if (!QueueEmpty(&obj->q1)) {
		QueuePush(&obj->q1, x);
	}
	else {
		QueuePush(&obj->q2, x);
	}
}
//出栈
int myStackPop(MyStack* obj) {
	Queue* empty = &obj->q1;
	Queue* nonempty = &obj->q2;
	if (!QueueEmpty(&obj->q1)) {
		empty = &obj->q2;
		nonempty = &obj->q1;
	}
	while (QueueSize(nonempty) > 1) {
		QueuePush(empty, QueueFront(nonempty));
		QueuePop(nonempty);
	}
	int top = QueueFront(nonempty);
	QueuePop(nonempty);
	return top;
}
//取栈顶
int myStackTop(MyStack* obj) {
	if (!QueueEmpty(&obj->q1)) {
		return QueueBack(&obj->q1);
	}
	else {
		return QueueBack(&obj->q2);
	}
}
//栈空
bool myStackEmpty(MyStack* obj) {
	return QueueEmpty(&obj->q1) && QueueEmpty(&obj->q2);
}
```

```c
//用栈实现队列
//创建两个栈，一个栈只用来入队，另一个栈只用来出队。若要入队，则将元素插入入队栈，若要出队，先检查出队栈是否为空，如果出队栈非空，则出栈栈顶元素，如果出队栈为空，则将入队栈的元素全部转移至出队栈，再出栈栈顶元素。
typedef struct {
	Stack pushst;
	Stack popst;
} MyQueue;
//创建队列
MyQueue* myQueueCreate() {
	MyQueue* pq = (MyQueue*)malloc(sizeof(MyQueue));
	if (pq == NULL) {
		perror("malloc fail");
		return NULL;
	}
	StackInit(&pq->pushst);
	StackInit(&pq->popst);
	return pq;
}
//入队
void myQueuePush(MyQueue* obj, int x) {
	StackPush(&obj->pushst, x);
}
//取队头
int myQueuePeek(MyQueue* obj) {
	if (StackEmpty(&obj->popst)) {
		while (!StackEmpty(&obj->pushst)) {
			StackPush(&obj->popst, StackTop(&obj->pushst));
			StackPop(&obj->pushst);
		}
	}
	return StackTop(&obj->popst);
}
//出队
int myQueuePop(MyQueue* obj) {
	int front = myQueuePeek(obj);
	StackPop(&obj->popst);
	return front;
}
//队空
bool myQueueEmpty(MyQueue* obj) {
	return StackEmpty(&obj->pushst) && StackEmpty(&obj->popst);
}
//销毁
void myQueueFree(MyQueue* obj) {
	StackDestroy(&obj->pushst);
	StackDestroy(&obj->popst);
	free(obj);
}
```

# 树与二叉树

## 树的概念

### 树的基本结构与术语

树是一种**非线性**的数据结构，它是由n（n>=0）个有限结点组成一个具有层次关系的集合。

<img src="C:\Users\q9384\AppData\Roaming\Typora\typora-user-images\image-20240513141448483.png" alt="image-20240513141448483" style="zoom: 30%;" />

<img src="C:\Users\q9384\AppData\Roaming\Typora\typora-user-images\image-20240513140901658.png" alt="image-20240513140901658" style="zoom:50%;" />

### 树的性质

<img src="C:\Users\q9384\AppData\Roaming\Typora\typora-user-images\image-20240513141147761.png" alt="image-20240513141147761" style="zoom: 50%;" />

### 树的表示方式



## 二叉树的概念

### 二叉树的基本结构

二叉树的定义：

1. 每个结点至多只有两棵子树
2. 二叉树是**有序树**，左右子树不能颠倒
3. 是递归定义的数据结构

二叉树的5种基本形态：

<img src="C:\Users\q9384\AppData\Roaming\Typora\typora-user-images\image-20240513142145534.png" alt="image-20240513142145534" style="zoom: 30%;" />

### 特殊的二叉树

**满二叉树：**一个二叉树，如果每一个层的结点数都达到最大值，则这个二叉树就是满二叉树。

**完全二叉树：**对于深度为K 的，有n个结点的二叉树，当且仅当其每一个结点都与深度为K的满二叉树中编号从1至n的结点一一对应时称之为完全二叉树。满二叉树是一种特殊的完全二叉树。

<img src="C:\Users\q9384\AppData\Roaming\Typora\typora-user-images\image-20240513143100710.png" alt="image-20240513143100710" style="zoom:30%;" />

### 二叉树的性质

1. 若规定根节点的层数为1，则一棵非空二叉树的第$i$层上最多有$2 ^ { ( i - 1 ) }$ 个结点。

2. 若规定根节点的层数为1，则深度为 $h$ 的二叉树的最大结点数是$2^ { h } - 1$。

3. 对任何一棵二叉树，如果度为0其叶结点个数为 $n _ { 0 }$，度为2的分支结点个数为 $n _ { 2 }$ ，则有 $n _ { 0 } = n _ { 2 } + 1$。

4. 若规定根节点的层数为1，包含n个节点的二叉树的高度至少为$h = \log _ { 2 } ( n + 1 )$。

5. 完全二叉树的性质：

   1. 具有个 $n$ $( n > 0 )$ 结点的完全二叉树的高度$h$为$\lceil \log _ { 2 } (  { n } + 1 )\rceil$ 或$\lfloor  \log _ { 2 } { n } \rfloor + 1 $。
      $2 ^ { h - 1 } - 1 < n \leq 2 ^ { h } - 1 \ggg h = \lceil \log _ { 2 } (  { n } + 1 )\rceil$

      $2 ^ { h - 1 } \leq n < 2 ^ { h } \ggg h = \lfloor  \log _ { 2 } { n } \rfloor + 1$

   2. 完全二叉树最多只有一个度为1的结点。

   3. 对于具有 $n$个结点的完全二叉树，如果按照从上至下从左至右的数组顺序对所有节点从0开始编号，则对于序号$i$为的结点有：

      1. 若 $i > 0 $ ，$i$位置节点的双亲序号： $(i-1)/2$；$i=0$，$i$为根节点编号，无双亲节点。
      2. 当$2i+1<n$时，结点i的左孩子编号为$2i+1$，否则无左孩子。
      3. 当$2i+2<n$时，结点i的右孩子编号$为2i+2$，否则无右孩子。

### 二叉树的存储结构

1. **顺序存储**

   顺序结构存储就是使用数组来存储，一般使用数组**只适合表示完全二叉树**，因为不是完全二叉树会有空间的浪费。而现实中使用中只有堆才会使用数组来存储。二叉树顺序存储在**物理上是一个数组，在逻辑上是一颗二叉树**。

   ![image-20240513151224309](C:\Users\q9384\AppData\Roaming\Typora\typora-user-images\image-20240513151224309.png)

2. **链式存储**

   二叉树的链式存储结构是指，用链表来表示一棵二叉树，即用链来指示元素的逻辑关系。 通常的方法是链表中每个结点由三个域组成，数据域和左右指针域，左右指针分别用来给出该结点左孩子和右孩子所在的链结点的存储地址 。

   <img src="C:\Users\q9384\AppData\Roaming\Typora\typora-user-images\image-20240513151412582.png" alt="image-20240513151412582" style="zoom:40%;" />

## 二叉树的顺序结构及实现

### 堆的概念和结构

如果有一个关键码的集合，把它的所有元素按完全二叉树的顺序存储方式存储在一个一维数组中，并满足：双亲结点的值大于等于（小于等于）孩子结点的值，则成为大堆（小堆）。将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。

<img src="https://img-blog.csdnimg.cn/aab02b5463e24293a2657e647c9f63ff.png#pic_center" alt="img" style="zoom: 50%;" />

### 堆的实现

```c
#include<stdio.h>
#include<stdlib.h>
#include<assert.h>
#include<stdbool.h>
typedef int HPDataType;
typedef struct Heap
{
	HPDataType* a;
	int size;
	int capacity;
}Heap;
// 堆的构建
void HeapInit(Heap* php) {
	assert(php);
	php->a = (HPDataType*)malloc(sizeof(HPDataType) * 4);
	if (php->a == NULL) {
		perror("malloc fail");
		return;
	}
	php->size = 0;
	php->capacity = 4;
}
// 堆的销毁
void HeapDestory(Heap* php) {
	free(php->a);
	php->size = 0;
	php->capacity = 0;
}
void swap(HPDataType* a, HPDataType* b) {
	HPDataType tmp = *a;
	*a = *b;
	*b = tmp;
}
//大根堆向上调整
void AdjustUp(HPDataType* a, int n) {
	int child = n;
	int parent = (child - 1) / 2;
	while (child > 0) {
		if (a[child] > a[parent]) {
			swap(&a[child], &a[parent]);
			child = parent;
			parent = (child - 1) / 2;
		}
		else
			break;
	}
}
// 堆的插入
void HeapPush(Heap* php, HPDataType x) {
	assert(php);
	if (php->size == php->capacity) {
		HPDataType* tmp = (HPDataType*)realloc(php->a, sizeof(HPDataType) * php->capacity * 2);
		if (tmp == NULL) {
			perror("realloc fail");
			return;
		}
		php->a = tmp;
		php->capacity *= 2;
	}
	php->a[php->size++] = x;
	AdjustUp(php->a, php->size - 1);
}
//大根堆向下调整
void AdjustDown(HPDataType* a, int n,int parent) {
	int child = 2 * parent + 1;
	while (child < n) {
		if (child + 1 < n && a[child] < a[child + 1]) {//注意避免右孩子越界
			child += 1;
		}
		if (a[child] > a[parent]) {
			swap(&a[child], &a[parent]);
			parent = child;
			child = 2 * parent + 1;
		}
		else
			break;
	}
}
// 堆的删除
void HeapPop(Heap* php) {
	assert(php);
	assert(php->size);
	swap(&php->a[0], &php->a[php->size - 1]);
	php->size--;
	AdjustDown(php->a, php->size, 0);
}
// 取堆顶的数据
HPDataType HeapTop(Heap* php) {
	assert(php);
	assert(php->size);
	return php->a[0];
}
// 堆的数据个数
int HeapSize(Heap* php) {
	assert(php);
	return php->size;
}
// 堆的判空
bool HeapEmpty(Heap* php) {
	assert(php);
	return php->size == 0;
}
void test() {
	int arr[] = { 2,3,5,7,7,16,20,30,32,45,50 };
	int sz = sizeof(arr) / sizeof(arr[0]);
	Heap hp;
	HeapInit(&hp);
	for (int i = 0; i < sz; i++) {
		HeapPush(&hp, arr[i]);;

	}
	printf("%d\n", HeapSize(&hp));
	while (!HeapEmpty(&hp)) {
		printf("%d ", HeapTop(&hp));
		HeapPop(&hp);
	}
	HeapDestory(&hp);
}
```

**时间复杂度分析：**

1. 向下调整：

   第1层，2^0^个节点，需要向下移动h-1层，第2层，2^1^个节点，需要向下移动h-2层……第h-1层，2^h-2^ 个节点，需要向下移动1层

   需要移动结点的步数为：

    $T ( n ) = 2 ^ { 0 } * ( h - 1 ) + 2 ^ { 1 } * ( h - 2 ) + 2 ^ { 2 } * ( h - 3 ) + 2 ^ { 3 } * ( h - 4 ) + \ldots + 2 ^ { h - 3 } * 2 + 2 ^ { h - 2 } * 1$ 

    $2 * T ( n ) = 2 ^ { 1 } * ( h - 1 ) + 2 ^ { 2 } * ( h - 2 ) + 2 ^ { 3 } * ( h - 3 ) + 2 ^ { 4 } * ( h - 4 ) + \ldots + 2 ^ { h - 2 } * 2 + 2 ^ { h - 1 } * 1$​ 

   错位相减得：

   $ T ( n ) = 2 ^ { h } - 1 - h $

   $ n = 2 ^ { h } - 1 \quad h = \log _ { 2 } ( n + 1 ) $

   $ T ( n ) = n - \log _ { 2 } ( n + 1 ) \approx n$​

   时间复杂度为$O(n)$

2. 向上调整：

   第2层，2^1^个节点，需要向上移动1层，第3层，2^2^个节点，需要向上移动2层……第h层，2^h-1^ 个节点，需要向上移动h-1层

   需要移动结点的步数为：

    $T ( n ) = 2 ^ { 1 } * ( 1 ) + 2 ^ { 2 } * ( 2 ) + 2 ^ { 3 } * (3 ) + 2 ^ { 4 } * ( 4 ) + \ldots + 2 ^ { h - 2 } * ( h-2 ) + 2 ^ { h - 1 } *  ( h-1 )$ 

    $2*T ( n ) = 2 ^ { 2 } * ( 1 ) + 2 ^ { 3 } * ( 2 ) + 2 ^ { 4 } * (3 ) + 2 ^ { 5 } * ( 4 ) + \ldots + 2 ^ { h - 1 } * ( h-2 ) + 2 ^ { h } *  ( h-1 )$  

   错位相减得：

   $ T ( n ) = 2 ^ { h }*h - 2*(2 ^ { h }-1) $

   $ n = 2 ^ { h } - 1 \quad h = \log _ { 2 } ( n + 1 ) $

   $ T ( n ) = (n+1) * \log _ { 2 } ( n + 1 )-2n \approx nlog{n}$

   时间复杂度为$O(nlog{n})$

### 堆的应用

- **基于大根堆的排序**：
  1. 建堆：
     方法一：从尾到头（或者从头到尾）不断向上调整，大元素不断"上升"，最终得到大根堆
     **方法二**：从分支结点至根节点不断向下调整，小元素不断“下坠”，最终得到大根堆
  2. 排序：每一趟将堆顶元素加入有序子序列，即与待排序序列中的最后一个元素交换，并将待排序元素序列再次调整为大根堆 

```c
//排升序，建大堆
void HeapSort(int* arr, int n) {
	//建堆，向上调整
	//int i = 0;
	//for (i = n; i > 0; i--) {
	//	AdjustUp(arr, i - 1);
	//}
	//建堆，向下调整
	int i = 0;
	for (i = (n - 1 - 1) / 2; i >= 0; i--) {
		AdjustDown(arr, n, i);
	}
	//排序
	int end = n - 1;
	while (end > 0){
		swap(&arr[0], &arr[end]);
		AdjustDown(arr, end,0);
		end--;
	}
}
int main() {
	int arr[] = { 7,5,2,3,10,11,16,15,1,4 };
	int sz = sizeof(arr) / sizeof(arr[0]);
	HeapSort(arr, sz);
	int i = 0;
	for (i = 0; i < sz; i++) {
		printf("%d ", arr[i]);
	}
	return 0;
}
```

> 基于“大根堆”的堆排序得到“递增序列”；基于“小根堆”的堆排序得到“递减序列”

- **TopK问题：**即求数据结合中前K个最大的元素或者最小的元素，一般情况下数据量都比较大。

  1. 建堆：用数据集合的前K个来建堆，前K个最大的元素建小根堆，前K个最小的元素建大根堆

  2. 排序：用剩余的N-K个元素依次与堆顶元素来比较，若是建小根堆，比较的元素大于堆顶元素，则替换堆顶元素，并调整小根堆；若是建大根堆，比较的元素小于堆顶元素，则替换堆顶元素，并调整大根堆。

     > 为什么前K个最大的元素建小根堆，前K个最小的元素建大根堆？
     > 以前K个最大的元素为例，若是建大根堆，如果当前堆顶元素已经为最大值，且堆中存在部分元素并不在前K个最大的元素中，那剩余的元素中符合条件的元素就无法进堆替换掉堆中不符合条件的元素，就无法得到前K个最大的元素。

```c
#include<stdio.h>
#include<stdlib.h>
#include<time.h>
//向下调整，建小堆
void AdjustDown(int *a,int n,int parent) {
	int child = parent * 2 + 1;
	while (child < n) {
		if (child + 1 < n && a[child] > a[child + 1])
			child += 1;
		if (a[parent] > a[child]) {
			int* tmp = a[parent];
			a[parent] = a[child];
			a[child] = tmp;
			parent = child;
			child = parent * 2 + 1;
		}
		else
			break;
	}
}
//找出前K个最大的元素
void PrintTopK(const char* file,int n, int k)
{
	// 1. 建堆
	int* arr = (int*)malloc(sizeof(int) * k);
	if (arr == NULL) {
		perror("malloc fail");
		return;
	}
	FILE* pf = fopen(file, "r");
	if (pf == NULL) {
		perror("fopen error");
		return;
	}
	int i = 0;
	for (i = 0; i < k; i++)
		fscanf(pf, "%d", &arr[i]);
	for (i = (k - 2) / 2; i >=0; i--)
		AdjustDown(arr, k, i);
	// 2. 将剩余n-k个元素依次与堆顶元素交换，不满则则替换
	int val = 0;
	while (fscanf(pf, "%d", &val) != EOF) {
		if (val > arr[0]) {
			arr[0] = val;
			AdjustDown(arr, k, 0);
		}
	}
	for (i = 0; i < k; i++)
		printf("%d ", arr[i]);
}
//创建1000个0-999的随机值
void CreateNData(const char*file,int n) {
	srand((signed int)time(NULL));
	FILE* pf = fopen(file, "w");
	if (pf == NULL) {
		perror("fopen error");
		return;
	}
	int ret = rand() % n;
	for (int i = 0; i < n; i++) {
		fprintf(pf, "%d\n", ret);
		ret = rand() % n;
	}
	fclose(pf);
	pf = NULL;
}
int main() {
	const char* file = "data.txt";
	//CreateNData(file,1000);
	PrintTopK(file, 1000, 10);
	return 0;
}
```

## 二叉树的链式结构及实现

### 二叉树的遍历

- **前序遍历** (Preorder Traversal 亦称先序遍历)：访问顺序为根>左>右
- **中序遍历** (Inorder Traversal)：访问顺序为左>根>右
- **后序遍历** (Postorder Traversal)：访问顺序为左>右>根

```c
typedef int BTDataType;
typedef struct BinaryTreeNode
{
	BTDataType data;
	struct BinaryTreeNode* left;
	struct BinaryTreeNode* right;
}BTNode;
//先序遍历
void PreOrder(BTNode* root) {
	if (root == NULL) {
		printf("NULL ");
		return;
	}
	printf("%d ", root->data);
	PreOrder(root->left);
	PreOrder(root->right);
}
//中序遍历
void InOrder(BTNode* root) {
	if (root == NULL) {
		printf("NULL ");
		return;
	}
	InOrder(root->left);
	printf("%d ", root->data);
	InOrder(root->right);
}
//后序遍历
void PostOrder(BTNode* root) {
	if (root == NULL) {
		printf("NULL ");
		return;
	}
	PostOrder(root->left);
	PostOrder(root->right);
	printf("%d ", root->data);
}
```

- **层序遍历**：从所在二叉树的根节点出发，首先访问第一层的树根节点，然后从左到右访问第2层上的节点，接着是第三层的节点，以此类推，自上而下，自左至右逐层访问树的结点的过程就是层序遍历。

```c
//层序遍历
#include<stdio.h>
#include<assert.h>
#include<stdlib.h>
#include<stdbool.h>
typedef struct BinaryTreeNode* QDataType;
typedef struct QListNode
{
	QDataType data;
	struct QListNode* next;
}QNode;
typedef struct Queue {
	QNode* front;
	QNode* rear;
}Queue;
// 初始化队列
void QueueInit(Queue* pq)；
// 检测队列是否为空，如果为空返回非零结果，如果非空返回0 
int QueueEmpty(Queue* pq)；
// 入队
void QueuePush(Queue* pq, QDataType data)；
// 出队
void QueuePop(Queue* pq)；
// 获取队列头部元素
QDataType QueueFront(Queue* pq)；
// 获取队列队尾元素
QDataType QueueBack(Queue* pq)；
// 获取队列中有效元素个数
int QueueSize(Queue* pq)；
// 销毁队列
void QueueDestroy(Queue* pq)；
// 层序遍历
void LevelOrder(BTNode* root) {
	Queue q;
	QueueInit(&q);
	if(root)
		QueuePush(&q, root);
	while (!QueueEmpty(&q)) {
		BTNode* front = QueueFront(&q);
		QueuePop(&q);
		//释放的是队列中的结点，结点值已用front保存，结点值是指向树的结点的指针，并不会释放树的结点
		printf("%c ", front->data);
		if(front->left)
			QueuePush(&q, front->left);
		if (front->right)
			QueuePush(&q, front->right);
	}
	QueueDestroy(&q);
}
```

<img src="C:\Users\q9384\AppData\Roaming\Typora\typora-user-images\image-20240515154855265.png" alt="image-20240515154855265" style="zoom: 33%;" />

此二叉树的的先序遍历为ABDEHCFG，中序遍历为DBEHAFCG，后序遍历为DHEBFGCA，层序遍历为ABCDEFGH

### 二叉树的常用函数

```c
// 二叉树节点个数
int TreeSize(BTNode* root) {
	return root == NULL ? 0 : TreeSize(root->left) + TreeSize(root->right) + 1;
}

//二叉树的高度
//极耗性能的写法：第二层的结点递归调用2次，第三层的结点递归调用4次，依次类推，层数越多越耗性能
int TreeHeight(BTNode* root) {
	if (root == NULL)
		return 0;
	return TreeHeight(root->left) > TreeHeight(root->right)
		? TreeHeight(root->left) + 1 : TreeHeight(root->right) + 1;
}
//合理的写法：每层结点递归调用一次即可
int TreeHeight(BTNode* root) {
	if (root == NULL)
		return 0;
	int left = TreeHeight(root->left);
	int right = TreeHeight(root->right);
	return  left > right ? left + 1 : right + 1;
}

//二叉树第k层的结点数
int TreeLevelK(BTNode* root, int k) {
	if (root == NULL)
		return 0;
	if (k == 1)
		return 1;
	return TreeLevelK(root->left, k - 1) + TreeLevelK(root->right, k - 1);
}

// 二叉树叶子节点个数
int BinaryTreeLeafSize(BTNode* root) {
	if (root == NULL)
		return 0;
	if (!root->left && !root->right)
		return 1;
	return BinaryTreeLeafSize(root->left) + BinaryTreeLeafSize(root->right);
}

//二叉树查找值为x的结点
BTNode* BinaryTreeFind(BTNode* root, BTDataType x) {
	if (root == NULL)
		return NULL;
	if (root->data == x)
		return root;
	BTNode* leftnode = BinaryTreeFind(root->left, x);
	if (leftnode)
		return leftnode;
	BTNode* rightnode = BinaryTreeFind(root->right, x);
	return rightnode;
	//错误写法
	//return BinaryTreeFind(root->left, x) || BinaryTreeFind(root->right, x);
	// || 是逻辑运算符，返回真假，而不是结点
}
```

### 二叉树的创建与销毁

```c
// 通过前序遍历的数组"abc##de#g##f###"构建二叉树
BTNode* BinaryTreeCreate(BTDataType* a, int* pi) {
	if (a[*pi] == '#') {
		(*pi)++;
		return NULL;
	}
	BTNode* node = (BTNode*)malloc(sizeof(BTNode));
	if (node == NULL) {
		perror("malloc fail");
		return NULL;
	}
	node->data = a[(*pi)++];
	node->left = BinaryTreeCreate(a, pi);
	node->right = BinaryTreeCreate(a, pi);
	return node;
}
// 判断二叉树是否是完全二叉树
bool BinaryTreeComplete(BTNode* root) {
	Queue q;
	QueueInit(&q);
	if (root)
		QueuePush(&q, root);
	while (!QueueEmpty(&q)) {
		BTNode* front = QueueFront(&q);
		QueuePop(&q);
		if (front == NULL)
			break;
		else {
			QueuePush(&q, front->left);
			QueuePush(&q, front->right);
		}
	}
	while (!QueueEmpty(&q)) {
		BTNode* front = QueueFront(&q);
		QueuePop(&q);
		if (front) {
			QueueDestroy(&q);
			return false;
		}
	}
	QueueDestroy(&q);
	return true;
}
// 二叉树销毁
void BinaryTreeDestory(BTNode* root) {
	if (root == NULL)
		return;
	BinaryTreeDestory(root->left);
	BinaryTreeDestory(root->right);
	free(root);
}
```

### OJ练习

```c
//如果二叉树每个节点都具有相同的值，那么该二叉树就是单值二叉树。
bool isUnivalTree(struct TreeNode* root) {
	if (root == NULL)
		return true;
	if (root->left && root->val != root->left->val)
		return false;
	if (root->right && root->val != root->right->val)
		return false;
	return isUnivalTree(root->left) && isUnivalTree(root->right);
}
//给你两棵二叉树的根节点 p 和 q ，编写一个函数来检验这两棵树是否相同。如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。
bool isSameTree(struct TreeNode* p, struct TreeNode* q) {
	//都为空
	if (!p && !q)
		return true;
	//其中一个为空，一个不为空
	if (!p || !q)
		return false;
	//都不为空
	if (p->val != q->val)
		return false;
	//判断左右子树
	return isSameTree(p->left, q->left) && isSameTree(p->right, q->right);
}
//对称二叉树
bool SymmetricTree(struct TreeNode* leftroot, struct TreeNode* rightroot) {
	//都为空
	if (!leftroot && !rightroot)
		return true;
	//其中一个为空，一个不为空
	if (!leftroot || !rightroot)
		return false;
	//都不为空
	if (leftroot->val != rightroot->val)
		return false;
	//判断左右子树
	return SymmetricTree(leftroot->left, rightroot->right) && SymmetricTree(leftroot->right, rightroot->left);
}
bool isSymmetric(struct TreeNode* root) {
	if (root == NULL)
		return true;
	return SymmetricTree(root->left, root->right);
}
//前序遍历：中序后序都一样
int TreeSize(struct TreeNode* root) {
	return root == NULL ? 0 : TreeSize(root->left) + TreeSize(root->right) + 1;
}
void PreOrder(struct TreeNode* root, int* a, int* pi) {//这里数组下标利用传址调用，以便于递归调用时下标后移
	if (root == NULL)
		return;
	a[(*pi)++] = root->val;
	PreOrder(root->left, a, pi);
	PreOrder(root->right, a, pi);
}
int* preorderTraversal(struct TreeNode* root, int* returnSize) {
	*returnSize = TreeSize(root);
	int* a = (int*)malloc(sizeof(int) * (*returnSize));
	if (a == NULL) {
		perror("malloc fail");
		return NULL;
	}
	int i = 0;
	PreOrder(root, a, &i);
	return a;
}
//另一棵树的子树
bool isSubtree(struct TreeNode* root, struct TreeNode* subRoot) {
	if (root == NULL)
		return false;
	if (isSameTree(root, subRoot))
		return true;
	return isSubtree(root->left, subRoot) || isSubtree(root->right, subRoot);
}
```

# 排序

## 概念

<img src="C:\Users\q9384\AppData\Roaming\Typora\typora-user-images\image-20240519193344597.png" alt="image-20240519193344597" style="zoom:30%;" />



## 插入排序

插入排序的基本思想：把待排序的记录按其关键码值的大小逐个插入到一个已经排好序的有序序列中，直到所有的记录插入完为止，得到一个新的有序序列 。

### 直接插入排序

当插入第$i$个元素时，前$i-1$个元素已经有序，将第$i$个元素与前$i-1$个元素从后向前依次比较，找到插入位置，插入位置后面的元素顺序后移，将第i个元素插入

```c
// 插入排序
void InsertSort(int* a, int n) {
	for (int i = 1; i < n; i++) {
		int end = i - 1;
		int tmp = a[i];
		while (end >= 0) {
			if (tmp < a[end]) {
				a[end + 1] = a[end];
				--end;
			}
			else
				break;
		}
		a[end + 1] = tmp;
	}
}
```

> 直接插入排序的特性总结：
>
> 1. 元素集合越接近有序，直接插入排序算法的时间效率越高 
> 2. 时间复杂度：O(N^2^) 
> 3. 空间复杂度：O(1)，它是一种稳定的排序算法 
> 4. 稳定性：稳定

### 希尔排序

希尔排序法又称缩小增量法。希尔排序法的基本思想是：先选定一个整数gap，把待排序文件中所有记录分成个n/gap组，所有距离为gap的记录分在同一组内，并对每一组内的记录进行直接插入排序。然后缩减gap，取gap = gap / 2或/gap = gap / 3 + 1，重复上述分组和排序的工作。当到达gap==1时，所有记录在统一组内排好序。

```c
// 希尔排序
void ShellSort(int* a, int n) {
	int gap = n;
	while (gap > 1) {
		gap /= 2;
		//gap = gap / 3 + 1;
		for (int i = gap; i < n; i++) {
			int end = i - gap;
			int tmp = a[i];
			while (end >= 0) {
				if (tmp < a[end]) {
					a[end + gap] = a[end];
					end -= gap;
				}
				else
					break;
			}
			a[end + gap] = tmp;
		}
	}
}
```

> 希尔排序的特性总结：
>
> 1. 希尔排序是对直接插入排序的优化。 
> 2. 当gap > 1时都是预排序，目的是让数组更接近于有序。当gap == 1时，数组已经有序了。
> 3. 希尔排序的时间复杂度不好计算，因为gap的取值方法很多，导致很难去计算，暂时记为O(n^1.3^)
> 4. 稳定性：不稳定

## 选择排序

选择基本思想：依次从待排序的数据元素中选出最小（或最大）的一个元素，顺序存放在序列中，直到全部待排序的数据元素排完。

### 简单选择排序

每趟从待排元素中选出最大与最小元素，将最大与最小元素顺序存放在数组前与数组后的序列中，直至全部元素排序完毕。

```c
// 选择排序
void SelectSort(int* a, int n) {
	int left = 0, right = n - 1;
	int mini = 0, maxi = n - 1;
	while (left < right) {
		for (int i = left; i <= right; i++) {
			if (a[i] < a[mini])
				mini = i;
			if (a[i] > a[maxi])
				maxi = i;
		}
		Swap(&a[right], &a[maxi]);
		//当这趟的最小值下标位置与最大值放置的位置相同时，在交换完最大值时，最小值也被交换到最大值下标位置
		if (mini == right)
			mini = maxi;
		Swap(&a[left], &a[mini]);
		++left;
		--right;
	}
}
```

> 简单选择排序的特性总结：
>
> 1. 直接选择排序思考非常好理解，但是效率不是很好。实际中很少使用
> 2. 时间复杂度：O(N^2^) 
> 3. 空间复杂度：O(1) 
> 4. 稳定性：不稳定

### 堆排序

排升序要建大堆，排降序建小堆。详解见4.3

```c
// 堆排序（基于小根堆排序）
void AdjustDown(int* a, int n, int root) {
	int child = 2 * root + 1;
	int parent = root;
	while (child < n) {
		if (child + 1 < n && a[child] > a[child + 1])
			child += 1;
		if (a[parent] > a[child]) {
			Swap(&a[parent], &a[child]);
			parent = child;
			child = 2 * parent + 1;
		}
		else
			break;
	}
}
void HeapSort(int* a, int n) {
	//建小根堆
	for (int i = (n - 2) / 2; i >= 0; i--)
		AdjustDown(a, n, i);
	//调整堆，并排序
	for (int i = n - 1; i > 0; i--) {
		Swap(&a[i], &a[0]);
		AdjustDown(a, i, 0);
	}
}
```

> 堆排序的特性总结：
>
> 1. 堆排序使用堆来选数，效率就高了很多。 
> 2. 时间复杂度：O(N*logN) 
> 3. 空间复杂度：O(1) 
> 4. 稳定性：不稳定

## 交换排序

基本思想：所谓交换，就是根据序列中两个记录键值的比较结果来对换这两个记录在序列中的位置，交换排序的特点是：将键值较大的记录向序列的尾部移动，键值较小的记录向序列的前部移动。

### 冒泡排序

```c
// 冒泡排序
void BubbleSort(int* a, int n) {
	for (int i = 0; i < n - 1; i++) {
		bool exchange = false;
		for (int j = 1; j < n - i; j++)
			if (a[j - 1] > a[j]) {
				Swap(&a[j - 1], &a[j]);
				exchange = true;
			}
		if (exchange == false)
			break;
	}
}
```

> 冒泡排序的特性总结：
>
> 1. 冒泡排序是一种非常容易理解的排序
> 2. 时间复杂度：O(N^2^)
> 3. 空间复杂度：O(1)
> 4. 稳定性：稳定

### 快速排序

基本思想为：任取待排序元素序列中 的某元素作为基准值，按照该排序码将待排序集合分割成两子序列，左子序列中所有元素均小于基准值，右子序列中所有元素均大于基准值，然后最左右子序列重复该过程，直到所有元素都排列在相应位置上为止。

- 快速排序递归
  1. hoare
     右边指针找小于key的元素，左边指针找大于key的元素，两元素互换，直至左右指针相遇，key与相遇位置元素互换
  2. 挖坑法
     将key位置设为坑，右边指针找小于key的元素，填入坑并形成新坑，左边指针找大于key的元素，填入坑并设形成新坑，直至左右指针相遇，key放入相遇位置
  3. 前后指针
     1）cur找到比key小的值，++prev，cur和prev位置的值交换，++cur
     2）cur找到比key大的值，++cur
     说明：
     1）prev要么紧跟着cur(prev下一个就是cur)
     2）prev跟cur中间间隔着比key大的一段值区间

```c
// 快速排序递归实现
// 快速排序hoare版本
int PartSort1(int* a, int left, int right) {
	//三数取中
	int midi = GetMidNumi(a, left, right);
	if (midi != left)
		Swap(&a[left], &a[midi]);

	int keyi = left;
	while (left < right) {
		//右边找小
		while (left < right && a[right] >= a[keyi])
			right--;
		//左边找大
		while (left < right && a[left] <= a[keyi])
			left++;
		Swap(&a[left], &a[right]);
	}
	Swap(&a[left], &a[keyi]);
	return left;
}
// 快速排序挖坑法
int PartSort2(int* a, int left, int right) {
	//三数取中
	int midi = GetMidNumi(a, left, right);
	if (midi != left)
		Swap(&a[left], &a[midi]);

	int key = a[left];
	int hole = left;
	while (left < right) {
		//右边找小
		while (left < right && a[right] >= key)
			right--;
		a[hole] = a[right];
		hole = right;
		//左边找大
		while (left < right && a[left] <= key)
			left++;
		a[hole] = a[left];
		hole = left;
	}
	a[hole] = key;
	return hole;
}
// 快速排序前后指针法
int PartSort3(int* a, int left, int right) {
	//三数取中
	int midi = GetMidNumi(a, left, right);
	if (midi != left)
		Swap(&a[left], &a[midi]);

	int keyi = left;
	int prev = left;
	int cur = left + 1;
	while (cur <= right)
	{
		if (a[cur] < a[keyi] && ++prev != cur)
			Swap(&a[cur], &a[prev]);
		++cur;
	}
	Swap(&a[prev], &a[keyi]);
	keyi = prev;
	return keyi;
}
```

- 快速排序优化
  1. 随机选key
  2. 三数取中法选key 
  3. 递归到小的子区间时，可以考虑使用插入排序
  4. **三路划分**

```c
//随机选key
	int randi = left + (rand() % (right - left + 1));
	if (randi != left)
		Swap(&a[left], &a[randi]);
//三数取中
int GetMidNumi(int* a, int left, int right)
{
	int mid = (left + right) / 2;
	if (a[left] < a[mid])
	{
		if (a[mid] < a[right])
			return mid;
		else if (a[left] > a[right])
			return left;
		else
			return right;
	}
	else // a[left] > a[mid]
	{
		if (a[mid] > a[right])
			return mid;
		else if (a[left] < a[right])
			return left;
		else
			return right;
	}
}
//递归到小的子区间时，可以考虑使用插入排序
void QuickSort(int* a, int left, int right) {
	if (left >= right)
		return;
    
	if ((right - left + 1) > 10) {
		int keyi = PartSort3(a, left, right);
		QuickSort(a, left, keyi - 1);
		QuickSort(a, keyi + 1, right);
	}
	else//小区间插入排序
		InsertSort(a + left, right - left + 1);
}
```

**三路划分**的基本思想：
将比key小的值甩到左边，比key大的值甩到右边，与key相等的值留在中间，一趟排完后[begin,end]区间的值为与key相等的值，[left, begin - 1]区间的值为比key小的值，[end + 1, right]区间的值为比key大的值。

```c
//三路划分
void QuickSort2(int* a, int left, int right) {
	if (left >= right)
		return;
	if ((right - left + 1) > 10) {
		//三数取中
		int midi = GetMidNumi(a, left, right);
		if (midi != left)
			Swap(&a[left], &a[midi]);
		 
		int key = a[left];
		int begin = left, end = right;
		int cur = begin + 1;
		while (cur <= end)
		{
			if (a[cur] < key) {
				Swap(&a[begin], &a[cur]);
				begin++;
				cur++;
			}
			else if (a[cur] > key) {
				Swap(&a[end], &a[cur]);
				end--;
			}
			else
				cur++;
		}
		QuickSort(a, left, begin - 1);
		QuickSort(a, end + 1, right);
	}
	else//小区间插入排序
		InsertSort(a + left, right - left + 1);
}
```

- 快速排序非递归

  > 递归的问题：1. 效率不如非递归。 2. 递归深度太深会栈溢出。
  >
  > 递归改非递归：1. 直接改循环。 2. 使用栈辅助。

```c
// 快速排序非递归实现
void QuickSortNonR(int* a, int left, int right) {
	Stack st;
	StackInit(&st);
	StackPush(&st, right);
	StackPush(&st, left);
	while (!StackEmpty(&st)) {
		int begin = StackTop(&st);
		StackPop(&st);
		int end = StackTop(&st);
		StackPop(&st);
		int div = PartSort1(a, begin, end);
		if (begin < div - 1) {
			StackPush(&st, div - 1);
			StackPush(&st, begin);
		}
		if (div + 1 < end) {
			StackPush(&st, end);
			StackPush(&st, div + 1);
		}
	}
	StackDestroy(&st);
}
```

> 快速排序的特性总结：
>
> 1. 快速排序整体的综合性能和使用场景都是比较好的，所以才敢叫快速排序
> 2. 时间复杂度：O(N*logN)
> 3. 空间复杂度：O(logN) 
> 4. 稳定性：不稳定

## 归并排序

归并排序（MERGE-SORT）是建立在归并操作上的一种有效的排序算法，该算法是采用**分治法**（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为**二路归并**。

<img src="C:\Users\q9384\AppData\Roaming\Typora\typora-user-images\image-20240519220400750.png" alt="image-20240519220400750" style="zoom: 50%;" />

```c
// 归并排序递归实现
void _MergeSort(int* a, int left, int right, int* tmp) {
	if (left >= right)
		return;
	int mid = (left + right) / 2;
	_MergeSort(a, left, mid, tmp);
	_MergeSort(a, mid + 1, right, tmp);
	int begin1 = left, end1 = mid;
	int begin2 = mid + 1, end2 = right;
	int i = left;
	while (begin1 <= end1 && begin2 <= end2) {
		if (a[begin1] < a[begin2])
			tmp[i++] = a[begin1++];
		else
			tmp[i++] = a[begin2++];
	}
	while (begin1 <= end1)
		tmp[i++] = a[begin1++];
	while (begin2 <= end2)
		tmp[i++] = a[begin2++];
	memcpy(a + left, tmp + left, sizeof(int) * (right - left + 1));
}
void MergeSort(int* a, int n) {
	int* tmp = (int*)malloc(sizeof(int) * n);
	if (tmp == NULL) {
		perror("malloc fail");
		return;
	}
	_MergeSort(a, 0, n - 1, tmp);
	free(tmp);
}
// 归并排序非递归实现
void MergeSortNonR(int* a, int n) {
	int gap = 1;
	int* tmp = (int*)malloc(sizeof(int) * n);
	if (tmp == NULL) {
		perror("malloc fail");
		return;
	}
	while (gap < n) {
		for (int i = 0; i < n; i += 2 * gap) {
			int begin1 = i, end1 = i + gap - 1;
			int begin2 = i + gap, end2 = i + 2 * gap - 1;
			////修正路线1
			//if (end1 >= n) {
			//	end1 = n - 1;
			//	begin2 = n;
			//	end2 = n - 1;
			//}
			//else if (begin2 >= n) {
			//	begin2 = n;
			//	end2 = n - 1;
			//}
			//else if (end2 >= n) {
			//	end2 = n - 1;
			//}

			//修正路线2
			if (begin2 >= n)
				break;
			else if (end2 >= n)
				end2 = n - 1;
			printf("[%d,%d] [%d,%d] ", begin1, end1, begin2, end2);
			int k = i;
			while (begin1 <= end1 && begin2 <= end2) {
				if (a[begin1] < a[begin2])
					tmp[k++] = a[begin1++];
				else
					tmp[k++] = a[begin2++];
			}
			while (begin1 <= end1)
				tmp[k++] = a[begin1++];
			while (begin2 <= end2)
				tmp[k++] = a[begin2++];
			//修正路线2
			memcpy(a + i, tmp + i, sizeof(int) * (k - i));
		}
		printf("\n");
		//修正路线1
		//memcpy(a, tmp, sizeof(int) * n);
		gap *= 2;
	}
}
```

> 归并排序的特性总结：
>
> 1. 归并的缺点在于需要O(N)的空间复杂度，归并排序的思考更多的是解决在磁盘中的外排序问题。
> 2. 时间复杂度：O(N*logN)
> 3. 空间复杂度：O(N)
> 4. 稳定性：稳定

##  非比较排序

### 计数排序

思想：计数排序又称为鸽巢原理，是对哈希直接定址法的变形应用。 

操作步骤：

 	1. 统计相同元素出现次数 
 	2. 根据统计的结果将序列回收到原来的序列中

```c
// 计数排序
void CountSort(int* a, int n) {
	int min = a[0], max = a[0];
	for (int i = 1; i < n; i++) {
		if (min > a[i])
			min = a[i];
		if (max < a[i])
			max = a[i];
	}
	int range = max - min + 1;
	int* count = (int*)malloc(sizeof(int) * range);
	if (count == NULL) {
		perror("malloc fail");
		return;
	}
	memset(count, 0, sizeof(int) * range);
	//1. 统计相同元素出现次数
	for (int i = 0; i < n; i++)
		count[a[i] - min]++;
	//2. 根据统计的结果将序列回收到原来的序列中
	int j = 0;
	for (int i = 0; i < range; i++)
		while (count[i]--)
			a[j++] = min + i;
	free(count);
}
```

> 计数排序的特性总结：
>
> 1. 计数排序在数据范围集中时，效率很高，但是适用范围及场景有限。
> 2. 时间复杂度：O(MAX(N,range) 
> 3. 空间复杂度：O(range) 
> 4. 稳定性：稳定

## 排序算法复杂度及稳定性分析

```c
//测试排序的性能对比
void TestOP(){
	srand(time(0));
	const int N = 100000;
	int* a1 = (int*)malloc(sizeof(int) * N);
	int* a2 = (int*)malloc(sizeof(int) * N);
	int* a3 = (int*)malloc(sizeof(int) * N);
	int* a4 = (int*)malloc(sizeof(int) * N);
	int* a5 = (int*)malloc(sizeof(int) * N);
	int* a6 = (int*)malloc(sizeof(int) * N);
	for (int i = 0; i < N; ++i){
		a1[i] = rand();
		a2[i] = a1[i];
		a3[i] = a1[i];
		a4[i] = a1[i];
		a5[i] = a1[i];
		a6[i] = a1[i];
	}
	int begin1 = clock();
	InsertSort(a1, N);
	int end1 = clock();

	int begin2 = clock();
	ShellSort(a2, N);
	int end2 = clock();

	int begin3 = clock();
	SelectSort(a3, N);
	int end3 = clock();

	int begin4 = clock();
	HeapSort(a4, N);
	int end4 = clock();

	int begin5 = clock();
	QuickSort(a5, 0, N - 1);
	int end5 = clock();

	int begin6 = clock();
	MergeSort(a6, N);
	int end6 = clock();

	printf("InsertSort:%d\n", end1 - begin1);
	printf("ShellSort:%d\n", end2 - begin2);
	printf("SelectSort:%d\n", end3 - begin3);
	printf("HeapSort:%d\n", end4 - begin4);
	printf("QuickSort:%d\n", end5 - begin5);
	printf("MergeSort:%d\n", end6 - begin6);
	free(a1);
	free(a2);
	free(a3);
	free(a4);
	free(a5);
	free(a6);
}
//InsertSort:3405
//ShellSort : 17
//SelectSort : 4199
//HeapSort : 17
//QuickSort : 10
//MergeSort : 10
```

|   排序方法   | 平均情况  | 最好情况 | 最坏情况 | 辅助空间      | 稳定性 |
| :----------: | :-------- | -------- | -------- | ------------- | :----: |
|   冒泡排序   | O(n^2^)   | O(n)     | O(n^2^)  | O(1)          |  稳定  |
| 简单选择排序 | O(n^2^)   | O(n^2^)  | O(n^2^)  | O(1)          | 不稳定 |
| 直接插入排序 | O(n^2^)   | O(n)     | O(n^2^)  | O(1)          |  稳定  |
|   希尔排序   | O(n^1.3^) |          | O(n^2^)  | O(1)          | 不稳定 |
|    堆排序    | O(nlogn)  | O(nlogn) | O(nlogn) | O(1)          | 不稳定 |
|   归并排序   | O(nlogn)  | O(nlogn) | O(nlogn) | O(n)          |  稳定  |
|   快速排序   | O(nlogn)  | O(nlogn) | O(n^2^)  | O(nlogn)~O(n) | 不稳定 |

